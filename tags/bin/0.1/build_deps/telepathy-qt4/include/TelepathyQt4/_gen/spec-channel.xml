<?xml version="1.0" ?><tp:spec xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0" xmlns:xi="http://www.w3.org/2001/XInclude">

<tp:title>Channel interfaces</tp:title>

<node name="/Channel" xml:base="../spec/Channel.xml">
  <tp:copyright>Copyright © 2005-2009 Collabora Limited</tp:copyright>
  <tp:copyright>Copyright © 2005-2009 Nokia Corporation</tp:copyright>
  <tp:copyright>Copyright © 2006 INdT</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel">

    <property access="read" name="ChannelType" tp:name-for-bindings="Channel_Type" tp:type="DBus_Interface" type="s">
      <tp:added version="0.17.7"/>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The channel's type. This cannot change once the channel has
          been created.</p>

        <p>For compatibility between older connection managers and newer
          clients, if this is unavailable or is an empty string,
          clients MUST use the result of calling
          <tp:member-ref>GetChannelType</tp:member-ref>.</p>

        <tp:rationale>
          The GetAll method lets clients retrieve all properties in one
          round-trip, which is desirable.
        </tp:rationale>

        <p>When requesting a channel, the request MUST specify a channel
          type, and the request MUST fail if the specified channel type
          cannot be supplied.</p>

        <tp:rationale>
          Common sense.
        </tp:rationale>
      </tp:docstring>
    </property>

    <property access="read" name="Interfaces" tp:name-for-bindings="Interfaces" tp:type="DBus_Interface[]" type="as">
      <tp:added version="0.17.7"/>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Extra interfaces provided by this channel. This SHOULD NOT include
          the channel type and the Channel interface itself, and cannot
          change once the channel has been created.</p>

        <p>For compatibility between older connection managers and newer
          clients, if this is unavailable, or if this is an empty list and
          <tp:member-ref>ChannelType</tp:member-ref> is an empty string,
          clients MUST use the result of calling
          <tp:member-ref>GetInterfaces</tp:member-ref> instead. If this is an
          empty list but ChannelType is non-empty, clients SHOULD NOT call
          GetInterfaces; this implies that connection managers that implement
          the ChannelType property MUST also implement the Interfaces property
          correctly.</p>

        <tp:rationale>
          The GetAll method lets clients retrieve all properties in one
          round-trip, which is desirable.
        </tp:rationale>

        <p>When requesting a channel with a particular value for this
          property, the request must fail without side-effects unless the
          connection manager expects to be able to provide a channel whose
          interfaces include at least the interfaces requested.</p>
      </tp:docstring>
    </property>

    <property access="read" name="TargetHandle" tp:name-for-bindings="Target_Handle" tp:type="Handle" type="u">
      <tp:added version="0.17.7"/>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The handle (a representation for the identifier) of the contact,
          chatroom, etc. with which this handle communicates. Its type
          is given by the <tp:member-ref>TargetHandleType</tp:member-ref>
          property.</p>

        <p>This is fixed for the lifetime of the channel, so channels which
          could potentially be used to communicate with multiple contacts
          (such as streamed media calls defined by their members, or ad-hoc
          chatrooms like MSN switchboards) must have TargetHandleType set
          to Handle_Type_None and TargetHandle set to 0.</p>

        <p>Unlike in the telepathy-spec 0.16 API, there is no particular
          uniqueness guarantee - there can be many channels with the same
          (channel type, handle type, handle) tuple. This is necessary
          to support conversation threads in XMPP and SIP, for example.</p>

        <p>If this is present in a channel request, it must be nonzero,
          <tp:member-ref>TargetHandleType</tp:member-ref>
          MUST be present and not Handle_Type_None, and
          <tp:member-ref>TargetID</tp:member-ref> MUST NOT be
          present.</p>

        <p>The channel that satisfies the request MUST either:</p>

        <ul>
          <li>have the specified TargetHandle property; or</li>
          <li>have <tp:member-ref>TargetHandleType</tp:member-ref> =
            Handle_Type_None, TargetHandle = 0, and be configured such that
            it could communicate with the specified handle in some other way
            (e.g. have the requested contact handle in its Group
            interface)</li>
        </ul>
      </tp:docstring>
    </property>

    <property access="read" name="TargetID" tp:name-for-bindings="Target_ID" type="s">
      <tp:added version="0.17.9"/>

      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The string that would result from inspecting the
          <tp:member-ref>TargetHandle</tp:member-ref>
          property (i.e. the identifier in the IM protocol of the contact,
          room, etc. with which this channel communicates), or the empty
          string if the TargetHandle is 0.</p>

        <tp:rationale>
          <p>The presence of this property avoids the following race
            condition:</p>

          <ul>
            <li>New channel C is signalled with target handle T</li>
            <li>Client calls <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
              [T])</li>
            <li>Channel C closes, removing the last reference to handle T</li>
            <li><tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
              [T]) returns an error</li>
          </ul>
        </tp:rationale>

        <p>If this is present in a channel request,
          <tp:member-ref>TargetHandleType</tp:member-ref>
          MUST be present and not Handle_Type_None, and
          <tp:member-ref>TargetHandle</tp:member-ref> MUST NOT be
          present. The request MUST fail with error InvalidHandle, without
          side-effects, if the requested TargetID would not be accepted by
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestHandles</tp:dbus-ref>.</p>

        <p>The returned channel must be related to the handle corresponding
          to the given identifier, in the same way as if TargetHandle
          had been part of the request instead.</p>

        <tp:rationale>
          <p>Requesting channels with a string identifier saves a round-trip
            (the call to RequestHandles). It also allows the channel
            dispatcher to accept a channel request for an account that is not
            yet connected (and thus has no valid handles), bring the account
            online, and pass on the same parameters to the new connection's
            CreateChannel method.</p>
        </tp:rationale>
      </tp:docstring>
    </property>

    <property access="read" name="TargetHandleType" tp:name-for-bindings="Target_Handle_Type" tp:type="Handle_Type" type="u">
      <tp:added version="0.17.7"/>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The type of <tp:member-ref>TargetHandle</tp:member-ref>.</p>

        <p>If this is omitted from a channel request, connection managers
          SHOULD treat this as equivalent to Handle_Type_None.</p>

        <p>If this is omitted or is Handle_Type_None,
          <tp:member-ref>TargetHandle</tp:member-ref> and
          <tp:member-ref>TargetID</tp:member-ref> MUST be omitted from the
          request.</p>
      </tp:docstring>
    </property>

    <method name="Close" tp:name-for-bindings="Close">
      <tp:docstring>
        Request that the channel be closed. This is not the case until
        the <tp:member-ref>Closed</tp:member-ref> signal has been emitted, and
        depending on the connection
        manager this may simply remove you from the channel on the server,
        rather than causing it to stop existing entirely. Some channels
        such as contact list channels may not be closed.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            This channel may never be closed, e.g. a contact list
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            This channel is not currently in a state where it can be closed,
            e.g. a non-empty user-defined contact group
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="Closed" tp:name-for-bindings="Closed">
      <tp:docstring>
        Emitted when the channel has been closed. Method calls on the
        channel are no longer valid after this signal has been emitted,
        and the connection manager may then remove the object from the bus
        at any point.
      </tp:docstring>
    </signal>

    <method name="GetChannelType" tp:name-for-bindings="Get_Channel_Type">
      <tp:deprecated version="0.17.7">Use the ChannelType
        property if possible.</tp:deprecated>
      <arg direction="out" name="Channel_Type" tp:type="DBus_Interface" type="s">
        <tp:docstring>The interface name</tp:docstring>
      </arg>
      <tp:docstring>
        Returns the interface name for the type of this channel.  Clients
        SHOULD use the <tp:member-ref>ChannelType</tp:member-ref> property
        instead, falling back to this method only if necessary.

        <tp:rationale>
          The GetAll method lets clients retrieve all properties in one
          round-trip.
        </tp:rationale>
      </tp:docstring>
    </method>

    <method name="GetHandle" tp:name-for-bindings="Get_Handle">
      <tp:deprecated version="0.17.7">Use the TargetHandleType
        and TargetHandle properties if possible.</tp:deprecated>
      <arg direction="out" name="Target_Handle_Type" tp:type="Handle_Type" type="u">
        <tp:docstring>
          The same as TargetHandleType.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Target_Handle" tp:type="Handle" type="u">
        <tp:docstring>
          The same as TargetHandle.
        </tp:docstring>
      </arg>
      <tp:docstring>
        Returns the handle type and number if this channel represents a
        communication with a particular contact, room or server-stored list, or
        zero if it is transient and defined only by its contents. Clients
        SHOULD use the <tp:member-ref>TargetHandle</tp:member-ref> and
        <tp:member-ref>TargetHandleType</tp:member-ref> properties instead,
        falling back to this method only if necessary.

        <tp:rationale>
          The GetAll method lets clients retrieve all properties in one
          round-trip.
        </tp:rationale>
      </tp:docstring>
    </method>

    <method name="GetInterfaces" tp:name-for-bindings="Get_Interfaces">
      <tp:deprecated version="0.17.7">Use the Interfaces
        property if possible.</tp:deprecated>
      <arg direction="out" name="Interfaces" tp:type="DBus_Interface[]" type="as">
        <tp:docstring>
          An array of the D-Bus interface names
        </tp:docstring>
      </arg>
      <tp:docstring>
        Get the optional interfaces implemented by the channel.
        Clients SHOULD use the <tp:member-ref>Interfaces</tp:member-ref>
        property instead, falling back to this method only if necessary.

        <tp:rationale>
          The GetAll method lets clients retrieve all properties in one
          round-trip.
        </tp:rationale>
      </tp:docstring>
    </method>

    <property access="read" name="Requested" tp:name-for-bindings="Requested" type="b">
      <tp:added version="0.17.13">(as stable API)</tp:added>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>True if this channel was created in response to a local request,
          such as a call to
          <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.RequestChannel</tp:dbus-ref>
          or
          <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>.</p>

        <tp:rationale>
          <p>The idea of this property is to distinguish between &quot;incoming&quot;
            and &quot;outgoing&quot; channels, in a way that doesn't break down when
            considering special cases like contact lists that are automatically
            created on connection to the server, or chatrooms that an
            IRC proxy/bouncer like irssi-proxy or bip was already in.</p>

          <p>The reason we want to make that distinction is that UIs for
            things that the user explicitly requested should start up
            automatically, whereas for incoming messages and VoIP calls we
            should first ask the user whether they want to open the messaging
            UI or accept the call.</p>
        </tp:rationale>

        <p>If the channel was not explicitly requested (even if it was
          created as a side-effect of a call to one of those functions,
          e.g. because joining a Tube in a MUC context on XMPP implies
          joining that MUC), then this property is false.</p>

        <p>For compatibility with older connection managers, clients SHOULD
          assume that this property is true if they see a channel announced
          by the
          <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.NewChannel</tp:dbus-ref>
          signal with the suppress_handler parameter set to true.</p>

        <tp:rationale>
          <p>In a correct connection manager, the only way to get such a
            channel is to request it.</p>
        </tp:rationale>

        <p>Clients MAY additionally assume that this property is false
          if they see a channel announced by the NewChannel signal with the
          suppress_handler parameter set to false.</p>

        <tp:rationale>
          <p>This is more controversial, since it's possible to get that
            parameter set to false by requesting a channel. However, there's
            no good reason to do so, and we've deprecated this practice.</p>

          <p>In the particular case of the channel dispatcher, the only
            side-effect of wrongly thinking a channel is unrequested
            is likely to be that the user has to confirm that they want to
            use it, so it seems fairly harmless to assume in the channel
            dispatcher that channels with suppress_handler false are
            indeed unrequested.</p>
        </tp:rationale>

        <p>It does not make sense for this property to be in channel
          requests—it will always be true for channels returned by
          CreateChannel, and callers of EnsureChannel cannot control whether an
          existing channel was originally requested locally—so it MUST NOT
          be accepted.</p>
      </tp:docstring>
    </property>

    <property access="read" name="InitiatorHandle" tp:name-for-bindings="Initiator_Handle" tp:type="Contact_Handle" type="u">
      <tp:added version="0.17.13">(as stable API)</tp:added>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The contact who initiated the channel. For channels requested by the
          local user, this MUST be the value of
          <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.SelfHandle</tp:dbus-ref>
          at the time the channel was created (i.e. not a channel-specific
          handle).</p>

        <tp:rationale>
          <p>The careful wording about the self-handle is because the Renaming
            interface can cause the return from Connection.GetSelfHandle to
            change. It's something of a specification bug that we don't signal
            this in the Connection interface yet.</p>
        </tp:rationale>

        <p>For channels requested by a remote user, this MUST be their handle.
          If unavailable or not applicable, this MUST be 0 (for instance,
          contact lists are not really initiated by anyone in particular, and
          it's easy to imagine a protocol where chatroom invitations can be
          anonymous).</p>

        <p>For channels with the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group</tp:dbus-ref>
          interface, this SHOULD be the same
          contact who is signalled as the &quot;Actor&quot; causing the self-handle
          to be placed in the local-pending set.</p>

        <p>This SHOULD NOT be a channel-specific handle, if possible.</p>

        <p>It does not make sense for this property to be in channel
          requests - the initiator will always be the local user - so it
          MUST NOT be accepted.</p>
      </tp:docstring>
    </property>

    <property access="read" name="InitiatorID" tp:name-for-bindings="Initiator_ID" type="s">
      <tp:added version="0.17.13">(as stable API)</tp:added>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The string that would result from inspecting the
          <tp:member-ref>InitiatorHandle</tp:member-ref>
          property (i.e. the initiator's identifier in the IM protocol).</p>

        <tp:rationale>
          <p>The presence of this property avoids the following race
            condition:</p>

          <ul>
            <li>New StreamedMedia channel C is signalled with initiator
              handle I</li>
            <li>Client calls <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
              [I])</li>
            <li>Channel C closes, removing the last reference to handle I</li>
            <li><tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
              [I]) returns an error</li>
            <li>Client can indicate that a call was missed, but not who
              called!</li>
          </ul>
        </tp:rationale>

        <p>It does not make sense for this property to be in channel
          requests - the initiator will always be the local user - so it
          MUST NOT be accepted.</p>
      </tp:docstring>
    </property>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
    <p>All communication in the Telepathy framework is carried out via channel
    objects which are created and managed by connections. This interface must
    be implemented by all channel objects, along with one single channel type,
    such as <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Type.ContactList</tp:dbus-ref>
    which represents a list of people (such as a buddy list) or a <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Type.Text</tp:dbus-ref> which
    represents a channel over which textual messages are sent and received.</p>

    <p>Each Channel's object path MUST start with the object path of
      its associated <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection</tp:dbus-ref>, followed
      by '/'. There MAY be any number of additional object-path components,
      which clients MUST NOT attempt to parse.</p>

    <tp:rationale>
      <p>This ensures that Channel object paths are unique, even between
        Connections and CMs, because Connection object paths are
        guaranteed-unique via their link to the well-known bus name.</p>

      <p>If all connection managers in use are known to comply with at least
        spec version 0.17.10, then the Connection's object path can
        even be determined from the Channel's without any additional
        information, by taking the first 7 components.</p>
    </tp:rationale>

    <p>Each channel may have an immutable handle associated with it, which
      may be any handle type, such as a contact, room or list handle,
      indicating that the channel is for communicating with that handle.</p>

    <p>If a channel does not have a handle (an &quot;anonymous channel&quot; with
      Target_Handle = 0 and Target_Handle_Type = Handle_Type_None), it
      means that the channel is defined by some other terms, such as it
      may be a transient group defined only by its members as visible
      through the <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Group</tp:dbus-ref>
      interface.</p>

    <p>Other optional interfaces can be implemented to indicate other available
      functionality, such as <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Group</tp:dbus-ref>
      if the channel contains a number of contacts, <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Password</tp:dbus-ref>
      to indicate that a channel may have a password set to require entry, and
      <tp:dbus-ref namespace="org.freedesktop.Telepathy">Properties</tp:dbus-ref> for
      extra data about channels which represent chat rooms or voice calls. The
      interfaces implemented may not vary after the channel's creation has been
      signalled to the bus (with the connection's <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">NewChannel</tp:dbus-ref>
      signal).</p>

    <p>Specific connection manager implementations may implement channel types and
    interfaces which are not contained within this specification in order to
    support further functionality. To aid interoperability between client and
    connection manager implementations, the interfaces specified here should be
    used wherever applicable, and new interfaces made protocol-independent
    wherever possible. Because of the potential for 3rd party interfaces adding
    methods or signals with conflicting names, the D-Bus interface names should
    always be used to invoke methods and bind signals.</p>
    </tp:docstring>

    <tp:changed version="0.17.7">Previously we guaranteed that, for
      any handle type other than Handle_Type_None, and for any channel type
      and any handle, there would be no more than one channel with that
      combination of channel type, handle type and handle. This guarantee
      has now been removed in order to accommodate features like message
      threads.
    </tp:changed>

    <tp:changed version="0.17.10">Previously we did not explicitly
      guarantee that Channels' object paths had the Connection's object path
      as a prefix.
    </tp:changed>
  </interface>
</node>

<node name="/Channel_Type_Contact_List" xml:base="../spec/Channel_Type_Contact_List.xml">
  <tp:copyright> Copyright (C) 2005, 2006 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright (C) 2005, 2006 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright (C) 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.ContactList">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Interface.Group"/>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel type for representing a list of people on the server which is
    not used for communication. This is intended for use with the interface
    <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Group</tp:dbus-ref>
    for managing buddy lists and privacy lists
    on the server. This channel type has no methods because all of the
    functionality it represents is available via the group interface.</p>

    <p>There are currently two types of contact list:
    HANDLE_TYPE_LIST is a &quot;magic&quot; server-defined list, and
    HANDLE_TYPE_GROUP is a user-defined contact group.</p>

    <p>For server-defined lists like the subscribe list, singleton instances
    of this channel type should be created by the connection manager at
    connection time if the list exists on the server, or may be requested
    by using the appropriate handle.  These handles can be obtained using
    <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestHandles</tp:dbus-ref>
    with a <tp:type>Handle_Type</tp:type> of HANDLE_TYPE_LIST and one of the
    following identifiers:</p>

    <ul>
      <li>subscribe - the group of contacts for whom you receive presence</li>
      <li>publish - the group of contacts who may receive your presence</li>
      <li>hide - a group of contacts who are on the publish list but are temporarily disallowed from receiving your presence</li>
      <li>allow - a group of contacts who may send you messages</li>
      <li>deny - a group of contacts who may not send you messages</li>
      <li>stored - on protocols where the user's contacts are stored, this
      contact list contains all stored contacts regardless of subscription
      status.</li>
    </ul>

    <p>A contact can be in several server-defined lists. All lists are optional
    to implement. If <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestHandles</tp:dbus-ref>
    or <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestChannel</tp:dbus-ref>
    for a particular contact list raises an error, this indicates that the
    connection manager makes no particular statement about the list's contents;
    clients MUST NOT consider this to be fatal.</p>

    <p>If a client wants to list all of a user's contacts, it is appropriate to
    use the union of the subscribe, publish and stored lists, including the
    local and remote pending members.</p>

    <p>For example in XMPP, contacts who have the subscription type &quot;none&quot;,
    &quot;from&quot;, &quot;to&quot; and &quot;both&quot; can be respectively in the lists:</p>

    <ul>
      <li>&quot;none&quot;: stored</li>
      <li>&quot;from&quot;: stored and publish</li>
      <li>&quot;to&quot;: stored and subscribe</li>
      <li>&quot;both&quot;: stored, publish and subscribe</li>
    </ul>

    <p>These contact list channels may not be closed.</p>

    <p>For user-defined contact groups, instances of this channel type should
    be created by the connection manager at connection time for each group
    that exists on the server. New, empty groups can be created by calling
    <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestHandles</tp:dbus-ref>
    with a <tp:type>Handle_Type</tp:type> of HANDLE_TYPE_GROUP and with the
    name set to the human-readable UTF-8 name of the group.</p>

    <p>User-defined groups may be deleted by calling <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Close</tp:dbus-ref> on the
    channel, but only if
    the group is already empty. Closing a channel to a non-empty group is
    not allowed; its members must be set to the empty set first.</p>

    <p>On some protocols (e.g. XMPP) empty groups are not represented on the
    server, so disconnecting from the server and reconnecting might cause
    empty groups to vanish.</p>
    </tp:docstring>

  </interface>
</node>
<node name="/Channel_Type_File_Transfer" xml:base="../spec/Channel_Type_File_Transfer.xml">
  <tp:copyright>
    Copyright © 2008-2009 Collabora Limited
  </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.FileTransfer">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:added version="0.17.18">(as stable API)</tp:added>
    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel type for transferring files. The
      transmission of data between contacts is achieved by reading from
      or writing to a socket. The type of the socket (local Unix, IPv4,
      etc.) is decided on when the file transfer is offered or accepted.</p>

      <p>A socket approach is used to make the transfer less dependent on both
      client and connection manager knowing the same protocols. As an example,
      when browsing an SMB share in a file manager, one selects &quot;Send file&quot;
      and chooses a contact. Instead of passing a URL which would then require
      the connection manager to connect to the SMB share itself, the client
      passes a stream from which the connection manager reads, requiring no
      further connection to the share. It also allows connection managers to
      be more restricted in their access to the system, allowing tighter
      security policies with eg SELinux, or more flexible deployments which
      cross user or system boundaries.</p>

      <p>The Telepathy client should connect to the socket or address that
      the connection manager has set up and provided back to the clients
      through the two methods.</p>

      <ul><li>In order to send a file, one should request a FileTransfer
      channel for a contact, including at least the mandatory properties
      (<tp:member-ref>Filename</tp:member-ref>,
      <tp:member-ref>Size</tp:member-ref> and <tp:member-ref>ContentType</tp:member-ref>).
      Then, one should
      call <tp:member-ref>ProvideFile</tp:member-ref> to configure the socket that
      will be used to transfer the file.</li>

      <li>In order to receive an incoming file transfer, one should call
      <tp:member-ref>AcceptFile</tp:member-ref> and then wait until the state
      changes to Open. When the receiver wants to resume a transfer, the Offset
      argument should be should be set to a non-zero value when calling
      <tp:member-ref>AcceptFile</tp:member-ref>.</li>

    <li>Once the offset has been negotiated, the
      <tp:member-ref>InitialOffsetDefined</tp:member-ref> signal
      is emitted and the <tp:member-ref>InitialOffset</tp:member-ref> property
      is defined. The <tp:member-ref>InitialOffsetDefined</tp:member-ref>
      signal is emitted before channel becomes Open.
      The receiver MUST check the value of
      <tp:member-ref>InitialOffset</tp:member-ref> for a difference in offset
      from the requested value in AcceptFile.</li>

      <li>When the state changes to Open, Clients can start the transfer of the
      file using the offset previously announced.
      </li></ul>

      <p>If something goes wrong with the transfer,
      <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Close</tp:dbus-ref>
      should be called on the channel.</p>

      <p>The File channel type may be requested for handles of type
      HANDLE_TYPE_CONTACT. If the channel is requested for any other
      handle type then the behaviour is undefined.</p>

      <p>Connection managers SHOULD NOT advertise support for file transfer to
        other contacts unless it has been indicated by a call to
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities.DRAFT">SetSelfCapabilities</tp:dbus-ref>.
      </p>
      <tp:rationale>
        <p>People would send us files, and it would always fail. That would be silly.</p>
      </tp:rationale>
    </tp:docstring>

    <property access="read" name="State" tp:name-for-bindings="State" tp:type="File_Transfer_State" type="u">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The state of the file transfer as described by the
        File_Transfer_State enum.</p>
      </tp:docstring>
    </property>

    <property access="read" name="ContentType" tp:name-for-bindings="Content_Type" type="s">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The file's MIME type. This cannot change once the channel has
        been created.</p>

        <p>This property is mandatory when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. Protocols which do not have a content-type property with file
        transfers should set this value to application/octet-stream.</p>
      </tp:docstring>
    </property>

    <property access="read" name="Filename" tp:name-for-bindings="Filename" type="s">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The name of the file on the sender's side. This is therefore given
        as a suggested filename for the receiver. This cannot change
        once the channel has been created.</p>

        <p>This property should be the basename of the file being sent. For example,
        if the sender sends the file /home/user/monkey.pdf then this property should
        be set to monkey.pdf.</p>

        <p>This property is mandatory when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. This property cannot be empty and MUST be set to a sensible value.</p>
      </tp:docstring>
    </property>

    <property access="read" name="Size" tp:name-for-bindings="Size" type="t">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The size of the file. If this property is set, then the file
        transfer is guaranteed to be this size. This cannot change once
        the channel has been created.</p>

        <p>When you are creating a channel with this property, its value
        MUST be accurate and in bytes. However, when receiving a file, this
        property still MUST be in bytes but might not be entirely accurate
        to the byte.</p>

        <p>This property is mandatory when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. If this information isn't provided in the protocol, connection managers MUST set it
        to UINT64_MAX.</p>
      </tp:docstring>
    </property>

    <property access="read" name="ContentHashType" tp:name-for-bindings="Content_Hash_Type" tp:type="File_Hash_Type" type="u">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The type of the <tp:member-ref>ContentHash</tp:member-ref> property.</p>

        <p>This property is optional when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. However, if you wish to include the <tp:member-ref>ContentHash</tp:member-ref>
        property you MUST also include this property. If you omit this property from a
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method call then its value will be assumed to be File_Hash_Type_None.</p>

        <p>For each supported hash type, implementations SHOULD include an entry
          in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">RequestableChannelClasses</tp:dbus-ref>
          with this property fixed to that hash type. If the protocol supports
          offering a file without a content hash, implementations SHOULD list
          this property in Allowed in a requestable channel class, mapping hash
          types they don't understand to None.
        </p>
      </tp:docstring>
    </property>

    <property access="read" name="ContentHash" tp:name-for-bindings="Content_Hash" type="s">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Hash of the contents of the file transfer, of type described
        in the value of the <tp:member-ref>ContentHashType</tp:member-ref>
        property.</p>

        <p>This property is optional when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. Its value MUST correspond to the appropriate type of the
        <tp:member-ref>ContentHashType</tp:member-ref> property. If the
        ContentHashType property is not set, or set to File_Hash_Type_None,
        then this property will not even be looked at.</p>
      </tp:docstring>
    </property>

    <property access="read" name="Description" tp:name-for-bindings="Description" type="s">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Description of the file transfer. This cannot change once the
        channel has been created.</p>

        <p>This property is optional when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method. If this property was not provided by the remote party, connection managers MUST set it to
        the empty string.</p>
      </tp:docstring>
    </property>

    <property access="read" name="Date" tp:name-for-bindings="Date" tp:type="Unix_Timestamp64" type="x">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The last modification time of the file being transferred. This
        cannot change once the channel has been created</p>

        <p>This property is optional when requesting the channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
        method.</p>
      </tp:docstring>
    </property>

    <property access="read" name="AvailableSocketTypes" tp:name-for-bindings="Available_Socket_Types" tp:type="Supported_Socket_Map" type="a{uau}">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>A mapping from address types (members of Socket_Address_Type) to
        arrays of access-control type (members of Socket_Access_Control)
        that the connection manager supports for sockets with that
        address type. For simplicity, if a CM supports offering a
        particular type of file transfer, it is assumed to support accepting
        it. Connection Managers MUST support at least Socket_Address_Type_IPv4.</p>

        <p>A typical value for a host without IPv6 support:</p>

        <pre>
          {
            Socket_Address_Type_IPv4:
              [Socket_Access_Control_Localhost, Socket_Access_Control_Port,
               Socket_Access_Control_Netmask],
            Socket_Address_Type_Unix:
              [Socket_Access_Control_Localhost, Socket_Access_Control_Credentials]
          }
        </pre>
      </tp:docstring>
    </property>

    <property access="read" name="TransferredBytes" tp:name-for-bindings="Transferred_Bytes" type="t">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The number of bytes that have been transferred at the time of
        requesting the property. This will be updated as the file transfer
        continues.</p>
      </tp:docstring>
    </property>

    <property access="read" name="InitialOffset" tp:name-for-bindings="Initial_Offset" type="t">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>The offset in bytes from where the file should be sent. This MUST
        be respected by both the receiver and the sender after the state
        becomes Open, but before any data is sent or received. Until the
        <tp:member-ref>InitialOffsetDefined</tp:member-ref> signal
        is emitted, this property is undefined.</p>

        <p>Before setting the <tp:member-ref>State</tp:member-ref> property to
        Open, the connection manager MUST set the InitialOffset property,
        possibly to 0.</p>

        <p>This property MUST NOT change after the state of the transfer has
        changed to Open.</p>
      </tp:docstring>
    </property>

    <tp:enum name="File_Transfer_State" type="u">
      <tp:enumvalue suffix="None" value="0">
        <tp:docstring>
          An invalid state type used as a null value. This value MUST NOT
          appear in the State property.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Pending" value="1">
        <tp:docstring>
          The file transfer is waiting to be accepted/closed by the receiver.
          The receiver has to call <tp:member-ref>AcceptFile</tp:member-ref>,
          then wait for the state to change to Open and check the offset value.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Accepted" value="2">
        <tp:docstring>
          The receiver has accepted the transfer. The sender now has to
          call <tp:member-ref>ProvideFile</tp:member-ref> to actually start the transfer.
          The receiver should now wait for the state to change to Open
          and check the offset value.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Open" value="3">
        <tp:docstring>
          The file transfer is open for traffic.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Completed" value="4">
        <tp:docstring>
          The file transfer has been completed successfully.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Cancelled" value="5">
        <tp:docstring>
          The file transfer has been cancelled.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="File_Transfer_State_Change_Reason" type="u">
      <tp:enumvalue suffix="None" value="0">
        <tp:docstring>
          No reason was specified.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Requested" value="1">
        <tp:docstring>
          The change in state was requested.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Local_Stopped" value="2">
        <tp:docstring>
          The file transfer was cancelled by the local user.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Remote_Stopped" value="3">
        <tp:docstring>
          The file transfer was cancelled by the remote user.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Local_Error" value="4">
        <tp:docstring>
          The file transfer was cancelled because of a local error.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Remote_Error" value="5">
        <tp:docstring>
          The file transfer was cancelled because of a remote error.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="File_Hash_Type" type="u">
      <tp:enumvalue suffix="None" value="0">
        <tp:docstring>
          No hash.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="MD5" value="1">
        <tp:docstring>
          MD5 digest as a string of 32 ASCII hex digits.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="SHA1" value="2">
        <tp:docstring>
          SHA1 digest as a string of ASCII hex digits.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="SHA256" value="3">
        <tp:docstring>
          SHA256 digest as a string of ASCII hex digits.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <method name="AcceptFile" tp:name-for-bindings="Accept_File">
      <tp:docstring>
        Accept a file transfer that's in the Pending state. The file
        transfer's state becomes Accepted after this method is called.
        At this point the client can connect to the socket. CM MUST emit
        <tp:member-ref>InitialOffsetDefined</tp:member-ref> and change
        the state to Open before writing to the socket.
        Then <tp:member-ref>InitialOffset</tp:member-ref> should be respected in case
        its value differs from the offset that was specified as an argument
        to AcceptFile.
      </tp:docstring>
      <arg direction="in" name="Address_Type" tp:type="Socket_Address_Type" type="u">
        <tp:docstring>
          The type of address the connection manager should listen on.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control" tp:type="Socket_Access_Control" type="u">
        <tp:docstring>
          The type of access control the connection manager should apply to
          the socket.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control_Param" type="v">
        <tp:docstring>
          A parameter for the access control type, to be interpreted as
          specified in the documentation for the Socket_Access_Control enum.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Offset" type="t">
        <tp:docstring>
          The desired offset in bytes where the file transfer should start.
          The offset is taken from the beginning of the file. Specifying an
          offset of zero will start the transfer from the beginning of the
          file. The offset that is actually given in the
          <tp:member-ref>InitialOffset</tp:member-ref> property can differ
          from this argument where the requested offset is not supported.
          (For example, some protocols do not support offsets at all so
          the InitialOffset property will always be 0.)
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="v">
        <tp:docstring>
          The address on which the connection manager will listen for
          connections for this file transfer.
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            The given address type or access-control mechanism is not supported.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
          <tp:docstring>
            Your address type, access control, access control parameter,
            offset, or a combination of all four is invalid.
          </tp:docstring>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The file transfer is not in the Pending state, there isn't
            or there is a local error with acquiring a socket.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="ProvideFile" tp:name-for-bindings="Provide_File">
      <tp:docstring>
        Provide the file for an outgoing file transfer which has been offered.
        Opens a socket that the client can use to provide a file to the connection manager.
        The channel MUST have been requested, and will change state
        to Open when this method is called if its state was Accepted.
      </tp:docstring>
      <arg direction="in" name="Address_Type" tp:type="Socket_Address_Type" type="u">
        <tp:docstring>
          The type of address the connection manager should listen on.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control" tp:type="Socket_Access_Control" type="u">
        <tp:docstring>
          The type of access control the connection manager should apply to
          the socket.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control_Param" type="v">
        <tp:docstring>
          A parameter for the access control type, to be interpreted as
          specified in the documentation for the Socket_Access_Control enum.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="v">
        <tp:docstring>
          The address on which the connection manager will listen for
          connections for this file transfer.
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            The given address type or access-control mechanism is not supported.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
          <tp:docstring>
            Your address type, access control, access control parameter, or
            a combination of all three is invalid.
          </tp:docstring>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            Channel is not an outgoing transfer, ProvideFile has already been called,
            or there was a local error acquiring the socket.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="FileTransferStateChanged" tp:name-for-bindings="File_Transfer_State_Changed">
      <tp:docstring>
        Emitted when the state of a file transfer changes.
      </tp:docstring>
      <arg name="State" tp:type="File_Transfer_State" type="u">
        <tp:docstring>
          The new state of the file transfer; see the File_Transfer_State enumeration.
        </tp:docstring>
      </arg>
      <arg name="Reason" tp:type="File_Transfer_State_Change_Reason" type="u">
        <tp:docstring>
          The reason for the state change; see the File_Transfer_State_Change_Reason
          enumeration.
          The value will always be File_Transfer_State_Change_Reason_None, except
          when changing state to cancelled.
        </tp:docstring>
      </arg>
    </signal>

    <signal name="TransferredBytesChanged" tp:name-for-bindings="Transferred_Bytes_Changed">
      <tp:docstring>
        Emitted when the number of transferred bytes changes. This will not be
        signalled with every single byte change. Instead, the most frequent
        this signal will be emitted is once a second. This should be
        sufficient, and the <tp:member-ref>TransferredBytes</tp:member-ref>
        property SHOULD NOT be polled.
      </tp:docstring>
      <arg name="Count" type="t">
        <tp:docstring>
          The number of already transferred bytes.
        </tp:docstring>
      </arg>
    </signal>

    <signal name="InitialOffsetDefined" tp:name-for-bindings="Initial_Offset_Defined">
      <tp:docstring>
        Emitted when the value of the <tp:member-ref>InitialOffset</tp:member-ref>
        property has been negotiated. This signal MUST be emitted before the channel
        becomes Open and clients have to use this offset when transferring the
        file.
      </tp:docstring>
      <arg name="InitialOffset" type="t">
        <tp:docstring>
          The value of the <tp:member-ref>InitialOffset</tp:member-ref> property.
        </tp:docstring>
      </arg>
    </signal>

  </interface>

</node>
<node name="/Channel_Type_Streamed_Media" xml:base="../spec/Channel_Type_Streamed_Media.xml">
  <tp:copyright> Copyright © 2005-2009 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright © 2005-2009 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright © 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.StreamedMedia">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Interface.Group"/>

    <tp:enum array-name="Media_Stream_Type_List" name="Media_Stream_Type" type="u">
      <tp:enumvalue suffix="Audio" value="0">
        <tp:docstring>An audio stream</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Video" value="1">
        <tp:docstring>A video stream</tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="Media_Stream_State" type="u">
      <tp:enumvalue suffix="Disconnected" value="0">
        <tp:docstring>The stream is disconnected.</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Connecting" value="1">
        <tp:docstring>The stream is trying to connect.</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Connected" value="2">
        <tp:docstring>The stream is connected.</tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="Media_Stream_Direction" type="u">
      <tp:enumvalue suffix="None" value="0">
        <tp:docstring>Media are not being sent or received</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Send" value="1">
        <tp:docstring>Media are being sent, but not received</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Receive" value="2">
        <tp:docstring>Media are being received, but not sent</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Bidirectional" value="3">
        <tp:docstring>Media are being sent and received</tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:flags name="Media_Stream_Pending_Send" type="u" value-prefix="Media_Stream_Pending">
      <tp:flag suffix="Local_Send" value="1">
        <tp:docstring>
            The local user has been asked to send media by the remote user.
            Call <tp:member-ref>RequestStreamDirection</tp:member-ref> to
            indicate whether or not this is acceptable.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Remote_Send" value="2">
        <tp:docstring>
            The remote user has been asked to send media by the local user.
            The <tp:member-ref>StreamDirectionChanged</tp:member-ref> signal
            will be emitted when the remote user accepts or rejects this
            change.
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <tp:struct array-name="Media_Stream_Info_List" name="Media_Stream_Info">
      <tp:member name="Identifier" tp:type="Stream_ID" type="u"/>
      <tp:member name="Contact" tp:type="Contact_Handle" type="u"/>
      <tp:member name="Type" tp:type="Media_Stream_Type" type="u"/>
      <tp:member name="State" tp:type="Media_Stream_State" type="u"/>
      <tp:member name="Direction" tp:type="Media_Stream_Direction" type="u"/>
      <tp:member name="Pending_Send_Flags" tp:type="Media_Stream_Pending_Send" type="u"/>
    </tp:struct>

    <tp:simple-type array-name="Stream_ID_List" name="Stream_ID" type="u">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>An unsigned integer identifying a stream within a channel.</p>
      </tp:docstring>
    </tp:simple-type>

    <method name="ListStreams" tp:name-for-bindings="List_Streams">
      <arg direction="out" name="Streams" tp:type="Media_Stream_Info[]" type="a(uuuuuu)">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          An array of structs containing:
          <ul>
          <li>the stream identifier</li>
          <li>the contact handle who the stream is with (or 0 if the stream
            represents more than a single member)</li>
          <li>the type of the stream</li>
          <li>the current stream state</li>
          <li>the current direction of the stream</li>
          <li>the current pending send flags</li>
          </ul>
        </tp:docstring>
      </arg>
      <tp:docstring>
        Returns an array of structs representing the streams currently active
        within this channel. Each stream is identified by an unsigned integer
        which is unique for each stream within the channel.
      </tp:docstring>
    </method>

    <method name="RemoveStreams" tp:name-for-bindings="Remove_Streams">
      <arg direction="in" name="Streams" tp:type="Stream_ID[]" type="au">
        <tp:docstring>
          An array of stream identifiers (as defined in
          <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>

      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request that the given streams are removed. If all streams are
          removed, the channel MAY close.</p>

        <p>Clients SHOULD NOT attempt to terminate calls by removing all the
          streams; instead, clients SHOULD terminate calls by removing the
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group.SelfHandle</tp:dbus-ref>
          from the channel, using either
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">RemoveMembers</tp:dbus-ref>
          or
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">RemoveMembersWithReason</tp:dbus-ref>.
          </p>
      </tp:docstring>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          A stream identifier is unknown
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="RequestStreamDirection" tp:name-for-bindings="Request_Stream_Direction">
      <arg direction="in" name="Stream_ID" type="u">
        <tp:docstring>
          The stream identifier (as defined in
          <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <arg direction="in" name="Stream_Direction" tp:type="Media_Stream_Direction" type="u">
        <tp:docstring>
          The desired stream direction (a value of MediaStreamDirection)
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request a change in the direction of an existing stream. In particular,
        this might be useful to stop sending media of a particular type,
        or inform the peer that you are no longer using media that is being
        sent to you.</p>

        <p>Depending on the protocol, streams which are no longer sending in
        either direction should be removed and a
        <tp:member-ref>StreamRemoved</tp:member-ref> signal emitted.
        Some direction changes can be enforced locally (for example,
        BIDIRECTIONAL -&gt; RECEIVE can be achieved by merely stopping sending),
        others may not be possible on some protocols, and some need agreement
        from the remote end. In this case, the MEDIA_STREAM_PENDING_REMOTE_SEND
        flag will be set in the
        <tp:member-ref>StreamDirectionChanged</tp:member-ref> signal, and the
        signal
        emitted again without the flag to indicate the resulting direction when
        the remote end has accepted or rejected the change.</p>
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          A stream identifier is unknown
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          The requested direction is not available on this stream
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="RequestStreams" tp:name-for-bindings="Request_Streams">
      <arg direction="in" name="Contact_Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          A contact handle with whom to establish the streams
        </tp:docstring>
      </arg>
      <arg direction="in" name="Types" tp:type="Media_Stream_Type[]" type="au">
        <tp:docstring>
          An array of stream types (values of MediaStreamType)
        </tp:docstring>
      </arg>
      <arg direction="out" name="Streams" tp:type="Media_Stream_Info[]" type="a(uuuuuu)">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          An array of structs (in the same order as the given stream types)
          containing:
          <ul>
            <li>the stream identifier</li>
            <li>the contact handle who the stream is with (or 0 if the stream
              represents more than a single member)</li>
            <li>the type of the stream</li>
            <li>the current stream state</li>
            <li>the current direction of the stream</li>
            <li>the current pending send flags</li>
          </ul>
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request that streams be established to exchange the given types of
        media with the given member. In general this will try and establish a
        bidirectional stream, but on some protocols it may not be possible to
        indicate to the peer that you would like to receive media, so a
        send-only stream will be created initially. In the cases where the
        stream requires remote agreement (eg you wish to receive media from
        them), the <tp:member-ref>StreamDirectionChanged</tp:member-ref> signal
        will be emitted with the
        MEDIA_STREAM_PENDING_REMOTE_SEND flag set, and the signal emitted again
        with the flag cleared when the remote end has replied.</p>

        <p>If streams of the requested types already exist, calling this
          method results in the creation of additional streams. Accordingly,
          clients wishing to have exactly one audio stream or exactly one
          video stream SHOULD check for the current streams using
          <tp:member-ref>ListStreams</tp:member-ref> before calling this
          method.</p>
      </tp:docstring>
      <tp:changed version="0.17.2">
        <p>It is valid to use a handle which is neither
          a current nor pending member in this channel's <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group</tp:dbus-ref>
          interface. If
          so, that handle will be added to the remote-pending set only when
          an attempt has actually been made to contact them. For further
          call-state notification, use the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">CallState</tp:dbus-ref>
          interface, if
          supported. This usage was not allowed in spec versions below
          0.17.2.</p>
      </tp:changed>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            A stream type given is invalid.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            A stream type given is not implemented by the connection manager.
            Since 0.17.23, connection managers SHOULD raise this error
            in preference to InvalidArgument.
            <tp:rationale>
              Connection managers can't know whether an unknown number
              is a valid stream type that was introduced in a later spec
              version.
            </tp:rationale>
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            That contact's client does not implement one of the given stream
            types. For this method, clients SHOULD consider this error and
            NotCapable to be equivalent.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotCapable">
          <tp:docstring>
            That contact's client does not implement one of the given stream
            types. Since 0.17.23, connection managers SHOULD raise
            this in preference to NotAvailable.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="StreamAdded" tp:name-for-bindings="Stream_Added">
      <arg name="Stream_ID" type="u">
        <tp:docstring>
          The stream identifier (as defined in
          <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <arg name="Contact_Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The contact handle who the stream is with (or 0 if it
          represents more than a single member)
        </tp:docstring>
      </arg>
      <arg name="Stream_Type" tp:type="Media_Stream_Type" type="u">
        <tp:docstring>
          The stream type (a value from MediaStreamType)
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when a new stream has been added to this channel.
          Clients SHOULD assume that the stream's
          <tp:type>Media_Stream_State</tp:type> is initially Disconnected.</p>

        <p>If a connection manager needs to represent the addition of a stream
          whose state is already Connecting or Connected, it MUST do this
          by emitting StreamAdded, closely followed by
          <tp:member-ref>StreamStateChanged</tp:member-ref> indicating a
          change to the appropriate state.</p>

        <tp:rationale>
          <p>Historically, it was not clear from the StreamAdded signal what
            the state of the stream was. telepathy-spec 0.17.22
            clarified this.</p>
        </tp:rationale>

        <p>Similarly, clients SHOULD assume that the initial
          <tp:type>Media_Stream_Direction</tp:type> of a newly added stream
          is Receive, and that the initial
          <tp:type>Media_Stream_Pending_Send</tp:type> is
          Pending_Local_Send.</p>

        <p>If a connection manager needs to represent the addition of a stream
          whose direction or pending-send differs from those initial values,
          it MUST do so by emitting StreamAdded, closely followed by
          <tp:member-ref>StreamDirectionChanged</tp:member-ref> indicating a
          change to the appropriate direction and pending-send state.</p>

        <tp:rationale>
          <p>StreamAdded doesn't itself indicate the stream's direction; this
            is unfortunate, but is preserved for compatibility.</p>

          <p>This is the appropriate direction for streams added by a remote
            contact on existing connection managers, and does not violate
            user privacy by automatically sending audio or video (audio streams
            start off muted, video streams start off not sending). For
            streams added by the local user using the client receiving the
            signal, the true direction can also be determined from the return
            value of the <tp:member-ref>RequestStreams</tp:member-ref>
            method.</p>

          <p>Existing clients typically operate by maintaining a separate
            idea of the directions that they would like the streams to have,
            and enforcing these intended directions by calling
            <tp:member-ref>RequestStreamDirection</tp:member-ref> whenever
            needed.</p>
        </tp:rationale>
      </tp:docstring>
    </signal>

    <signal name="StreamDirectionChanged" tp:name-for-bindings="Stream_Direction_Changed">
      <arg name="Stream_ID" type="u">
        <tp:docstring>
        The stream identifier (as defined in <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <arg name="Stream_Direction" tp:type="Media_Stream_Direction" type="u">
        <tp:docstring>
        The new stream direction (as defined in ListStreams)
        </tp:docstring>
      </arg>
      <arg name="Pending_Flags" tp:type="Media_Stream_Pending_Send" type="u">
        <tp:docstring>
        The new pending send flags (as defined in ListStreams)
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when the direction or pending flags of a stream are
          changed.</p>

        <p>If the MEDIA_STREAM_PENDING_LOCAL_SEND flag is set, the remote user
          has requested that we begin sending on this stream.
          <tp:member-ref>RequestStreamDirection</tp:member-ref>
          should be called to indicate whether or not this change is
          acceptable.</p>

        <tp:rationale>
          <p>This allows for a MSN-style user interface, &quot;Fred has asked you
            to enable your webcam. (Accept | Reject)&quot;, if desired.</p>
        </tp:rationale>
      </tp:docstring>
    </signal>

    <signal name="StreamError" tp:name-for-bindings="Stream_Error">
      <arg name="Stream_ID" type="u">
        <tp:docstring>
        The stream identifier (as defined in
        <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <arg name="Error_Code" tp:type="Media_Stream_Error" type="u">
        <tp:docstring>
          A stream error number, one of the values of MediaStreamError
        </tp:docstring>
      </arg>
      <arg name="Message" type="s">
        <tp:docstring>
          A string describing the error (for debugging purposes only)
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when a stream encounters an error.
      </tp:docstring>
    </signal>

    <signal name="StreamRemoved" tp:name-for-bindings="Stream_Removed">
      <arg name="Stream_ID" type="u">
        <tp:docstring>
        stream_id - the stream identifier (as defined in
        <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when a stream has been removed from this channel.
      </tp:docstring>
    </signal>

    <signal name="StreamStateChanged" tp:name-for-bindings="Stream_State_Changed">
      <arg name="Stream_ID" type="u">
        <tp:docstring>
          The stream identifier (as defined in
          <tp:member-ref>ListStreams</tp:member-ref>)
        </tp:docstring>
      </arg>
      <arg name="Stream_State" tp:type="Media_Stream_State" type="u">
        <tp:docstring>
          The new stream state (as defined in ListStreams)
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when a member's stream's state changes.
      </tp:docstring>
    </signal>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel that can send and receive streamed media such as audio or video.
    Provides a number of methods for listing and requesting new streams, and
    signals to indicate when streams have been added, removed and changed
    status.</p>

      <p>To make a media call to a contact, clients should call <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">CreateChannel</tp:dbus-ref>
        with <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">ChannelType</tp:dbus-ref>
        = <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>,
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandleType</tp:dbus-ref>
        = Contact, and one of <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandle</tp:dbus-ref>
        or <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetID</tp:dbus-ref>
        (which should yield a channel with the local user in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">Members</tp:dbus-ref>,
        and the remote contact as <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandle</tp:dbus-ref>
        but not in any group members list), then call
        <tp:member-ref>RequestStreams</tp:member-ref> to initiate the call (at
        which point the contact should appear in the channel's <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">RemotePendingMembers</tp:dbus-ref>).</p>

      <p>In the past, several other patterns have been used to place outgoing
        calls; see
        <a href="http://telepathy.freedesktop.org/wiki/Requesting%20StreamedMedia%20channels">'Requesting StreamedMedia Channels' on the Telepathy wiki</a>
        for the details.</p>

      <p>Incoming calls should be signalled as <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandleType</tp:dbus-ref>
        = Contact, <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandle</tp:dbus-ref>
        set to the remote contact, with the local user in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">LocalPendingMembers</tp:dbus-ref>;
        to accept the call, <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">AddMembers</tp:dbus-ref>
        can be used to move the local user to the group's members.</p>

      <p>When the local user accepts an incoming call, the connection manager
        SHOULD change the direction of any streams with pending local send
        to be sending, without altering whether those streams are
        receiving.</p>

      <tp:rationale>
        <p>This matches existing practice, and means that a client
          can answer incoming calls and get an unmuted microphone/activated
          webcam without having to take additional action to accept the
          stream directions.</p>

        <p>It does, however, introduce a race condition: a client believing
          that it is accepting an audio-only call by calling AddMembers
          can inadvertantly accept an audio + video call (and hence activate
          sending from a webcam without the user's permission) if a video
          stream is added just before AddMembers is processed. This race
          should be removed when this specification is revised.</p>
      </tp:rationale>

    <p>In general this should be used in conjunction with the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">MediaSignalling</tp:dbus-ref>
    interface to exchange connection candidates and codec choices with
    whichever component is responsible for the streams. However, in certain
    applications where no candidate exchange is necessary (eg the streams are
    handled by specialised hardware which is controlled directly by the
    connection manager), the signalling interface can be omitted and this
    channel type used simply to control the streams.</p>
    </tp:docstring>

    <tp:flags name="Channel_Media_Capabilities" type="u" value-prefix="Channel_Media_Capability">
      <tp:docstring>
        The channel-type-specific capability flags used for
        Channel.Type.StreamedMedia in the <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Capabilities</tp:dbus-ref>
        interface. See the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.StreamedMedia">FUTURE.InitialAudio</tp:dbus-ref>
        property for details of the mechanisms that will replace this.
      </tp:docstring>
      <tp:flag suffix="Audio" value="1">
        <tp:docstring>
          The handle is capable of using audio streams within a media channel.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Video" value="2">
        <tp:docstring>
          The handle is capable of using video streams within a media channel.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="NAT_Traversal_STUN" value="4">
        <tp:docstring>
          The handle is capable of performing STUN to traverse NATs.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="NAT_Traversal_GTalk_P2P" value="8">
        <tp:docstring>
          The handle is capable of establishing Google Talk peer-to-peer
          connections (as implemented in libjingle 0.3) to traverse NATs.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="NAT_Traversal_ICE_UDP" value="16">
        <tp:docstring>
          The handle is capable of establishing ICE UDP peer-to-peer
          connections (as defined by the IETF MMUSIC working group) to traverse
          NATs.
        </tp:docstring>
      </tp:flag>
    </tp:flags>

  </interface>
</node>
<node name="/Channel_Type_Room_List" xml:base="../spec/Channel_Type_Room_List.xml">
  <tp:copyright> Copyright © 2005-2009 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright © 2005-2009 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright © 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.RoomList">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>

    <tp:struct array-name="Room_Info_List" name="Room_Info">
      <tp:member name="Handle" tp:type="Room_Handle" type="u"/>
      <tp:member name="Channel_Type" tp:type="DBus_Interface" type="s"/>
      <tp:member name="Info" tp:type="String_Variant_Map" type="a{sv}"/>
    </tp:struct>

    <property access="read" name="Server" tp:name-for-bindings="Server" type="s">
      <tp:docstring>
        <p>For protocols with a concept of chatrooms on multiple servers
          with different DNS names (like XMPP), the DNS name of the server
          whose rooms are listed by this channel, e.g. &quot;conference.jabber.org&quot;.
          Otherwise, the empty string.</p>

        <p>This property cannot change during the lifetime of the channel.</p>
      </tp:docstring>
    </property>

    <method name="GetListingRooms" tp:name-for-bindings="Get_Listing_Rooms">
      <arg direction="out" name="In_Progress" type="b">
        <tp:docstring>
          A boolean indicating if room listing is in progress
        </tp:docstring>
      </arg>
      <tp:docstring>
        Check to see if there is already a room list request in progress
        on this channel.
      </tp:docstring>
    </method>

    <signal name="GotRooms" tp:name-for-bindings="Got_Rooms">
      <arg name="Rooms" tp:type="Room_Info[]" type="a(usa{sv})">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          An array of structs containing:
          <ul>
            <li>an integer room handle</li>
            <li>a string representing the D-Bus interface name of the channel type</li>
            <li>a dictionary mapping string keys to variant boxed information</li>
          </ul>
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when information about rooms on the server becomes available.
        The array contains the room handle (as can be passed to the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestChannel</tp:dbus-ref>
        method with HANDLE_TYPE_ROOM), the channel
        type, and a dictionary containing further information about the
        room as available. The following well-known keys and types are
        recommended for use where appropriate:</p>

        <dl>
          <dt>handle-name (s)</dt>
          <dd>The string name of the room handle (as would be returned by
            <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>)</dd>

          <dt>name (s)</dt>
          <dd>The human-readable name of the room if different from the handle</dd>

          <dt>description (s)</dt>
          <dd>A description of the room's overall purpose</dd>

          <dt>subject (s)</dt>
          <dd>The current subject of conversation in the room</dd>

          <dt>members (u)</dt>
          <dd>The number of members in the room</dd>

          <dt>password (b)</dt>
          <dd>True if the room requires a password to enter</dd>

          <dt>invite-only (b)</dt>
          <dd>True if you cannot join the room, but must be invited</dd>
        </dl>
      </tp:docstring>
    </signal>
    <method name="ListRooms" tp:name-for-bindings="List_Rooms">
      <tp:docstring>
        Request the list of rooms from the server. The
        <tp:member-ref>ListingRooms</tp:member-ref> (True) signal should be
        emitted when this request is being processed,
        <tp:member-ref>GotRooms</tp:member-ref> when any room information is
        received, and <tp:member-ref>ListingRooms</tp:member-ref> (False) when
        the request is complete.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
      </tp:possible-errors>
    </method>
    <method name="StopListing" tp:name-for-bindings="Stop_Listing">
      <tp:docstring>
        Stop the room listing if it's in progress, but don't close the channel.
        The <tp:member-ref>ListingRooms</tp:member-ref> (False) signal should
        be emitted when the listing stops.
      </tp:docstring>
    </method>
    <signal name="ListingRooms" tp:name-for-bindings="Listing_Rooms">
      <arg name="Listing" type="b">
        <tp:docstring>A boolean indicating if room listing is in progress</tp:docstring>
      </arg>
      <tp:docstring>
        Emitted to indicate whether or not room listing request is currently
        in progress.
      </tp:docstring>
    </signal>
    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel type for listing named channels available on the server. Once the
    <tp:member-ref>ListRooms</tp:member-ref> method is called, it emits signals for rooms present on the
    server, until you <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Close</tp:dbus-ref> this
    channel. In some cases, it may not be possible
    to stop the deluge of information from the server. This channel should be
    closed when the room information is no longer being displayed, so that the
    room handles can be freed.</p>

    <p>This channel type may be implemented as a singleton on some protocols, so
    clients should be prepared for the eventuality that they are given a
    channel that is already in the middle of listing channels. The
    <tp:member-ref>ListingRooms</tp:member-ref> signal, or
    <tp:member-ref>GetListingRooms</tp:member-ref> method, can be used to check
    this.</p>
    </tp:docstring>
  </interface>
</node>
<node name="/Channel_Type_Text" xml:base="../spec/Channel_Type_Text.xml">
  <tp:copyright> Copyright © 2005-2009 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright © 2005-2009 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright © 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.Text">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>

    <tp:simple-type array-name="Message_ID_List" name="Message_ID" type="u">
      <tp:docstring>
        A unique-per-channel identifier for an incoming message. These
        SHOULD be allocated in a way that minimizes collisions (in particular,
        message IDs SHOULD NOT be re-used until all of the 32-bit integer
        space has already been used).
      </tp:docstring>
    </tp:simple-type>

    <tp:struct array-name="Pending_Text_Message_List" name="Pending_Text_Message">
      <tp:docstring>A struct (message ID, timestamp in seconds since
        1970-01-01 00:00 UTC, sender's handle, message type, flags, text)
        representing a pending text message, as returned by
        <tp:member-ref>ListPendingMessages</tp:member-ref>.  The arguments of
        the <tp:member-ref>Received</tp:member-ref> signal also match this
        struct's signature.</tp:docstring>
      <tp:member name="Identifier" tp:type="Message_ID" type="u"/>
      <tp:member name="Unix_Timestamp" tp:type="Unix_Timestamp" type="u"/>
      <tp:member name="Sender" tp:type="Contact_Handle" type="u"/>
      <tp:member name="Message_Type" tp:type="Channel_Text_Message_Type" type="u"/>
      <tp:member name="Flags" tp:type="Channel_Text_Message_Flags" type="u"/>
      <tp:member name="Text" type="s"/>
    </tp:struct>

    <method name="AcknowledgePendingMessages" tp:name-for-bindings="Acknowledge_Pending_Messages">
      <arg direction="in" name="IDs" tp:type="Message_ID[]" type="au">
        <tp:docstring>
          The IDs of the messages to acknowledge
        </tp:docstring>
      </arg>
      <tp:docstring>
        Inform the channel that you have handled messages by displaying them to
        the user (or equivalent), so they can be removed from the pending queue.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            A given message ID was not found, so no action was taken
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="GetMessageTypes" tp:name-for-bindings="Get_Message_Types">
      <arg direction="out" name="Available_Types" tp:type="Channel_Text_Message_Type[]" type="au">
        <tp:docstring>
          An array of integer message types (ChannelTextMessageType)
        </tp:docstring>
      </arg>
      <tp:docstring>
        Return an array indicating which types of message may be sent on this
        channel.
      </tp:docstring>
    </method>

    <method name="ListPendingMessages" tp:name-for-bindings="List_Pending_Messages">
      <arg direction="in" name="Clear" type="b">
        <tp:docstring>
          If true, behave as if
          <tp:member-ref>AcknowledgePendingMessages</tp:member-ref> had also
          been called.
        </tp:docstring>
        <tp:deprecated version="0.17.3">
          Setting this to true is NOT RECOMMENDED for clients that
          have some sort of persistent message storage - clients SHOULD only
          acknowledge messages after they have actually stored them, which is
          impossible if this flag is true.</tp:deprecated>
      </arg>
      <arg direction="out" name="Pending_Messages" tp:type="Pending_Text_Message[]" type="a(uuuuus)">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          An array of structs representing the pending queue. Each contains:
          <ul>
            <li>a numeric identifier</li>
            <li>a Unix timestamp indicating when the message was received</li>
            <li>the contact handle for the contact who sent the message</li>
            <li>the message type, taken from ChannelTextMessageType</li>
            <li>the bitwise-OR of the message flags from ChannelTextMessageFlags</li>
            <li>the text of the message</li>
          </ul>
        </tp:docstring>
      </arg>
      <tp:docstring>
        List the messages currently in the pending queue, and optionally
        remove then all.
      </tp:docstring>
    </method>

    <signal name="LostMessage" tp:name-for-bindings="Lost_Message">
      <tp:docstring>
        This signal is emitted to indicate that an incoming message was
        not able to be stored and forwarded by the connection manager
        due to lack of memory.
      </tp:docstring>
    </signal>

    <signal name="Received" tp:name-for-bindings="Received">
      <arg name="ID" type="u">
        <tp:docstring>
          A numeric identifier for acknowledging the message
        </tp:docstring>
      </arg>
      <arg name="Timestamp" tp:type="Unix_Timestamp" type="u">
        <tp:docstring>
          A Unix timestamp indicating when the message was received
        </tp:docstring>
      </arg>
      <arg name="Sender" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The handle of the contact who sent the message
        </tp:docstring>
      </arg>
      <arg name="Type" tp:type="Channel_Text_Message_Type" type="u">
        <tp:docstring>
          The type of the message (normal, action, notice, etc.)
        </tp:docstring>
      </arg>
      <arg name="Flags" tp:type="Channel_Text_Message_Flags" type="u">
        <tp:docstring>
          A bitwise OR of the message flags
        </tp:docstring>
      </arg>
      <arg name="Text" type="s">
        <tp:docstring>
          The text of the message
        </tp:docstring>
      </arg>
      <tp:docstring>
        Signals that a message with the given id, timestamp, sender, type
        and text has been received on this channel. Applications that catch
        this signal and reliably inform the user of the message should
        acknowledge that they have dealt with the message with the
        <tp:member-ref>AcknowledgePendingMessages</tp:member-ref> method.
      </tp:docstring>
    </signal>

    <method name="Send" tp:name-for-bindings="Send">
      <arg direction="in" name="Type" tp:type="Channel_Text_Message_Type" type="u">
        <tp:docstring>
          An integer indicating the type of the message
        </tp:docstring>
      </arg>
      <arg direction="in" name="Text" type="s">
        <tp:docstring>
          The message to send
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request that a message be sent on this channel. When the message has
          been submitted for delivery, this method will return and the
          <tp:member-ref>Sent</tp:member-ref> signal will be emitted. If the
          message cannot be submitted for delivery, the method returns an error
          and no signal is emitted.</p>

        <p>This method SHOULD return before the Sent signal is
          emitted.</p>

        <tp:rationale>
          <p>When a Text channel implements the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Messages</tp:dbus-ref>
            interface, that &quot;SHOULD&quot; becomes a &quot;MUST&quot;.</p>
        </tp:rationale>
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
      </tp:possible-errors>
    </method>

    <tp:enum name="Channel_Text_Send_Error" type="u">
      <tp:enumvalue suffix="Unknown" value="0">
        <tp:docstring>
        An unknown error occurred
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Offline" value="1">
        <tp:docstring>
        The requested contact was offline
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Invalid_Contact" value="2">
        <tp:docstring>
        The requested contact is not valid
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Permission_Denied" value="3">
        <tp:docstring>
        The user does not have permission to speak on this channel
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Too_Long" value="4">
        <tp:docstring>
        The outgoing message was too long and was rejected by the server
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Not_Implemented" value="5">
        <tp:docstring>
        The channel doesn't support sending text messages to the requested
        contact
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <signal name="SendError" tp:name-for-bindings="Send_Error">
      <arg name="Error" tp:type="Channel_Text_Send_Error" type="u">
        <tp:docstring>
          The error that occurred
        </tp:docstring>
      </arg>
      <arg name="Timestamp" tp:type="Unix_Timestamp" type="u">
        <tp:docstring>
          The Unix timestamp indicating when the message was sent
        </tp:docstring>
      </arg>
      <arg name="Type" tp:type="Channel_Text_Message_Type" type="u">
        <tp:docstring>
          The message type
        </tp:docstring>
      </arg>
      <arg name="Text" type="s">
        <tp:docstring>
          The text of the message
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Signals that an outgoing message has failed to send. The error
          will be one of the values from ChannelTextSendError.</p>

        <p>This signal should only be emitted for messages for which
          <tp:member-ref>Sent</tp:member-ref> has already been emitted and
          <tp:member-ref>Send</tp:member-ref> has already returned success.</p>
      </tp:docstring>
      <tp:changed version="0.17.3">older spec versions claimed that SendError
        was emitted <em>instead of</em> Sent, rather than <em>in addition
        to</em> Sent. However, the 0.17.3+ semantics were what we'd always
        actually implemented.</tp:changed>
    </signal>

    <signal name="Sent" tp:name-for-bindings="Sent">
      <arg name="Timestamp" tp:type="Unix_Timestamp" type="u">
        <tp:docstring>
          Unix timestamp indicating when the message was sent
        </tp:docstring>
      </arg>
      <arg name="Type" tp:type="Channel_Text_Message_Type" type="u">
        <tp:docstring>
          The message type (normal, action, notice, etc) from
          ChannelTextMessageType
        </tp:docstring>
      </arg>
      <arg name="Text" type="s">
        <tp:docstring>
          The text of the message. If the message was, or will be, altered
          during transmission, this argument SHOULD reflect what other
          contacts will receive rather than being a copy of the argument
          to <tp:member-ref>Send</tp:member-ref>.
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Signals that a message has been submitted for sending.</p>
      </tp:docstring>
    </signal>

    <tp:enum array-name="Channel_Text_Message_Type_List" name="Channel_Text_Message_Type" type="u">
      <tp:docstring>
        The type of message.
      </tp:docstring>

      <tp:enumvalue suffix="Normal" value="0">
        <tp:docstring>
        An ordinary chat message. Unknown types SHOULD be treated like this.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Action" value="1">
        <tp:docstring>
        An action which might be presented to the user as
        &quot;* &lt;sender&gt; &lt;action&gt;&quot;, such as an IRC CTCP
        ACTION (typically selected by the &quot;/me&quot; command). For example, the
        text of the message might be &quot;drinks more coffee&quot;.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Notice" value="2">
        <tp:docstring>
        A one-off or automated message not necessarily expecting a reply
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Auto_Reply" value="3">
        <tp:docstring>
        An automatically-generated reply message.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Delivery_Report" value="4">
        <tp:docstring>
          This message type MUST NOT appear unless the channel supports the
          DeliveryReporting interface. The message MUST be as defined by
          the DeliveryReporting interface.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:flags name="Channel_Text_Message_Flags" type="u" value-prefix="Channel_Text_Message_Flag">
      <tp:flag suffix="Truncated" value="1">
        <tp:docstring>
        The incoming message was truncated to a shorter length by the
        server or the connection manager.
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Non_Text_Content" value="2">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The incoming message contained non-text content which cannot be
            represented by this interface, but has been signalled
            in the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Messages</tp:dbus-ref>
            interface.</p>

          <p>Connection managers SHOULD only set this flag if the non-text
            content appears to be relatively significant (exactly how
            significant is up to the implementor). The intention is that
            if this flag is set, clients using this interface SHOULD inform
            the user that part of the message was not understood.</p>
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Scrollback" value="4">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The incoming message was part of a replay of message history.</p>

          <tp:rationale>
            <p>In XMPP multi-user chat, a few past messages are replayed
              when you join a chatroom. A sufficiently capable IRC connection
              manager could also set this flag on historical messages when
              connected to a proxy like bip or irssi-proxy. The existence
              of this flag allows loggers and UIs to use better heuristics
              when eliminating duplicates (a simple implementation made
              possible by this flag would be to avoid logging scrollback
              at all).</p>
          </tp:rationale>
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Rescued" value="8">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The incoming message has been seen in a previous channel during
            the lifetime of the <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection</tp:dbus-ref>, but
            had not been acknowledged
            when that channel closed, causing an identical channel (the
            channel in which the message now appears) to open.</p>

          <tp:rationale>
            <p>This means that a logger (which should already have seen the
              message in the previous channel) is able to recognise and ignore
              these replayed messages.</p>
          </tp:rationale>
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <tp:property name="anonymous" type="b">
      <tp:docstring>
      True if people may join the channel without other members being made
      aware of their identity.
      </tp:docstring>
    </tp:property>
    <tp:property name="invite-only" type="b">
      <tp:docstring>
      True if people may not join the channel until they have been invited.
      </tp:docstring>
    </tp:property>
    <tp:property name="limit" type="u">
      <tp:docstring>
      The limit to the number of members, if limited is true.
      </tp:docstring>
    </tp:property>
    <tp:property name="limited" type="b">
      <tp:docstring>
      True if there is a limit to the number of channel members.
      </tp:docstring>
    </tp:property>
    <tp:property name="moderated" type="b">
      <tp:docstring>
      True if channel membership is not sufficient to allow participation.
      </tp:docstring>
    </tp:property>
    <tp:property name="name" type="s">
      <tp:docstring>
      A human-visible name for the channel, if it differs from the string
      version of the channel's handle.
      </tp:docstring>
    </tp:property>
    <tp:property name="description" type="s">
      <tp:docstring>
      A human-readable description of the channel's overall purpose.
      </tp:docstring>
    </tp:property>
    <tp:property name="password" type="s">
      <tp:docstring>
      The password required to enter the channel if password-required is true.
      </tp:docstring>
    </tp:property>
    <tp:property name="password-required" type="b">
      <tp:docstring>
      True if a password must be provided to enter the channel.
      </tp:docstring>
    </tp:property>
    <tp:property name="persistent" type="b">
      <tp:docstring>
      True if the channel will remain in existence on the server after all
      members have left it.
      </tp:docstring>
    </tp:property>
    <tp:property name="private" type="b">
      <tp:docstring>
      True if the channel is not visible to non-members.
      </tp:docstring>
    </tp:property>
    <tp:property name="subject" type="s">
      <tp:docstring>
      A human-readable description of the current subject of conversation in
      the channel, similar to /topic in IRC.
      </tp:docstring>
    </tp:property>
    <tp:property name="subject-contact" tp:type="Contact_Handle" type="u">
      <tp:docstring>
      A contact handle representing who last modified the subject, or 0
      if it isn't known.
      </tp:docstring>
    </tp:property>
    <tp:property name="subject-timestamp" tp:type="Unix_Timestamp" type="u">
      <tp:docstring>
      A unix timestamp indicating when the subject was last modified.
      </tp:docstring>
    </tp:property>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A channel type for sending and receiving messages in plain text,
        with no formatting. In future specifications, channels for sending
        and receiving messages that can be reduced to plain text (i.e.
        formatted text) should also have this type.</p>

      <p>When a message is received, an identifier is assigned and a
        <tp:member-ref>Received</tp:member-ref> signal emitted, and the message
        placed in a pending queue which can be inspected with
        <tp:member-ref>ListPendingMessages</tp:member-ref>. A client which has
        handled the message by showing it to the user (or equivalent) should
        acknowledge the receipt using the
        <tp:member-ref>AcknowledgePendingMessages</tp:member-ref> method,
        and the message will then be removed from the pending queue. Numeric
        identifiers for received messages may be reused over the lifetime of
        the channel.</p>

      <p>Each message has an associated 'type' value, which should be one
        of the values allowed by
        <tp:type>Channel_Text_Message_Type</tp:type>.</p>

      <p>Each message also has a flags value, which is a bitwise OR of the
        flags given in <tp:type>Channel_Text_Message_Flags</tp:type>.</p>

      <p>Sending messages can be requested using the
        <tp:member-ref>Send</tp:member-ref> method, which will return
        successfully and emit the <tp:member-ref>Sent</tp:member-ref> signal
        when the message has been delivered to the server, or return an error
        with no signal emission if there is a failure. If a message is sent but
        delivery of the message later fails, this is indicated with the
        <tp:member-ref>SendError</tp:member-ref> signal.</p>

      <p>On protocols where additional contacts cannot be invited into
        a one-to-one chat, or where a one-to-one chat is just a series of
        individual personal messages rather than being represented by some
        object on the server (i.e. most protocols), one-to-one chats should be
        represented by a Text channel with <tp:type>Handle_Type</tp:type>
        CONTACT.</p>

      <p>Named chat rooms whose identity can be saved and used again later
        (IRC channels, Jabber MUCs) are expected to be represented by Text
        channels with <tp:type>Handle_Type</tp:type> ROOM and the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group</tp:dbus-ref>
        interface; they should usually also have the Properties interface.</p>

      <p>Unnamed, transient chat rooms defined only by their members (e.g. on
        MSN) are expected to be represented by Text channels with handle type
        0, handle 0, the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group</tp:dbus-ref>
        interface, and optionally the Properties interface.</p>

      <p>On protocols where a conversation with a user is actually just
        a nameless chat room starting with exactly two members, to which
        more members can be invited, calling
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestChannel</tp:dbus-ref>
        with type Text
        and handle type CONTACT should continue to succeed, but may return
        a channel with handle type 0, handle 0, the group interface,
        and the local and remote contacts in its members.</p>

      <p>If a channel of type Text is closed while it has pending messages,
        the connection manager MUST allow this, but SHOULD open a new,
        identical channel to deliver those messages, signalling it as a new
        channel with the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">NewChannel</tp:dbus-ref>
        signal (with the suppress_handler parameter set to FALSE).</p>

      <p>If messages were sent on the old channel but the
        <tp:member-ref>Sent</tp:member-ref>signal has not yet been emitted
        for those messages, the new channel SHOULD emit Sent for those
        messages when appropriate - it behaves like a continuation of the
        old channel.</p>

      <tp:rationale>
        <p>In effect, this turns this situation, in which a client
          is likely to lose messages:</p>

        <ul>
          <li>UI window is closed</li>
          <li>message arrives</li>
          <li>text channel emits Received</li>
          <li>UI calls Close on text channel before it has seen the
            Received signal</li>
          <li>text channel emits Closed and closes</li>
        </ul>

        <p>into something nearly equivalent to this situation, which is
          fine:</p>

        <ul>
          <li>UI window is closed</li>
          <li>UI calls Close on text channel</li>
          <li>text channel emits Closed and closes</li>
          <li>message arrives</li>
          <li>new text channel is created, connection emits NewChannel</li>
          <li>(the same or a different) UI handles it</li>
        </ul>

        <p>suppress_handler must be set to FALSE so the replacement channel
          will be handled by something.</p>
      </tp:rationale>

      <p>As a result, Text channels SHOULD implement <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Destroyable</tp:dbus-ref>.</p>

      <tp:rationale>
        <p>This &quot;respawning&quot; behaviour becomes problematic if there is no
          suitable handler for Text channels, or if a particular message
          repeatedly crashes the Text channel handler; a channel dispatcher
          can't just Close() the channel in these situations, because
          it will come back.</p>

        <p>In these situations, the channel dispatcher needs a last-resort
          way to destroy the channel and stop it respawning. It could either
          acknowledge the messages itself, or use the Destroyable interface;
          the Destroyable interface has the advantage that it's not
          channel-type-dependent, so the channel dispatcher only has to
          understand one extra interface, however many channel types
          eventually need a distinction between Close and Destroy.</p>
      </tp:rationale>

    </tp:docstring>
  </interface>
</node>
<node name="/Channel_Type_Tubes" xml:base="../spec/Channel_Type_Tubes.xml">
  <tp:copyright>
    Copyright © 2007-2009 Collabora Limited
  </tp:copyright>
  <tp:license>
    This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Type.Tubes">

    <tp:deprecated version="0.17.25">Client implementations
      SHOULD use <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamTube</tp:dbus-ref> and
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">DBusTube</tp:dbus-ref>
      instead.</tp:deprecated>

    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>A &quot;tube&quot; is a mechanism for arbitrary data transfer. Two types of
        data transfer are currently specified: D-Bus messages, and streams of
        bytes. Each tube has a service name, which is a string specifying the
        kind of communication that takes place over it, and a dictionary of
        arbitrary parameters. Tube parameters are commonly used for bootstrap
        information such as usernames and passwords. Each tube is identified
        by a locally unique identifier.</p>

       <p>The Tubes channel type may be requested for handles of type
         HANDLE_TYPE_CONTACT and HANDLE_TYPE_ROOM.</p>

       <p>Stream tubes specify listening addresses using pairs of parameters
         with signature 'u', 'v', where the integer 'u' is a member of
         Socket_Address_Type and the v is dependent on the type of address.</p>
    </tp:docstring>

    <tp:simple-type name="Tube_ID" type="u">
      <tp:docstring>An identifier for a tube. These are local to a Tubes
        channel, and may not be assumed to be the same as the other
        participants' idea of the tube identifier.</tp:docstring>
    </tp:simple-type>

    <tp:struct array-name="Tube_Info_List" name="Tube_Info">
      <tp:docstring>A struct (tube ID, initiator handle, tube type,
        service name, parameters, state) representing a tube, as returned
        by ListTubes on the Tubes channel type.</tp:docstring>
      <tp:member name="Identifier" tp:type="Tube_ID" type="u"/>
      <tp:member name="Initiator" tp:type="Contact_Handle" type="u"/>
      <tp:member name="Type" tp:type="Tube_Type" type="u"/>
      <tp:member name="Service" type="s"/>
      <tp:member name="Parameters" tp:type="String_Variant_Map" type="a{sv}"/>
      <tp:member name="State" tp:type="Tube_State" type="u"/>
    </tp:struct>

    <tp:struct array-name="DBus_Tube_Member_List" name="DBus_Tube_Member">
      <tp:docstring>Represents a participant in a multi-user D-Bus tube, as
        returned by <tp:member-ref>GetDBusNames</tp:member-ref> and seen in the
        <tp:member-ref>DBusNamesChanged</tp:member-ref> signal.</tp:docstring>
      <tp:member name="Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The handle of a participant in this D-Bus tube.
        </tp:docstring>
      </tp:member>
      <tp:member name="Unique_Name" tp:type="DBus_Unique_Name" type="s">
        <tp:docstring>
          That participant's unique name.
        </tp:docstring>
      </tp:member>
    </tp:struct>

    <tp:enum array-name="Tube_Type_List" name="Tube_Type" type="u">
      <tp:enumvalue suffix="DBus" value="0">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The tube is D-Bus tube as described by the
            org.freedesktop.Telepathy.Channel.Type.DBusTube interface.</p>
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Stream" value="1">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The tube is stream tube as described by the
            org.freedesktop.Telepathy.Channel.Type.StreamTube interface.</p>
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="Tube_State" type="u">
      <tp:enumvalue suffix="Local_Pending" value="0">
        <tp:docstring>
          The tube is waiting to be accepted/closed locally.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Remote_Pending" value="1">
        <tp:docstring>
          The tube is waiting to be accepted/closed remotely.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Open" value="2">
        <tp:docstring>
          The tube is open for traffic.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:mapping name="Supported_Socket_Map">
      <tp:docstring>The supported socket address and access-control types
        for tubes. See GetAvailableStreamTubeTypes.</tp:docstring>
      <tp:member name="Address_Type" tp:type="Socket_Address_Type" type="u"/>
      <tp:member name="Access_Control" tp:type="Socket_Access_Control[]" type="au"/>
    </tp:mapping>

    <method name="GetAvailableStreamTubeTypes" tp:name-for-bindings="Get_Available_Stream_Tube_Types">
      <tp:docstring>List the available address types and access-control types
        for stream tubes.</tp:docstring>
      <arg direction="out" name="Available_Stream_Tube_Types" tp:type="Supported_Socket_Map" type="a{uau}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>A mapping from address types (members of Socket_Address_Type) to
          arrays of access-control type (members of Socket_Access_Control)
          that the connection manager supports for stream tubes with that
          address type. For simplicity, if a CM supports offering a
          particular type of tube, it is assumed to support accepting it.</p>

          <p>A typical value for a host without IPv6 support:</p>

          <pre>
            {
              Socket_Address_Type_IPv4:
                [Socket_Access_Control_Localhost, Socket_Access_Control_Port,
                 Socket_Access_Control_Netmask],
              Socket_Address_Type_Unix:
                [Socket_Access_Control_Localhost, Socket_Access_Control_Credentials]
            }
          </pre>

          <p>If stream tubes are not supported, this will be an empty
            dictionary.</p>
        </tp:docstring>
      </arg>
    </method>

    <method name="GetAvailableTubeTypes" tp:name-for-bindings="Get_Available_Tube_Types">
      <arg direction="out" name="Available_Tube_Types" tp:type="Tube_Type[]" type="au">
        <tp:docstring>
          An array of the available tube types, as defined by the Tube_Type
          enum.
        </tp:docstring>
      </arg>
    </method>

    <method name="ListTubes" tp:name-for-bindings="List_Tubes">
      <arg direction="out" name="Tubes" tp:type="Tube_Info[]" type="a(uuusa{sv}u)">
        <tp:docstring>
         Return an array of tuples, each representing a tube, with the
         following members:

         <ul>
           <li>the tube's ID</li>
           <li>the tube's initiator</li>
           <li>the tube's type</li>
           <li>the tube's service</li>
           <li>the tube's parameters</li>
           <li>the tube's state</li>
         </ul>
        </tp:docstring>
      </arg>
    </method>

    <!-- this tp:name-for-bindings is ugly, but compatible with
    the code generation in telepathy-glib versions that did not use
    tp:name-for-bindings -->
    <method name="OfferDBusTube" tp:name-for-bindings="Offer_D_Bus_Tube">
      <tp:docstring>
        Offers a D-Bus tube providing the service specified.
      </tp:docstring>
      <arg direction="in" name="Service" type="s">
        <tp:docstring>
          A string representing the service name that will be used over the
          tube.
          It should be a well-known D-Bus service name, of the form
          com.example.ServiceName.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Parameters" tp:type="String_Variant_Map" type="a{sv}">
        <tp:docstring>
          A dictionary of properties for the new tube; the allowable keys,
          types and values are defined by the service. Connection managers
          must support the value being any primitive (non-container)
          D-Bus type, or a byte array 'ay'.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Tube_ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the new tube.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The contact associated with this channel doesn't have tubes
            capabilities.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            The connection manager doesn't support D-Bus tubes.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="OfferStreamTube" tp:name-for-bindings="Offer_Stream_Tube">
      <tp:docstring>
        Offer a stream tube exporting the local socket specified.
      </tp:docstring>
      <arg direction="in" name="Service" type="s">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          A string representing the service name that will be used over the
          tube.
          It should be a well-known TCP service name as defined by
          <a href="http://www.iana.org/assignments/port-numbers">
            http://www.iana.org/assignments/port-numbers</a> or
          <a href="http://www.dns-sd.org/ServiceTypes.html">
            http://www.dns-sd.org/ServiceTypes.html</a>, for instance
          &quot;rsync&quot; or &quot;daap&quot;.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Parameters" tp:type="String_Variant_Map" type="a{sv}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>A dictionary of properties for the new tube; the allowable keys,
          types and values are defined by the service. Connection managers
          must support the value being any primitive (non-container)
          D-Bus type, or a byte array 'ay'.</p>
          <p>These should usually be the same key-value pairs specified for
          use in the DNS-SD TXT record for that service.</p>
        </tp:docstring>
      </arg>
      <arg direction="in" name="Address_Type" tp:type="Socket_Address_Type" type="u">
        <tp:docstring>
          The type of the listening address of the local service, as a member of
          Socket_Address_Type.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Address" type="v">
        <tp:docstring>
          The listening address of the local service, as indicated by the
          address_type.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control" tp:type="Socket_Access_Control" type="u">
        <tp:docstring>
          The access control the local service applies to the local socket,
          specified so the connection manager can behave appropriately
          when it connects.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control_Param" type="v">
        <tp:docstring>
          A parameter for the access control type, to be interpreted as
          specified in the documentation for the Socket_Access_Control enum.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Tube_ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the new tube.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The contact associated with this channel doesn't have tube
            capabilities.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            The connection manager doesn't support stream tubes, or
            does not support the given address type or access-control type.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="NewTube" tp:name-for-bindings="New_Tube">
      <tp:docstring>
        Emitted when a tube is created.
      </tp:docstring>
      <arg name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the new tube.
        </tp:docstring>
      </arg>
      <arg name="Initiator" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The handle of the contact who initiated the tube.
        </tp:docstring>
      </arg>
      <arg name="Type" tp:type="Tube_Type" type="u">
        <tp:docstring>
          The tube type, as defined by the Tube_Type enum.
        </tp:docstring>
      </arg>
      <arg name="Service" type="s">
        <tp:docstring>
          A string representing the service that will be used over the tube.
        </tp:docstring>
      </arg>
      <arg name="Parameters" tp:type="String_Variant_Map" type="a{sv}">
        <tp:docstring>
          The new tube's properties.
        </tp:docstring>
      </arg>
      <arg name="State" tp:type="Tube_State" type="u">
        <tp:docstring>
          The new tube's state.
        </tp:docstring>
      </arg>
    </signal>

    <!-- this tp:name-for-bindings is ugly, but compatible with
    the code generation in telepathy-glib versions that did not use
    tp:name-for-bindings -->
    <method name="AcceptDBusTube" tp:name-for-bindings="Accept_D_Bus_Tube">
      <tp:docstring>
        Accept a D-Bus tube that's in the &quot;local pending&quot; state. The
        connection manager will attempt to open the tube. The tube remains in
        the &quot;local pending&quot; state until the TubeStateChanged signal is
        emitted.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube to accept.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="s">
        <tp:docstring>
          The string describing the address of the private bus. The client
          should not attempt to connect to the address until the tube is open.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The given tube ID is invalid or does not refer to a D-Bus
            tube.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="AcceptStreamTube" tp:name-for-bindings="Accept_Stream_Tube">
      <tp:docstring>
        Accept a stream tube that's in the &quot;local pending&quot; state. The
        connection manager will attempt to open the tube. The tube remains in
        the &quot;local pending&quot; state until the TubeStateChanged signal is
        emitted.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube to accept.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Address_Type" tp:type="Socket_Address_Type" type="u">
        <tp:docstring>
          The type of address the connection manager should listen on.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control" tp:type="Socket_Access_Control" type="u">
        <tp:docstring>
          The type of access control the connection manager should apply to
          the socket.
        </tp:docstring>
      </arg>
      <arg direction="in" name="Access_Control_Param" type="v">
        <tp:docstring>
          A parameter for the access control type, to be interpreted as
          specified in the documentation for the Socket_Access_Control enum.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="v">
        <tp:docstring>
          The address on which the connection manager will listen for
          connections to this tube. The client should not attempt to connect
          to the address until the tube is open.
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The given tube ID is invalid or does not refer to a stream
            tube.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotImplemented">
          <tp:docstring>
            The given address type or access-control mechanism is not supported.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="TubeStateChanged" tp:name-for-bindings="Tube_State_Changed">
      <tp:docstring>
        Emitted when the state of a tube changes.
      </tp:docstring>
      <arg name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube that changed state.
        </tp:docstring>
      </arg>
      <arg name="State" tp:type="Tube_State" type="u">
        <tp:docstring>
          The new state of the tube; see the Tube_State enumeration.
        </tp:docstring>
      </arg>
    </signal>

    <method name="CloseTube" tp:name-for-bindings="Close_Tube">
      <tp:docstring>
        Close a tube.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube to close.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
      </tp:possible-errors>
    </method>

    <signal name="TubeClosed" tp:name-for-bindings="Tube_Closed">
      <tp:docstring>
       Emitted when a tube has been closed. The ID of a closed tube is no
       longer valid. The ID may later be reused for a new tube.
      </tp:docstring>
      <arg name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube that was closed.
        </tp:docstring>
      </arg>
    </signal>

    <!-- this tp:name-for-bindings is ugly, but compatible with
    the code generation in telepathy-glib versions that did not use
    tp:name-for-bindings -->
    <method name="GetDBusTubeAddress" tp:name-for-bindings="Get_D_Bus_Tube_Address">
      <tp:docstring>
        For a D-Bus tube, return a string describing the address of the
        private bus.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube to get an address for.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="s">
        <tp:docstring>
          The bus address.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The tube is not a D-Bus tube.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            This tube is not in the &quot;open&quot; state.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <!-- this tp:name-for-bindings is ugly, but compatible with
    the code generation in telepathy-glib versions that did not use
    tp:name-for-bindings -->
    <method name="GetDBusNames" tp:name-for-bindings="Get_D_Bus_Names">
      <tp:docstring>
        For a multi-user (i.e. Handle_Type_Room) D-Bus tube, obtain a mapping
        between contact handles and their unique bus names on this tube.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube to get names for.
        </tp:docstring>
      </arg>
      <arg direction="out" name="DBus_Names" tp:type="DBus_Tube_Member[]" type="a(us)">
        <tp:docstring>
          An array of structures, each containing a contact handle and a D-Bus
          bus name.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The tube is not a multi-user D-Bus tube.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            This tube is not in the &quot;open&quot; state.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <!-- this tp:name-for-bindings is ugly, but compatible with
    the code generation in telepathy-glib versions that did not use
    tp:name-for-bindings -->
    <signal name="DBusNamesChanged" tp:name-for-bindings="D_Bus_Names_Changed">
      <tp:docstring>
        Emitted on a multi-user (i.e. Handle_Type_Room) D-Bus tube when a
        participant opens or closes the tube.
      </tp:docstring>
      <arg name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube whose names have changed.
        </tp:docstring>
      </arg>
      <arg name="Added" tp:type="DBus_Tube_Member[]" type="a(us)">
        <tp:docstring>
          Array of handles and D-Bus names of new participants.
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          Array of handles of former participants.
        </tp:docstring>
      </arg>
    </signal>

    <method name="GetStreamTubeSocketAddress" tp:name-for-bindings="Get_Stream_Tube_Socket_Address">
      <tp:docstring>
        For a stream tube, obtain the address of the socket used to
        communicate over this tube.
      </tp:docstring>
      <arg direction="in" name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the stream tube to get the socket for.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address_Type" tp:type="Socket_Address_Type" type="u">
        <tp:docstring>
          The type of the listening address of the socket, as a member of
          Socket_Address_Type.
        </tp:docstring>
      </arg>
      <arg direction="out" name="Address" type="v">
        <tp:docstring>
          The listening address of the socket, as indicated by the
          address_type.
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The tube is not a stream tube.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            This tube is not in the &quot;open&quot; state.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <signal name="StreamTubeNewConnection" tp:name-for-bindings="Stream_Tube_New_Connection">
      <tp:docstring>
        Emitted on a stream tube when a participant opens a new connection
        to its socket.
      </tp:docstring>
      <arg name="ID" tp:type="Tube_ID" type="u">
        <tp:docstring>
          The ID of the tube
        </tp:docstring>
      </arg>
      <arg name="Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The handle of the participant who opened the new connection
        </tp:docstring>
      </arg>
    </signal>

  </interface>

</node>

<node name="/Channel_Interface_Call_State" xml:base="../spec/Channel_Interface_Call_State.xml">
  <tp:copyright> Copyright (C) 2008 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright (C) 2008 Nokia Corporation </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.CallState">
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"/>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>An interface for streamed media channels that can indicate call
        progress or call states. The presence of this interface is no guarantee
        that call states will actually be signalled (for instance, SIP
        implementations are not guaranteed to generate status 180 Ringing, so a
        call can be accepted without the Ringing flag ever having been set).</p>

      <p>To notify the other participant in the call that they are on hold,
        see <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Hold</tp:dbus-ref>.</p>
    </tp:docstring>
    <tp:added version="0.17.2"/>

    <method name="GetCallStates" tp:name-for-bindings="Get_Call_States">
      <tp:docstring>
        Get the current call states for all contacts involved in this call.
      </tp:docstring>

      <arg direction="out" name="States" tp:type="Channel_Call_State_Map" type="a{uu}">
        <tp:docstring>
          The current call states. Participants where the call state flags
          would be 0 (all unset) may be omitted from this mapping.
        </tp:docstring>
      </arg>
    </method>

    <signal name="CallStateChanged" tp:name-for-bindings="Call_State_Changed">
      <tp:docstring>
        Emitted when the state of a member of the channel has changed.
      </tp:docstring>

      <arg name="Contact" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          An integer handle for the contact.
        </tp:docstring>
      </arg>

      <arg name="State" tp:type="Channel_Call_State_Flags" type="u">
        <tp:docstring>
          The new state for this contact.
        </tp:docstring>
      </arg>
    </signal>

    <tp:mapping name="Channel_Call_State_Map">
      <tp:docstring>
        A map from contacts to call states.
      </tp:docstring>

      <tp:member name="Contact" tp:type="Contact_Handle" type="u">
        <tp:docstring>A contact involved in this call.</tp:docstring>
      </tp:member>

      <tp:member name="State" tp:type="Channel_Call_State_Flags" type="u">
        <tp:docstring>State flags for the given contact.</tp:docstring>
      </tp:member>
    </tp:mapping>

    <tp:flags name="Channel_Call_State_Flags" type="u" value-prefix="Channel_Call_State">
      <tp:docstring>
        A set of flags representing call states.
      </tp:docstring>

      <tp:flag suffix="Ringing" value="1">
        <tp:docstring>
          The contact has been alerted about the call but has not responded
          (e.g. 180 Ringing in SIP).
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Queued" value="2">
        <tp:docstring>
          The contact is temporarily unavailable, and the call has been placed
          in a queue (e.g. 182 Queued in SIP, or call-waiting in telephony).
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Held" value="4">
        <tp:docstring>
          The contact has placed the call on hold, and will not receive
          media from the local user or any other participants until they
          unhold the call again.
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Forwarded" value="8">
        <tp:docstring>
          The initiator of the call originally called a contact other than the
          current recipient of the call, but the call was then forwarded or
          diverted.
        </tp:docstring>
      </tp:flag>
    </tp:flags>

  </interface>
</node>
<node name="/Channel_Interface_Chat_State" xml:base="../spec/Channel_Interface_Chat_State.xml">
  <tp:copyright> Copyright (C) 2007 Collabora Limited </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.ChatState">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <method name="SetChatState" tp:name-for-bindings="Set_Chat_State">
      <arg direction="in" name="State" tp:type="Channel_Chat_State" type="u">
        <tp:docstring>
          The new state.
        </tp:docstring>
      </arg>
      <tp:docstring>
        Set the local state and notify other members of the channel that it
        has changed.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
      </tp:possible-errors>
    </method>
    <signal name="ChatStateChanged" tp:name-for-bindings="Chat_State_Changed">
      <arg name="Contact" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          An integer handle for the contact.
        </tp:docstring>
      </arg>
      <arg name="State" tp:type="Channel_Chat_State" type="u">
        <tp:docstring>
          The new state of this contact.
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when the state of a member of the channel has changed.
        This includes local state.
      </tp:docstring>
    </signal>
    <tp:enum name="Channel_Chat_State" type="u">
      <tp:enumvalue suffix="Gone" value="0">
        <tp:docstring>
        The contact has effectively ceased participating in the chat.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Inactive" value="1">
        <tp:docstring>
        The contact has not been active for some time.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Active" value="2">
        <tp:docstring>
        The contact is actively participating in the chat.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Paused" value="3">
        <tp:docstring>
        The contact has paused composing a message.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Composing" value="4">
        <tp:docstring>
        The contact is composing a message to be sent to the chat.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>
    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>An interface for channels for receiving notifications of remote contacts'
      state, and for notifying remote contacts of the local state.</p>

      <p>Clients should assume that a contact's state is Channel_Chat_State_Inactive
      unless they receive a notification otherwise.</p>

      <p>The Channel_Chat_State_Gone state is treated differently to other states:</p>
      <ul>
        <li>It may not be used for multi-user chats</li>
        <li>It may not be explicitly sent</li>
        <li>It should be automatically sent when the channel is closed</li>
        <li>It must not be sent to the peer if a channel is closed without being used</li>
        <li>Receiving it must not cause a new channel to be opened</li>
      </ul>

      <p>The different states are defined by XEP-0085, but may be applied to any suitable protocol.</p>
    </tp:docstring>
  </interface>
</node>
<node name="/Channel_Interface_DTMF" xml:base="../spec/Channel_Interface_DTMF.xml">
  <tp:copyright>Copyright (C) 2005, 2006 Collabora Limited</tp:copyright>
  <tp:copyright>Copyright (C) 2005, 2006 Nokia Corporation</tp:copyright>
  <tp:copyright>Copyright (C) 2006 INdT</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.DTMF">
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"/>

    <method name="StartTone" tp:name-for-bindings="Start_Tone">
      <arg direction="in" name="Stream_ID" tp:type="Stream_ID" type="u">
        <tp:docstring>A stream ID as defined in the StreamedMedia channel type.</tp:docstring>
      </arg>
      <arg direction="in" name="Event" tp:type="DTMF_Event" type="y">
        <tp:docstring>A numeric event code from the DTMF_Event enum.</tp:docstring>
      </arg>
      <tp:docstring>
        Start sending a DTMF tone on this stream. Where possible, the tone
        will continue until <tp:member-ref>StopTone</tp:member-ref> is called.
        On certain protocols, it may
        only be possible to send events with a predetermined length. In this
        case, the implementation may emit a fixed-length tone, and the StopTone
        method call should return NotAvailable.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The given stream ID was invalid.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The requested event is not available on this stream.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="StopTone" tp:name-for-bindings="Stop_Tone">
      <arg direction="in" name="Stream_ID" tp:type="Stream_ID" type="u">
        <tp:docstring>A stream ID as defined in the StreamedMedia channel type.</tp:docstring>
      </arg>
      <tp:docstring>
        Stop sending any DTMF tone which has been started using the
        <tp:member-ref>StartTone</tp:member-ref>
        method. If there is no current tone, this method will do nothing.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The given stream ID was invalid.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            Continuous tones are not supported by this stream.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <tp:enum name="DTMF_Event" type="y">
      <tp:enumvalue suffix="Digit_0" value="0">
        <tp:docstring>0</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_1" value="1">
        <tp:docstring>1</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_2" value="2">
        <tp:docstring>2</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_3" value="3">
        <tp:docstring>3</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_4" value="4">
        <tp:docstring>4</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_5" value="5">
        <tp:docstring>5</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_6" value="6">
        <tp:docstring>6</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_7" value="7">
        <tp:docstring>7</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_8" value="8">
        <tp:docstring>8</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Digit_9" value="9">
        <tp:docstring>9</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Asterisk" value="10">
        <tp:docstring>*</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Hash" value="11">
        <tp:docstring>#</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Letter_A" value="12">
        <tp:docstring>A</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Letter_B" value="13">
        <tp:docstring>B</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Letter_C" value="14">
        <tp:docstring>C</tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Letter_D" value="15">
        <tp:docstring>D</tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      An interface that gives a Channel the ability to send DTMF events over
      audio streams which have been established using the StreamedMedia channel
      type. The event codes used are in common with those defined in <a href="http://www.rfc-editor.org/rfc/rfc4733.txt">RFC4733</a>, and are
      listed in the <tp:type>DTMF_Event</tp:type> enumeration.
    </tp:docstring>

  </interface>
</node>
<node name="/Channel_Interface_Group" xml:base="../spec/Channel_Interface_Group.xml">
  <tp:copyright>Copyright © 2005-2009 Collabora Limited</tp:copyright>
  <tp:copyright>Copyright © 2005-2009 Nokia Corporation</tp:copyright>
  <tp:copyright>Copyright © 2006 INdT</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.Group">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>

    <tp:struct array-name="Local_Pending_Info_List" name="Local_Pending_Info">
      <tp:docstring>A structure representing a contact whose attempt to
        join a group is to be confirmed by the local user using
        <tp:member-ref>AddMembers</tp:member-ref>.</tp:docstring>
      <tp:member name="To_Be_Added" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The contact to be added to the group
        </tp:docstring>
      </tp:member>
      <tp:member name="Actor" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The contact requesting or causing the change
        </tp:docstring>
      </tp:member>
      <tp:member name="Reason" tp:type="Channel_Group_Change_Reason" type="u">
        <tp:docstring>
          The reason for the change
        </tp:docstring>
      </tp:member>
      <tp:member name="Message" type="s">
        <tp:docstring>
          A human-readable message from the Actor, or an empty string
          if there is no message
        </tp:docstring>
      </tp:member>
    </tp:struct>

    <method name="AddMembers" tp:name-for-bindings="Add_Members">
      <arg direction="in" name="Contacts" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          An array of contact handles to invite to the channel
        </tp:docstring>
      </arg>
      <arg direction="in" name="Message" type="s">
        <tp:docstring>
          A string message, which can be blank if desired
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Invite all the given contacts into the channel, or accept requests for
          channel membership for contacts on the pending local list.</p>

        <p>A message may be provided along with the request, which will be sent
        to the server if supported. See the CHANNEL_GROUP_FLAG_MESSAGE_ADD and
        CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT
        <tp:member-ref>GroupFlags</tp:member-ref> to see in which cases this
        message should be provided.</p>

        <p>Attempting to add contacts who are already members is allowed;
          connection managers must silently accept this, without error.</p>
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotCapable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle"/>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.Full"/>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.InviteOnly"/>
        <tp:error name="org.freedesktop.Telepathy.Error.Channel.Banned"/>
      </tp:possible-errors>
    </method>

    <method name="GetAllMembers" tp:name-for-bindings="Get_All_Members">
      <tp:deprecated version="0.17.6">Use GetAll on the D-Bus
        Properties D-Bus interface to get properties including Members,
        RemotePendingMembers and LocalPendingMembers instead, falling back to
        this method and GetLocalPendingMembersWithInfo if necessary.
      </tp:deprecated>

      <arg direction="out" name="Members" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          array of handles of current members
        </tp:docstring>
      </arg>
      <arg direction="out" name="Local_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          array of handles of local pending members
        </tp:docstring>
      </arg>
      <arg direction="out" name="Remote_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          array of handles of remote pending members
        </tp:docstring>
      </arg>
      <tp:docstring>
        Returns arrays of all current, local and remote pending channel
        members.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <tp:flags name="Channel_Group_Flags" type="u" value-prefix="Channel_Group_Flag">
      <tp:flag suffix="Can_Add" value="1">
        <tp:docstring>
            The <tp:member-ref>AddMembers</tp:member-ref> method can be used to
            add or invite members who are
            not already in the local pending list (which is always valid).
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Can_Remove" value="2">
        <tp:docstring>
            The <tp:member-ref>RemoveMembers</tp:member-ref> method can be used
            to remove channel members
            (removing those on the pending local list is always valid).
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Can_Rescind" value="4">
        <tp:docstring>
            The <tp:member-ref>RemoveMembers</tp:member-ref> method can be used
            on people on the remote
            pending list.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Add" value="8">
        <tp:docstring>
            A message may be sent to the server when calling
            <tp:member-ref>AddMembers</tp:member-ref> on
            contacts who are not currently pending members.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Remove" value="16">
        <tp:docstring>
            A message may be sent to the server when calling
            <tp:member-ref>RemoveMembers</tp:member-ref> on
            contacts who are currently channel members.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Accept" value="32">
        <tp:docstring>
            A message may be sent to the server when calling
            <tp:member-ref>AddMembers</tp:member-ref> on
            contacts who are locally pending.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Reject" value="64">
        <tp:docstring>
            A message may be sent to the server when calling
            <tp:member-ref>RemoveMembers</tp:member-ref> on
            contacts who are locally pending.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Rescind" value="128">
        <tp:docstring>
            A message may be sent to the server when calling
            <tp:member-ref>RemoveMembers</tp:member-ref> on
            contacts who are remote pending.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Channel_Specific_Handles" value="256">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>
            The members of this group have handles which are specific to
            this channel, and are not valid as general-purpose handles on
            the connection. Depending on the channel, it may be possible to
            check the <tp:member-ref>HandleOwners</tp:member-ref> property or
            call <tp:member-ref>GetHandleOwners</tp:member-ref> to find the
            owners of these handles, which should be done if you wish to (e.g.)
            subscribe to the contact's presence.
          </p>

          <p>
            Connection managers must ensure that any given handle is not
            simultaneously a general-purpose handle and a channel-specific
            handle.
          </p>
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Only_One_Group" value="512">
        <tp:docstring>
            Placing a contact in multiple groups of this type is not allowed
            and will raise NotAvailable (on services where contacts may only
            be in one user-defined group, user-defined groups will have
            this flag).
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Handle_Owners_Not_Available" value="1024">
        <tp:docstring>
          In rooms with channel specific handles (ie Channel_Specific_Handles
          flag is set), this flag indicates that no handle owners are
          available, apart from the owner of the
          <tp:member-ref>SelfHandle</tp:member-ref>.

          <tp:rationale>
            This used to be an important optimization to avoid repeated
            GetHandleOwners calls, before we introduced the
            <tp:member-ref>HandleOwners</tp:member-ref> property and
            <tp:member-ref>HandleOwnersChanged</tp:member-ref> signal.
          </tp:rationale>
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Properties" value="2048">
        <tp:docstring>
          This flag indicates that all the properties introduced in
          specification 0.17.6 are fully supported.
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Members_Changed_Detailed" value="4096">
        <tp:docstring>
          Indicates that <tp:member-ref>MembersChangedDetailed</tp:member-ref>
          will be emitted for changes to this group's members in addition to
          <tp:member-ref>MembersChanged</tp:member-ref>.
          Clients can then connect to the former and ignore emission of the
          latter. This flag's state MUST NOT change over the lifetime of a
          channel.

          <tp:rationale>
            If it were allowed to change, client bindings would have to always
            connect to MembersChanged just in case the flag ever went away (and
            generally be unnecessarily complicated), which would mostly negate
            the point of having this flag in the first place.
          </tp:rationale>
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Message_Depart" value="8192">
        <tp:added version="0.17.21"/>
        <tp:docstring>
          A message may be sent to the server when calling
          <tp:member-ref>RemoveMembers</tp:member-ref> on
          the <tp:member-ref>SelfHandle</tp:member-ref>.

          <tp:rationale>
            This would be set for XMPP Multi-User Chat or IRC channels,
            but not for a typical implementation of streamed media calls.
          </tp:rationale>
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <property access="read" name="GroupFlags" tp:name-for-bindings="Group_Flags" tp:type="Channel_Group_Flags" type="u">
      <tp:docstring>
        An integer representing the bitwise-OR of flags on this
        channel. The user interface can use this to present information about
        which operations are currently valid. Change notification is via
        the <tp:member-ref>GroupFlagsChanged</tp:member-ref> signal.
      </tp:docstring>
      <tp:added version="0.17.6">For backwards compatibility,
        clients should fall back to calling GetGroupFlags if
        Channel_Group_Flag_Properties is not present.</tp:added>
    </property>

    <method name="GetGroupFlags" tp:name-for-bindings="Get_Group_Flags">
      <arg direction="out" name="Group_Flags" tp:type="Channel_Group_Flags" type="u">
        <tp:docstring>
          The value of the GroupFlags property
        </tp:docstring>
      </arg>
      <tp:docstring>
        Returns the value of the <tp:member-ref>GroupFlags</tp:member-ref> property.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Use GetAll on the D-Bus
        Properties D-Bus interface to get properties including GroupFlags
        instead, falling back to this method if necessary.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <tp:mapping name="Handle_Owner_Map">
      <tp:docstring>
        A map from channel-specific handles to their owners.
      </tp:docstring>
      <tp:added version="0.17.6">For backwards compatibility,
        clients should fall back to calling GetHandleOwners if
        Channel_Group_Flag_Properties is not present.</tp:added>

      <tp:member name="Channel_Specific_Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          A nonzero channel-specific handle
        </tp:docstring>
      </tp:member>
      <tp:member name="Global_Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The global handle that owns the corresponding channel-specific
          handle, or 0 if this could not be determined
        </tp:docstring>
      </tp:member>
    </tp:mapping>

    <property access="read" name="HandleOwners" tp:name-for-bindings="Handle_Owners" tp:type="Handle_Owner_Map" type="a{uu}">
      <tp:docstring>
        A map from channel-specific handles to their owners, including
        at least all of the channel-specific handles in this channel's members,
        local-pending or remote-pending sets as keys. Any handle not in
        the keys of this mapping is not channel-specific in this channel.
        Handles which are channel-specific, but for which the owner is
        unknown, MUST appear in this mapping with 0 as owner. Change
        notification is via the
        <tp:member-ref>HandleOwnersChanged</tp:member-ref> signal.
      </tp:docstring>
      <tp:added version="0.17.6"/>
    </property>

    <signal name="HandleOwnersChanged" tp:name-for-bindings="Handle_Owners_Changed">
      <tp:docstring>
        Emitted whenever the <tp:member-ref>HandleOwners</tp:member-ref>
        property changes.
      </tp:docstring>
      <tp:added version="0.17.6">This signal should not be relied on
        unless Channel_Group_Flag_Properties is present.</tp:added>

      <arg name="Added" tp:type="Handle_Owner_Map" type="a{uu}">
        <tp:docstring>
          A map from channel-specific handles to their owners, in which the
          keys include all the handles that were added to the keys of the
          HandleOwners property, and all the handles in that property whose
          owner has changed
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          The channel-specific handles that were removed from the keys of the
          HandleOwners property, as a result of the contact leaving this group
          in a previous <tp:member-ref>MembersChanged</tp:member-ref> signal
        </tp:docstring>
      </arg>
    </signal>

    <method name="GetHandleOwners" tp:name-for-bindings="Get_Handle_Owners">
      <arg direction="in" name="Handles" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of integer handles representing members of the channel
        </tp:docstring>
      </arg>
      <arg direction="out" name="Owners" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          An array of integer handles representing the owner handles of
          the given room members, in the same order, or 0 if the
          owner is not available
        </tp:docstring>
      </arg>
      <tp:docstring>
        If the CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES flag is set on
        the channel, then the handles of the group members are specific
        to this channel, and are not meaningful in a connection-wide
        context such as contact lists. This method allows you to find
        the owner of the handle if it can be discovered in this channel,
        or 0 if the owner is not available.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Clients should use the
        HandleOwners property and HandleOwnersChanged signal if
        Channel_Group_Flag_Properties is present.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            This channel doesn't have the CHANNEL_SPECIFIC_HANDLES flag,
            so handles in this channel are globally meaningful and calling
            this method is not necessary
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            One of the given handles is not a member
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <method name="GetLocalPendingMembers" tp:name-for-bindings="Get_Local_Pending_Members">
      <arg direction="out" name="Handles" tp:type="Contact_Handle[]" type="au"/>
      <tp:docstring>
        Returns the To_Be_Added handle (only) for each structure in the
        <tp:member-ref>LocalPendingMembers</tp:member-ref> property.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Use the LocalPendingMembers
        property, if Channel_Group_Flag_Properties is present.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <method name="GetLocalPendingMembersWithInfo" tp:name-for-bindings="Get_Local_Pending_Members_With_Info">
      <tp:added version="0.15.0"/>
      <tp:docstring>
        Returns the <tp:member-ref>LocalPendingMembers</tp:member-ref> property.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Use the LocalPendingMembers
        property, if Channel_Group_Flag_Properties is present.</tp:deprecated>
      <arg direction="out" name="Info" tp:type="Local_Pending_Info[]" type="a(uuus)">
        <tp:docstring>
          An array of structs containing:
          <ul>
            <li>
              A handle representing the contact requesting channel membership
            </li>
            <li>
              A handle representing the contact making the request, or 0 if
              unknown
            </li>
            <li>
              The reason for the request: one of the values of
              <tp:type>Channel_Group_Change_Reason</tp:type>
            </li>
            <li>
              A string message containing the reason for the request if any (or
              blank if none)
            </li>
          </ul>
        </tp:docstring>
      </arg>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <property access="read" name="LocalPendingMembers" tp:name-for-bindings="Local_Pending_Members" tp:type="Local_Pending_Info[]" type="a(uuus)">
      <tp:docstring>
        An array of structs containing handles representing contacts
        requesting channel membership and awaiting local approval with
        <tp:member-ref>AddMembers</tp:member-ref>.
      </tp:docstring>
      <tp:added version="0.17.6">If Channel_Group_Flag_Properties is
        not present, clients should fall back to using the
        deprecated GetLocalPendingMembersWithInfo method, or fall back
        from that to the deprecated GetAllMembers method.</tp:added>
    </property>

    <property access="read" name="Members" tp:name-for-bindings="Members" tp:type="Contact_Handle[]" type="au">
      <tp:docstring>
        The members of this channel.
      </tp:docstring>
      <tp:added version="0.17.6">If Channel_Group_Flag_Properties
        is not set, fall back to calling GetAllMembers.</tp:added>
    </property>

    <method name="GetMembers" tp:name-for-bindings="Get_Members">
      <arg direction="out" name="Handles" tp:type="Contact_Handle[]" type="au"/>
      <tp:docstring>
        Returns the <tp:member-ref>Members</tp:member-ref> property.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Use the Members
        property, if Channel_Group_Flag_Properties is present.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <property access="read" name="RemotePendingMembers" tp:name-for-bindings="Remote_Pending_Members" tp:type="Contact_Handle[]" type="au">
      <tp:docstring>
        An array of handles representing contacts who have been
        invited to the channel and are awaiting remote approval.
      </tp:docstring>
      <tp:added version="0.17.6">If Channel_Group_Flag_Properties
        is not set, fall back to calling GetAllMembers.</tp:added>
    </property>

    <method name="GetRemotePendingMembers" tp:name-for-bindings="Get_Remote_Pending_Members">
      <arg direction="out" name="Handles" tp:type="Contact_Handle[]" type="au"/>
      <tp:docstring>
        Returns an array of handles representing contacts who have been
        invited to the channel and are awaiting remote approval.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Use the
        <tp:member-ref>RemotePendingMembers</tp:member-ref>
        property, if Channel_Group_Flag_Properties is present.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <signal name="SelfHandleChanged" tp:name-for-bindings="Self_Handle_Changed">
      <tp:docstring>
        Emitted whenever the <tp:member-ref>SelfHandle</tp:member-ref> property
        changes.
      </tp:docstring>
      <tp:added version="0.17.6">This signal should not be relied on
        unless Channel_Group_Flag_Properties is present.</tp:added>

      <arg name="Self_Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The new value of the SelfHandle property.
        </tp:docstring>
      </arg>
    </signal>

    <property access="read" name="SelfHandle" tp:name-for-bindings="Self_Handle" tp:type="Contact_Handle" type="u">
      <tp:docstring>
        The handle for the user on this channel (which can also be a
        local or remote pending member), or 0 if the user is not a member at
        all (which is likely to be the case, for instance, on <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">ContactList</tp:dbus-ref>
        channels). Note that this is different from the result of
        <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.GetSelfHandle</tp:dbus-ref>
        on some protocols, so the value of this handle should
        always be used with the methods of this interface.
      </tp:docstring>
      <tp:added version="0.17.6">For backwards compatibility,
        clients should fall back to calling GetSelfHandle if
        Channel_Group_Flag_Properties is not present.</tp:added>
    </property>

    <method name="GetSelfHandle" tp:name-for-bindings="Get_Self_Handle">
      <arg direction="out" name="Self_Handle" tp:type="Contact_Handle" type="u"/>
      <tp:docstring>
        Returns the value of the <tp:member-ref>SelfHandle</tp:member-ref>
        property.
      </tp:docstring>
      <tp:deprecated version="0.17.6">Clients should retrieve the
        SelfHandle property using GetAll instead,
        if Channel_Group_Flag_Properties is present.</tp:deprecated>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <signal name="GroupFlagsChanged" tp:name-for-bindings="Group_Flags_Changed">
      <arg name="Added" tp:type="Channel_Group_Flags" type="u">
        <tp:docstring>
          A bitwise OR of the flags which have been set
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Channel_Group_Flags" type="u">
        <tp:docstring>
          A bitwise OR of the flags which have been cleared
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when the flags as returned by
        <tp:member-ref>GetGroupFlags</tp:member-ref> are changed.
        The user interface should be updated as appropriate.
      </tp:docstring>
    </signal>

    <tp:enum name="Channel_Group_Change_Reason" type="u">
      <tp:enumvalue suffix="None" value="0">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>No reason was provided for this change.</p>

          <p>In particular, this reason SHOULD be used when representing
            users joining a named chatroom in the usual way, users leaving
            a chatroom by their own request, and normal termination of a
            StreamedMedia call by the remote user.</p>

          <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is removed from
            a group for this reason and the actor is not the SelfHandle, the
            equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Terminated</code>.</p>

          <p>If the SelfHandle is removed from a group for this reason and
            the actor is also the SelfHandle, the equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Cancelled</code>.</p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Offline" value="1">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is due to a user going offline. Also used when
            user is already offline, but this wasn't known previously.</p>

          <p>If a one-to-one <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
            call fails because the contact being called is offline, the
            connection manager SHOULD indicate this by removing both the
            <tp:member-ref>SelfHandle</tp:member-ref> and the other contact's
            handle from the Group interface with reason Offline.</p>

          <tp:rationale>
            For 1-1 calls, the call terminates as a result of removing the
            remote contact, so the SelfHandle should be removed at the same
            time as the remote contact and for the same reason.
          </tp:rationale>

          <p>If a handle is removed from a group for this reason, the
            equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Offline</code>.</p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Kicked" value="2">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is due to a kick operation.</p>

          <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is removed
            from a group for this reason, the equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Channel.Kicked</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Busy" value="3">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is due to a busy indication.</p>

          <p>If a one-to-one <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
            call fails because the contact being called is busy, the
            connection manager SHOULD indicate this by removing both the
            <tp:member-ref>SelfHandle</tp:member-ref> and the other contact's
            handle from the Group interface with reason Busy.</p>

          <tp:rationale>
            For 1-1 calls, the call terminates as a result of removing the
            remote contact, so the SelfHandle should be removed at the same
            time as the remote contact and for the same reason.
          </tp:rationale>

          <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is removed
            from a group for this reason, the equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Busy</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Invited" value="4">
        <tp:docstring>
          The change is due to an invitation. This reason SHOULD only be used
          when contacts are added to the remote-pending set (to indicate that
          the contact has been invited) or to the members (to indicate that
          the contact has accepted the invitation).

          <tp:rationale>
            Otherwise, what would it mean?
          </tp:rationale>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Banned" value="5">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is due to a kick+ban operation.</p>

          <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is removed
            from a group for this reason, the equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.Channel.Banned</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Error" value="6">
        <tp:docstring>
            The change is due to an error occurring.
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Invalid_Contact" value="7">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is because the requested contact does not exist.</p>

          <p>For instance, if the user invites a nonexistent contact to a
            chatroom or attempts to call a nonexistent contact, this could
            be indicated by the CM adding that contact's handle to
            remote-pending for reason None or Invited, then removing it for
            reason Invalid_Contact. In the case of a 1-1 StreamedMedia
            call, the CM SHOULD remove the self handle from the Group
            in the same signal.</p>

          <tp:rationale>
            For 1-1 calls, the call terminates as a result of removing the
            remote contact, so the SelfHandle should be removed at the same
            time as the remote contact and for the same reason.
          </tp:rationale>

          <p>If a contact is removed from a group for this reason, the
            equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.DoesNotExist</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="No_Answer" value="8">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is because the requested contact did not respond.</p>

          <p>If a one-to-one <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
            call fails because the contact being called did not respond, the
            connection manager SHOULD indicate this by removing both the
            <tp:member-ref>SelfHandle</tp:member-ref> and the other contact's
            handle from the Group interface with reason No_Answer.</p>

          <tp:rationale>
            Documenting existing practice.
          </tp:rationale>

          <p>If a contact is removed from a group for this reason, the
            equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.NoAnswer</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Renamed" value="9">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is because a contact's unique identifier changed.
          There must be exactly one handle in the removed set and exactly
          one handle in one of the added sets. The <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Renaming">Renamed</tp:dbus-ref>
          signal on the
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">Renaming</tp:dbus-ref>
          interface will have been emitted for the same handles,
          shortly before this <tp:member-ref>MembersChanged</tp:member-ref> signal is emitted.</p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Permission_Denied" value="10">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The change is because there was no permission to contact the
            requested handle.</p>

          <p>If a contact is removed from a group for this reason, the
            equivalent D-Bus error is
            <code>org.freedesktop.Telepathy.Error.PermissionDenied</code>.
          </p>
        </tp:docstring>
      </tp:enumvalue>
      <tp:enumvalue suffix="Separated" value="11">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>If members are removed with this reason code, the change is
            because the group has split into unconnected parts which can only
            communicate within themselves (e.g. netsplits on IRC use this
            reason code).
          </p>
          <p>
            If members are added with this reason code, the change is because
            unconnected parts of the group have rejoined. If this channel
            carries messages (e.g. <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text</tp:dbus-ref>
            or <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Tubes</tp:dbus-ref>
            channels) applications must
            assume that the contacts being added are likely to have missed some
            messages as a result of the separation, and that the contacts
            in the group are likely to have missed some messages from the
            contacts being added.
          </p>
          <p>Note that from the added contacts' perspective, they have been
            in the group all along, and the contacts we indicate to be in
            the group (including the local user) have just rejoined
            the group with reason Separated. Application protocols in Tubes
            should be prepared to cope with this situation.
          </p>

          <p>The <tp:member-ref>SelfHandle</tp:member-ref> SHOULD NOT be
            removed from channels with this reason.</p>
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <signal name="MembersChanged" tp:name-for-bindings="Members_Changed">
      <arg name="Message" type="s">
        <tp:docstring>
          A string message from the server, or blank if not
        </tp:docstring>
      </arg>
      <arg name="Added" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members added to the channel
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members removed from the channel
        </tp:docstring>
      </arg>
      <arg name="Local_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members who are pending local approval
        </tp:docstring>
      </arg>
      <arg name="Remote_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members who are pending remote approval
        </tp:docstring>
      </arg>
      <arg name="Actor" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          The contact handle of the person who made the change, or 0
          if not known
        </tp:docstring>
      </arg>
      <arg name="Reason" tp:type="Channel_Group_Change_Reason" type="u">
        <tp:docstring>
          A reason for the change
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when contacts join any of the three lists (members, local
          pending or remote pending) or when they leave any of the three lists.
          There may also be a message from the server regarding this change,
          which may be displayed to the user if desired.</p>

        <p>All channel-specific handles that are mentioned in this signal
          MUST be represented in the value of the
          <tp:member-ref>HandleOwners</tp:member-ref> property.
          In practice, this will mean that
          <tp:member-ref>HandleOwnersChanged</tp:member-ref> is
          emitted <em>before</em> emitting a MembersChanged signal in which
          channel-specific handles are added, but that it is emitted
          <em>after</em> emitting a MembersChanged signal in which
          channel-specific handles are removed.</p>
      </tp:docstring>
    </signal>

    <tp:mapping name="Handle_Identifier_Map">
      <tp:docstring>
        A map from handles to the corresponding normalized string identifier.
      </tp:docstring>
      <tp:added version="0.17.17"/>

      <tp:member name="Handle" tp:type="Contact_Handle" type="u">
        <tp:docstring>
          A nonzero handle
        </tp:docstring>
      </tp:member>
      <tp:member name="Identifier" type="s">
        <tp:docstring>
          The same string that would be returned by <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>
          for this handle.
        </tp:docstring>
      </tp:member>
    </tp:mapping>

    <signal name="MembersChangedDetailed" tp:name-for-bindings="Members_Changed_Detailed">
      <arg name="Added" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members added to the channel
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members removed from the channel
        </tp:docstring>
      </arg>
      <arg name="Local_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members who are pending local approval
        </tp:docstring>
      </arg>
      <arg name="Remote_Pending" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          A list of members who are pending remote approval
        </tp:docstring>
      </arg>
      <arg name="Details" tp:type="String_Variant_Map" type="a{sv}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Information about the change, which may include the following
            well-known keys:</p>

          <dl>
            <dt>actor (u — <tp:type>Contact_Handle</tp:type>)</dt>
            <dd>The contact handle of the person who made the change; 0 or
              omitted if unknown or not applicable.</dd>

            <dt>change-reason (u — <tp:type>Channel_Group_Change_Reason</tp:type>)</dt>
            <dd>A reason for the change.</dd>

            <dt>contact-ids (a{us} — <tp:type>Handle_Identifier_Map</tp:type>)</dt>
            <dd>
              <p>The string identifiers for handles mentioned in this signal, to
              give clients the minimal information necessary to react to the
              event without waiting for round-trips.  Connection managers
              SHOULD include the identifiers for members added to the group and
              for the actor (if any); they MAY omit the identifiers for handles
              which have been removed from the group.</p>

              <tp:rationale>
                <p>On IRC, an event such as a netsplit could cause the vast
                majority of a channel to leave.  Given that clients should
                already know the identifiers of a channel's members, including
                potentially hundreds of strings in the netsplit signal is
                unnecessary.</p>
              </tp:rationale>

              <p>Clients MUST NOT assume that the presence or absence of a
                handle in this mapping is meaningful. This mapping is merely
                an optimization for round-trip reduction, and connection
                managers MAY add additional handles, omit some handles, or
                omit the mapping completely.</p>
            </dd>

            <dt>message (s)</dt>
            <dd>A string message from the server regarding the change</dd>

            <dt>error (s — <tp:type>DBus_Error_Name</tp:type>)</dt>
            <dd>A (possibly implementation-specific) DBus error describing the
              change, providing more specific information than the
              <tp:type>Channel_Group_Change_Reason</tp:type> enum allows. This
              MUST only be present if it is strictly more informative than
              'change-reason'; if present, 'change-reason' MUST be set to the
              closest available reason.

              <tp:rationale>
                A SIP connection manager might want to signal &quot;402 Payment
                required&quot; as something more specific than Error or
                Permission_Denied so that a SIP-aware UI could handle it
                specially; including a namespaced error permits this to be done
                without <tp:type>Channel_Group_Change_Reason</tp:type> being
                extended to encompass every error any CM ever wants to report.
              </tp:rationale>
            </dd>

            <dt>debug-message (s)</dt>
            <dd>Debugging information on the change. SHOULD NOT be shown to
              users in normal circumstances.</dd>
          </dl>
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Emitted when contacts join any of the three lists (members, local
          pending or remote pending) or when they leave any of the three
          lists. This signal provides a superset of the information provided by
          <tp:member-ref>MembersChanged</tp:member-ref>;
          if the channel's <tp:member-ref>GroupFlags</tp:member-ref>
          contains Members_Changed_Detailed, then clients may listen exclusively
          to this signal in preference to that signal.</p>

        <p>All channel-specific handles that are mentioned in this signal
          MUST be represented in the value of the
          <tp:member-ref>HandleOwners</tp:member-ref> property.  In practice,
          this will mean that
          <tp:member-ref>HandleOwnersChanged</tp:member-ref> is emitted
          <em>before</em> emitting a MembersChangedDetailed signal in which
          channel-specific handles are added, but that it is emitted
          <em>after</em> emitting a MembersChangedDetailed signal in which
          channel-specific handles are removed.</p>
      </tp:docstring>
      <tp:added version="0.17.16"/>
    </signal>

    <method name="RemoveMembers" tp:name-for-bindings="Remove_Members">
      <arg direction="in" name="Contacts" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          An array of contact handles to remove from the channel
        </tp:docstring>
      </arg>
      <arg direction="in" name="Message" type="s">
        <tp:docstring>
          A string message, which can be blank if desired
        </tp:docstring>
      </arg>
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Requests the removal of contacts from a channel, reject their
          request for channel membership on the pending local list, or
          rescind their invitation on the pending remote list.</p>

        <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is in a Group,
          it can be removed via this method, in order to leave the group
          gracefully. This is the recommended way to leave a chatroom, close
          or reject a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
          call, and so on.</p>

        <p>Accordingly, connection managers SHOULD support
          doing this, regardless of the value of
          <tp:member-ref>GroupFlags</tp:member-ref>.
          If doing so fails with PermissionDenied, this is considered to a bug
          in the connection manager, but clients MUST recover by falling back
          to closing the channel with the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Close</tp:dbus-ref>
          method.</p>

        <p>Removing any contact from the local pending list is always
          allowed. Removing contacts other than the
          <tp:member-ref>SelfHandle</tp:member-ref> from the channel's members
          is allowed if and only if Channel_Group_Flag_Can_Remove is in the
          <tp:member-ref>GroupFlags</tp:member-ref>,
          while removing contacts other than the
          <tp:member-ref>SelfHandle</tp:member-ref> from the remote pending list
          is allowed if and only if Channel_Group_Flag_Can_Rescind is in the
          <tp:member-ref>GroupFlags</tp:member-ref>.</p>

        <p>A message may be provided along with the request, which will be
          sent to the server if supported. See the
          Channel_Group_Flag_Message_Remove,
          Channel_Group_Flag_Message_Depart,
          Channel_Group_Flag_Message_Reject and
          Channel_Group_Flag_Message_Rescind
          <tp:member-ref>GroupFlags</tp:member-ref> to see in which cases this
          message should be provided.</p>
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle"/>
      </tp:possible-errors>
    </method>

    <method name="RemoveMembersWithReason" tp:name-for-bindings="Remove_Members_With_Reason">
      <arg direction="in" name="Contacts" tp:type="Contact_Handle[]" type="au">
        <tp:docstring>
          An array of contact handles to remove from the channel
        </tp:docstring>
      </arg>
      <arg direction="in" name="Message" type="s">
        <tp:docstring>
          A string message, which can be blank if desired
        </tp:docstring>
      </arg>
      <arg direction="in" name="Reason" tp:type="Channel_Group_Change_Reason" type="u">
        <tp:docstring>
          A reason for the change
        </tp:docstring>
      </arg>
      <tp:docstring>
        As <tp:member-ref>RemoveMembers</tp:member-ref>, but a reason code may
        be provided where
        appropriate. The reason code may be ignored if the underlying
        protocol is unable to represent the given reason.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidHandle"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The provided reason code was invalid.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>Interface for channels which have multiple members, and where the members
    of the channel can change during its lifetime. Your presence in the channel
    cannot be presumed by the channel's existence (for example, a channel you
    may request membership of but your request may not be granted).</p>

  <p>This interface implements three lists: a list of current members
    (<tp:member-ref>Members</tp:member-ref>), and two lists of local pending
    and remote pending members
    (<tp:member-ref>LocalPendingMembers</tp:member-ref> and
    <tp:member-ref>RemotePendingMembers</tp:member-ref>, respectively).
    Contacts on the remote
    pending list have been invited to the channel, but the remote user has not
    accepted the invitation. Contacts on the local pending list have requested
    membership of the channel, but the local user of the framework must accept
    their request before they may join. A single contact should never appear on
    more than one of the three lists. The lists are empty when the channel is
    created, and the <tp:member-ref>MembersChanged</tp:member-ref> signal
    (and, if the channel's <tp:member-ref>GroupFlags</tp:member-ref> contains
    Members_Changed_Detailed, the
    <tp:member-ref>MembersChangedDetailed</tp:member-ref> signal)
    should be emitted when information
    is retrieved from the server, or changes occur.</p>

  <p>If the <tp:member-ref>MembersChanged</tp:member-ref> or
    <tp:member-ref>MembersChangedDetailed</tp:member-ref> signal indicates
    that the <tp:member-ref>SelfHandle</tp:member-ref> has been removed from
    the channel, and the channel subsequently emits <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Closed</tp:dbus-ref>,
    clients SHOULD consider the details given in the MembersChanged or
    MembersChangedDetailed signal to be the reason why the channel closed.</p>

  <p>Addition of members to the channel may be requested by using
    <tp:member-ref>AddMembers</tp:member-ref>. If
    remote acknowledgement is required, use of the AddMembers method will cause
    users to appear on the remote pending list. If no acknowledgement is
    required, AddMembers will add contacts to the member list directly.  If a
    contact is awaiting authorisation on the local pending list, AddMembers
    will grant their membership request.</p>

  <p>Removal of contacts from the channel may be requested by using
    <tp:member-ref>RemoveMembers</tp:member-ref>.  If a contact is awaiting
    authorisation on the local pending
    list, RemoveMembers will refuse their membership request. If a contact is
    on the remote pending list but has not yet accepted the invitation,
    RemoveMembers will rescind the request if possible.</p>

  <p>It should not be presumed that the requester of a channel implementing this
    interface is immediately granted membership, or indeed that they are a
    member at all, unless they appear in the list. They may, for instance,
    be placed into the remote pending list until a connection has been
    established or the request acknowledged remotely.</p>

  <p>If the local user joins a Group channel whose members or other state
    cannot be discovered until the user joins (e.g. many chat room
    implementations), the connection manager should ensure that the channel
    is, as far as possible, in a consistent state before adding the local
    contact to the members set; until this happens, the local contact should
    be in the remote-pending set. For instance, if the connection manager
    queries the server to find out the initial members list for the
    channel, it should leave the local contact in the remote-pending set
    until it has finished receiving the initial members list.
  </p>

  <p>If the protocol provides no reliable way to tell whether the complete
    initial members list has been received yet, the connection manager
    should make a best-effort attempt to wait for the full list
    (in the worst case, waiting for a suitable arbitrary timeout)
    rather than requiring user interfaces to do so on its behalf.</p>
    </tp:docstring>
  </interface>
</node>
<node name="/Channel_Interface_Hold" xml:base="../spec/Channel_Interface_Hold.xml">
  <tp:copyright> Copyright (C) 2005-2008 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright (C) 2005-2008 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright (C) 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  </tp:license>

  <interface name="org.freedesktop.Telepathy.Channel.Interface.Hold">
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"/>
    <tp:changed version="0.17.4">first API-stable version</tp:changed>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>Interface for channels where you may put the channel on hold.
        This only makes sense for channels where
        you are streaming media to or from the members. (To see whether the
        other participant has put you on hold, see <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">CallState</tp:dbus-ref>.)</p>

      <p>If you place a channel on hold, this indicates that you do not wish
        to be sent media streams by any of its members and will be ignoring
        any media streams you continue to receive. It also requests that the
        connection manager free up any resources that are only needed for
        an actively used channel (e.g. in a GSM or PBX call, it will be
        necessary to place an active call on hold before you can start
        another call).</p>
    </tp:docstring>

    <method name="GetHoldState" tp:name-for-bindings="Get_Hold_State">
      <tp:docstring>
        Return whether the local user has placed the channel on hold.
      </tp:docstring>

      <arg direction="out" name="HoldState" tp:type="Local_Hold_State" type="u">
        <tp:docstring>
          The state of the channel
        </tp:docstring>
      </arg>

      <arg direction="out" name="Reason" tp:type="Local_Hold_State_Reason" type="u">
        <tp:docstring>
          The reason why the channel is in that state
        </tp:docstring>
      </arg>
    </method>

    <signal name="HoldStateChanged" tp:name-for-bindings="Hold_State_Changed">
      <tp:docstring>
        Emitted to indicate that the hold state has changed for this channel.
        This may occur as a consequence of you requesting a change with
        <tp:member-ref>RequestHold</tp:member-ref>, or the state changing as a
        result of a request from
        another process.
      </tp:docstring>

      <arg name="HoldState" tp:type="Local_Hold_State" type="u">
        <tp:docstring>
          The state of the channel
        </tp:docstring>
      </arg>

      <arg name="Reason" tp:type="Local_Hold_State_Reason" type="u">
        <tp:docstring>
          The reason for the state change
        </tp:docstring>
      </arg>
    </signal>

    <tp:enum name="Local_Hold_State" type="u">
      <tp:docstring>
        The hold state of a channel.
      </tp:docstring>

      <tp:enumvalue suffix="Unheld" value="0">
        <tp:docstring>
          All streams are unheld (the call is active). New channels SHOULD
          have this hold state.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Held" value="1">
        <tp:docstring>
          All streams are held (the call is on hold)
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Pending_Hold" value="2">
        <tp:docstring>
          The connection manager is attempting to move to state Held, but
          has not yet completed that operation. It is unspecified whether
          any, all or none of the streams making up the channel are on hold.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Pending_Unhold" value="3">
        <tp:docstring>
          The connection manager is attempting to move to state Held, but
          has not yet completed that operation. It is unspecified whether
          any, all or none of the streams making up the channel are on hold.
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:enum name="Local_Hold_State_Reason" type="u">
      <tp:docstring>
        The reason for a change to the Local_Hold_State. Clients MUST
        treat unknown values as equivalent to Local_Hold_State_Reason_None.
      </tp:docstring>

      <tp:enumvalue suffix="None" value="0">
        <tp:docstring>
          The reason cannot be described by any of the predefined values
          (connection managers SHOULD avoid this reason, but clients MUST
          handle it gracefully)
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Requested" value="1">
        <tp:docstring>
          The change is in response to a user request
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Resource_Not_Available" value="2">
        <tp:docstring>
          The change is because some resource was not available
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <method name="RequestHold" tp:name-for-bindings="Request_Hold">
      <arg direction="in" name="Hold" type="b">
        <tp:docstring>
          A boolean indicating whether or not the channel should be on hold
        </tp:docstring>
      </arg>

      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Request that the channel be put on hold (be instructed not to send
          any media streams to you) or be taken off hold.</p>

        <p>If the connection manager can immediately tell that the requested
          state change could not possibly succeed, this method SHOULD
          return the NotAvailable error. If the requested state is the
          same as the current state, this method SHOULD return successfully
          without doing anything.</p>

        <p>Otherwise, this method SHOULD immediately set the hold state to
          Local_Hold_State_Pending_Hold or Local_Hold_State_Pending_Unhold
          (as appropriate), emitting
          <tp:member-ref>HoldStateChanged</tp:member-ref> if this is a change,
          and return successfully.</p>

        <p>The eventual success or failure of the request is indicated by a
          subsequent HoldStateChanged signal, changing the hold state to
          Local_Hold_State_Held or Local_Hold_State_Unheld.</p>

        <p>If the channel has multiple streams, and the connection manager
          succeeds in changing the hold state of one stream but fails to
          change the hold state of another, it SHOULD attempt to revert
          all streams to their previous hold states.</p>

        <p>The following state transitions SHOULD be used, where
          appropriate:</p>

        <ul>
          <li>Successful hold:
            (Unheld, any reason) → (Pending_Hold, Requested) →
            (Held, Requested)
          </li>
          <li>Successful unhold:
            (Held, any reason) → (Pending_Unhold, Requested) →
            (Unheld, Requested)
          </li>
          <li>Attempting to unhold fails at the first attempt to acquire a
            resource:
            (Held, any reason) → (Pending_Unhold, Requested) →
            (Held, Resource_Not_Available)
          </li>
          <li>Attempting to unhold acquires one resource, but fails to acquire
            a second, and takes time to release the first:
            (Held, any reason) → (Pending_Unhold, Requested) →
            (Pending_Hold, Resource_Not_Available) →
            (Held, Resource_Not_Available)
          </li>
        </ul>
      </tp:docstring>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable">
          <tp:docstring>
            The requested hold state cannot be achieved; for example,
            if only a limited number of channels can be in the &quot;not on hold&quot;
            state, attempts to exceed this number will raise NotAvailable.
          </tp:docstring>
        </tp:error>
      </tp:possible-errors>
    </method>

  </interface>
</node>
<node name="/Channel_Interface_Media_Signalling" xml:base="../spec/Channel_Interface_Media_Signalling.xml">
  <tp:copyright> Copyright © 2005-2009 Collabora Limited </tp:copyright>
  <tp:copyright> Copyright © 2005-2009 Nokia Corporation </tp:copyright>
  <tp:copyright> Copyright © 2006 INdT </tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"/>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>An interface for signalling a channel containing synchronised media
        sessions which can contain an arbitrary number of streams. The
        presence of this interface on a Channel indicates that the connection
        manager will not carry out the actual streaming for this channel,
        and that the client handling the channel is responsible for doing
        so; in most cases we recommend doing this by using the
        telepathy-farsight library.</p>

      <tp:rationale>
        <p>Streaming audio and (particularly) video requires a high level of
          integration with the UI, and having the connection manager act as
          a proxy would be likely to introduce unacceptable latency. As a
          result, audio/video streaming is offloaded into the client
          where possible, as an exception to the general design of
          Telepathy.</p>
      </tp:rationale>

      <p>The negotiation interface is based on the API of the
        <a href="http://farsight.freedesktop.org/">Farsight</a> library.
        This, in turn, is based upon the IETF MMusic ICE drafts, where
        connections are established by signalling potential connection
        candidates to the peer until a usable connection is found, and
        codecs are negotiated with an SDP-style offer and answer. However,
        the principles should be applicable to other media streaming methods
        and the API re-used without difficulty.</p>

      <p>Note that the naming conventions used in the MediaStreamHandler
        and MediaSessionHandler interfaces are rather confusing; methods
        have signal-like names and signals have method-like names, due to
        the API being based rather too closely on that of Farsight. This
        is for historical reasons and will be fixed in a future release
        of the Telepathy specification.</p>
    </tp:docstring>

    <tp:simple-type name="Media_Session_Type" type="s">
      <tp:docstring>The type of a media session. Currently, the only supported
        value is &quot;rtp&quot;.</tp:docstring>
    </tp:simple-type>

    <tp:struct array-name="Media_Session_Handler_Info_List" name="Media_Session_Handler_Info">
      <tp:docstring>A struct representing a active session handler.</tp:docstring>
      <tp:member name="Session_Handler" type="o">
        <tp:docstring>The object path of the session handler, which is on the
          same bus name as the channel.</tp:docstring>
      </tp:member>
      <tp:member name="Media_Session_Type" tp:type="Media_Session_Type" type="s">
        <tp:docstring>The media session's type</tp:docstring>
      </tp:member>
    </tp:struct>

    <method name="GetSessionHandlers" tp:name-for-bindings="Get_Session_Handlers">
      <arg direction="out" name="Session_Handlers" tp:type="Media_Session_Handler_Info[]" type="a(os)"/>
      <tp:docstring>
        Returns all currently active session handlers on this channel
        as a list of (session_handler_path, type).
      </tp:docstring>
    </method>

    <signal name="NewSessionHandler" tp:name-for-bindings="New_Session_Handler">
      <arg name="Session_Handler" type="o">
        <tp:docstring>
          Object path of the new <tp:dbus-ref namespace="org.freedesktop.Telepathy">Media.SessionHandler</tp:dbus-ref>
          object
        </tp:docstring>
      </arg>
      <arg name="Session_Type" tp:type="Media_Session_Type" type="s">
        <tp:docstring>
          String indicating type of session, eg &quot;rtp&quot;
        </tp:docstring>
      </arg>
      <tp:docstring>
        Signal that a session handler object has been created. The client
        should create a session object and create streams for the streams
        within.
      </tp:docstring>
    </signal>

    <tp:property name="nat-traversal" type="s">
      <tp:deprecated version="0.17.22">Use the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Media.StreamHandler">NATTraversal</tp:dbus-ref>
        property on the Media.StreamHandler, if available; use this
        as a fallback.</tp:deprecated>
      <tp:docstring>
        A string indicating the NAT traversal techniques employed by the
        streams within this channel if they do not have a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Media.StreamHandler">NATTraversal</tp:dbus-ref>
        property. The possible values are the same as for the NATTraversal
        property on the streams.
      </tp:docstring>
    </tp:property>

    <tp:property name="stun-server" type="s">
      <tp:deprecated version="0.17.22">Use the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Media.StreamHandler">STUNServers</tp:dbus-ref>
        property on the Media.StreamHandler, if available; use this
        as a fallback.</tp:deprecated>
      <tp:docstring>
        The IP address or hostname of the STUN server to use for NAT traversal
        if the individual streams do not specify one.
      </tp:docstring>
    </tp:property>

    <tp:property name="stun-port" type="q">
      <tp:deprecated version="0.17.22">Use the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Media.StreamHandler">STUNServers</tp:dbus-ref>
        property on the Media.StreamHandler, if available; use this
        as a fallback.</tp:deprecated>
      <tp:docstring>
      The UDP port number to use on the provided STUN server.
      </tp:docstring>
    </tp:property>

    <tp:property name="gtalk-p2p-relay-token" type="s">
      <tp:deprecated version="0.17.22">XMPP connection managers
        supporting the Google Talk relay server SHOULD make the necessary
        HTTP requests to find a username and password, and use those
        to populate the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Media.StreamHandler">RelayInfo</tp:dbus-ref>
        property on the Media.StreamHandler.</tp:deprecated>
      <tp:docstring>
      The authentication token for use with the Google Talk peer-to-peer relay
      server.
      </tp:docstring>
    </tp:property>

  </interface>
</node>
<node name="/Channel_Interface_Messages" xml:base="../spec/Channel_Interface_Messages.xml">
  <tp:copyright>Copyright © 2008-2009 Collabora Ltd.</tp:copyright>
  <tp:copyright>Copyright © 2008-2009 Nokia Corporation</tp:copyright>
  <tp:license xmlns="http://www.w3.org/1999/xhtml">
    <p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>

<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
USA.</p>
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.Messages">
    <tp:requires interface="org.freedesktop.Telepathy.Channel.Type.Text"/>
    <tp:added version="0.17.16">(as stable API)</tp:added>

    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>This interface extends the Text interface to support more general
        messages, including:</p>

      <ul>
        <li>messages with attachments (like MIME multipart/mixed)</li>
        <li>groups of alternatives (like MIME multipart/alternative)</li>
        <li>delivery reports</li>
        <li>any extra types of message we need in future</li>
      </ul>

      <p>Although this specification supports formatted (rich-text)
        messages with unformatted alternatives, implementations SHOULD NOT
        attempt to send formatted messages until the Telepathy specification
        has also been extended to cover capability discovery for message
        formatting.</p>

      <tp:rationale>
        We intend to expose all rich-text messages as XHTML-IM, but on some
        protocols, formatting is an extremely limited subset of that format
        (e.g. there are protocols where foreground/background colours, font
        and size can be set, but only for entire messages).
        Until we can tell UIs what controls to offer to the user, it's
        unfriendly to offer the user controls that may have no effect.
      </tp:rationale>

      <p>This interface also replaces <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text.SendError</tp:dbus-ref>,
        adding support for
        protocols where the message content is not echoed back to the sender on
        failure, adding support for receiving positive acknowledgements,
        and using the Messages queue for state-recovery
        (ensuring that incoming delivery reports are not lost if there is not
        currently a process handling them).</p>

      <p>If this interface is present, clients that support it SHOULD
        listen for the <tp:member-ref>MessageSent</tp:member-ref> and
        <tp:member-ref>MessageReceived</tp:member-ref> signals, and
        ignore the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Sent</tp:dbus-ref>,
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">SendError</tp:dbus-ref>
        and <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Received</tp:dbus-ref>
        signals on the Text interface (which are guaranteed to duplicate
        signals from this interface).</p>
    </tp:docstring>

    <property access="read" name="SupportedContentTypes" tp:name-for-bindings="Supported_Content_Types" type="as">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>A list of MIME types supported by this channel, with more preferred
          MIME types appearing earlier in the list. The list MAY include &quot;*/*&quot;
          to indicate that attachments with arbitrary MIME types can be sent.
          This list MUST NOT be empty, since all Messages implementations
          MUST accept messages containing a single &quot;text/plain&quot; part.</p>

        <p>Some examples of how this property interacts with the
          <tp:member-ref>MessagePartSupportFlags</tp:member-ref>:</p>

        <dl>
          <dt>A simple IM implementation: only plain text messages are
            allowed</dt>
          <dd>SupportedContentTypes = ['text/plain'],
            MessagePartSupportFlags = 0</dd>

          <dt>Formatted text with a plain text alternative is allowed (see the
            HTML interface draft)</dt>
          <dd>SupportedContentTypes = ['text/html', 'text/plain'],
            MessagePartSupportFlags = 0</dd>

          <dt>JPEG or PNG images may be sent, but without any attached
            text</dt>
          <dd>SupportedContentTypes = ['text/plain', 'image/jpeg',
            'image/png'], MessagePartSupportFlags = 0</dd>

          <dt>Unformatted text to which an optional JPEG or PNG image may be
            attached</dt>
          <dd>SupportedContentTypes = ['text/plain', 'image/jpeg',
            'image/png'], MessagePartSupportFlags = One_Attachment</dd>

          <dt>Formatted text to which arbitrarily many images may be
            attached</dt>
          <dd>SupportedContentTypes = ['text/html', 'text/plain', 'image/jpeg',
            'image/png', 'image/x-ms-bmp'], MessagePartSupportFlags =
            One_Attachment | Multiple_Attachments</dd>

          <dt>A full SIP implementation: arbitrary MIME messages are
            allowed</dt>
          <dd>SupportedContentTypes = ['*/*'], MessagePartSupportFlags =
            One_Attachment | Multiple_Attachments</dd>
        </dl>
      </tp:docstring>
    </property>

    <property access="read" name="MessagePartSupportFlags" tp:name-for-bindings="Message_Part_Support_Flags" tp:type="Message_Part_Support_Flags" type="u">
      <tp:docstring>
        Flags indicating the level of support for message parts on this
        channel.
      </tp:docstring>
    </property>

    <tp:flags name="Message_Part_Support_Flags" type="u" value-prefix="Message_Part_Support_Flag">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Flags indicating the level of support for message parts on this
          channel. They are designed such that setting more flags always
          implies that the channel has more capabilities.</p>

        <p>If no flags are set, this indicates that messages may contain
          a single message part whose content-type is any of the types
          from SupportedContentTypes, possibly with some alternatives.</p>

        <p>There is no flag indicating support for alternatives. This is
          because the SendMessage implementation can always accept messages
          containing alternatives, even if the underlying protocol does not,
          by deleting all alternatives except the first (most preferred)
          that is supported.</p>

        <tp:rationale>
          Each of the flags so far implies the previous flag, so we could
          have used a simple enumeration here; however, we've defined
          the message-part support indicator as a flag set for future
          expansion.
        </tp:rationale>

        <p>See <tp:member-ref>SupportedContentTypes</tp:member-ref> for some
          examples.</p>
      </tp:docstring>

      <tp:flag suffix="One_Attachment" value="1">
        <tp:docstring>
          <tp:member-ref>SendMessage</tp:member-ref> will accept messages
          containing a textual message body,
          plus a single attachment of any type listed in the
          SupportedContentTypes property. It does not make sense for this
          flag to be set if Message_Part_Support_Flag_Data_Only is not also set
          (because the connection manager can trivially provide an empty text
          part if necessary).
        </tp:docstring>
      </tp:flag>
      <tp:flag suffix="Multiple_Attachments" value="2">
        <tp:docstring>
          SendMessage will accept messages containing a textual message body,
          plus an arbitrary number of attachments of any type listed in the
          SupportedContentTypes property. It does not make sense for this
          flag to be set if Message_Part_Support_Flag_One_Attachment is not
          also set.
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <tp:mapping array-depth="2" array-name="Message_Part_List" name="Message_Part">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Part of a message's content. In practice, this mapping never
          appears in isolation - messages are represented by a list of
          <tp:type>Message_Part</tp:type> mappings.</p>

        <p>An example of how a message might
          look, in a Python-like syntax:</p>

          <pre>
[
  {
    'message-token': '9de9546a-3400-4419-a505-3ea270cb834c',
    'message-sender': 42,
    'message-sent': 1210067943,
    'message-received': 1210067947,
    'message-type': 0,              # = Channel_Text_Message_Type_Normal
    'pending-message-id': 437,
  },
  { 'alternative': 'main',
    'content-type': 'text/html',
    'content': 'Here is a photo of my cat:&lt;br /&gt;' +
               '&lt;img src=&quot;cid:catphoto&quot; alt=&quot;lol!&quot; /&gt;' +
               '&lt;br /&gt;Isn't it cute?',
  },
  { 'alternative': 'main',
    'content-type': 'text/plain',
    'content': 'Here is a photo of my cat:\n[IMG: lol!]\nIsn't it cute?',
  },
  { 'identifier': 'catphoto',
    'content-type': 'image/jpeg',
    'size': 101000,
    'needs-retrieval': True,
  },
]
          </pre>

        <div>
          <p>The first part of the message contains &quot;headers&quot; which refer
            to the entire message.</p>

          <p>It is an error for a connection manager to put keys referring
            to the message as a whole in the second or subsequent
            Message_Part, but clients MUST recover from this error by ignoring
            these keys in the second and subsequent parts.</p>

          <tp:rationale>
            <p>Instead of representing messages as aa{sv} where the first
              dictionary is special (a dictionary of headers), we could have
              used a signature like (a{sv}aa{sv}) to separate out the headers
              and the body parts.</p>

            <p>However, this would make access to the messages more awkward.
              In Python, the syntax for access to a header field would remain
              <code>message[0]['message-type']</code>, but access to a body
              field in the second body part would change from
              message[2]['content'] to message[1][1]['content']. In GLib,
              the message would change from being a
              GPtrArray(GHashTable) to being a
              GValueArray(GHashTable, GPtrArray(GHashTable)) which is rather
              inconvenient to dereference.</p>
          </tp:rationale>

          <p>Well-known keys for the message as a whole, and the corresponding
            value types, include:</p>

          <dl>
            <dt>message-token (s)</dt>
            <dd>An opaque, globally-unique identifier for the entire message.
              This MAY be treated as if it were a MIME Message-ID, e.g. for
              the mid: and cid: URI schemes. If omitted, there is no suitable
              token.</dd>

            <dt>message-sent (x - <tp:type>Unix_Timestamp64</tp:type>)</dt>
            <dd>The time the message was sent (if unavailable, the time
              it arrived at a central server MAY be used). Omitted if no
              reasonable approximation is available; SHOULD always be present
              on outgoing messages.</dd>

            <dt>message-received (x - <tp:type>Unix_Timestamp64</tp:type>)</dt>
            <dd>The time the message was received locally. SHOULD always
              be present.</dd>

            <dt>message-sender (u - <tp:type>Contact_Handle</tp:type>)</dt>
            <dd>The contact who sent the message. If 0 or omitted, the contact
              who sent the message could not be determined.</dd>

            <dt>message-type (u - <tp:type>Channel_Text_Message_Type</tp:type>)
            </dt>
            <dd>The type of message; if omitted,
              Channel_Text_Message_Type_Normal MUST be assumed. MAY
              be omitted for normal chat messages.</dd>

            <dt>pending-message-id (u - <tp:type>Message_ID</tp:type>)</dt>
            <dd>The incoming message ID. This MUST NOT be present on outgoing
              messages. Clients SHOULD NOT store this key - it is only valid
              for as long as the message remains unacknowledged.</dd>

            <dt>interface (s - <tp:type>DBus_Interface</tp:type>)</dt>
            <dd>This message is specific to the given interface, which is
              neither Text nor Messages. It SHOULD be ignored if that
              interface is not supported. (Note that an 'interface' key
              can also appear on the second and subsequent parts, where
              it indicates that that part (only) should be ignored if
              unsupported.)</dd>

            <dt>scrollback (b)</dt>
            <dd>If present and true, the incoming message was part of a
              replay of message history (this matches the Scrollback flag in
              <tp:type>Channel_Text_Message_Flags</tp:type>). This flag
              does not make sense on outgoing messages and SHOULD NOT
              appear there.</dd>

            <dt>rescued (b)</dt>
            <dd>If present and true, the incoming message has been seen in
              a previous channel during the lifetime of the Connection,
              but had not been acknowledged when that channel closed, causing
              an identical channel (in which the message now appears) to open.
              This matches the Rescued flag in
              <tp:type>Channel_Text_Message_Flags</tp:type>; it
              does not make sense on outgoing messages, and SHOULD NOT
              appear there.</dd>
          </dl>
        </div>

        <div>
          <p>The second and subsequent parts contain the message's
            content, including plain text, formatted text and/or attached
            files.</p>

          <p>It is an error for a connection manager to put keys referring
            to the message body in the first Message_Part;
            clients MUST recover from this error by ignoring
            these keys in first part.</p>

          <p>In any group of parts with the same non-empty value for the
            &quot;alternative&quot; key (which represent alternative versions of the
            same content), more faithful versions of the intended message MUST
            come before less faithful versions (note that this order is the
            opposite of MIME &quot;multipart/alternative&quot; parts). Clients SHOULD
            display the first alternative that they understand.</p>

          <tp:rationale>
            <p>Specifying the preference order means that if the underlying
              protocol doesn't support alternatives, the CM can safely delete
              everything apart from the first supported alternative when
              sending messages.</p>

            <p>The order is the reverse of MIME because MIME's rationale for
              placing the &quot;plainest&quot; part first (legibility in pre-MIME UAs)
              does not apply to us, and placing the most preferred part
              first simplifies display (a client can iterate the message
              in order, display the first alternative that it understands,
              and skip displaying all subsequent parts with the same
              &quot;alternative&quot; key).</p>
          </tp:rationale>

          <p>Clients SHOULD present all parts that are not redundant
            alternatives in the order they appear in this array, possibly
            excluding parts that are referenced by another displayed part.
            It is implementation-specific how the parts are presented to the
            user.</p>

          <tp:rationale>
            <p>This allows CMs to assume that all parts are actually shown to
              the user, even if they are not explicitly referenced - we do
              not yet recommend formatted text, and there is no way for
              plain text to reference an attachment since it has no concept of
              markup or references. This also forces clients to do something
              sensible with messages that consist entirely of &quot;attachments&quot;,
              with no &quot;body&quot; at all.</p>

            <p>For instance, when displaying the above example, a client that
              understands the HTML part should display the JPEG image once,
              between the two lines &quot;Here is a photo of my cat:&quot; and
              &quot;Isn't it cute?&quot;; it may additionally present the image in some
              way for a second time, after &quot;Isn't it cute?&quot;, or may choose
              not to.</p>

            <p>A client that does not understand HTML, displaying the same
              message, should display the plain-text part, followed by the JPEG
              image.</p>
          </tp:rationale>

          <p>Well-known keys for the second and subsequent parts, and the
            corresponding value types, include:</p>

          <dl>
            <dt>identifier (s)</dt>
            <dd>An opaque identifier for this part.
              Parts of a message MAY reference other parts by treating
              this identifier as if it were a MIME Content-ID and using
              the cid: URI scheme.</dd>

            <dt>alternative (s)</dt>
            <dd>
              <p>If present, this part of the message is an alternative for
                all other parts with the same value for &quot;alternative&quot;.
                Clients SHOULD only display one of them (this is expected to
                be used for XHTML messages in a future version of this
                specification).</p>

              <p>If omitted, this part is not an alternative for any other
                part.</p>

              <p>Parts of a message MAY reference the group of alternatives
                as a whole (i.e. a reference to whichever of them is chosen)
                by treating this identifier as if it were the MIME Content-ID
                of a multipart/alternative part, and using the cid: URI
                scheme.</p>
            </dd>

            <dt>content-type (s)</dt>
            <dd>
              <p>The MIME type of this part. See the documentation
                for ReceivedMessage for notes on the special status of
                &quot;text/plain&quot; parts.</p>

              <p>Connection managers MUST NOT signal parts without a
                'content-type' key; if a protocol provides no way to determine
                the MIME type, the connection manager is responsible for
                guessing it, but MAY fall back to &quot;text/plain&quot; for text and
                &quot;application/octet-stream&quot; for non-text.</p>

              <p>Clients MUST ignore parts without a 'content-type' key, which
                are reserved for future expansion.</p>
            </dd>

            <dt>lang (s)</dt>
            <dd>The natural language of this part, identified by a
              RFC 3066 language tag.

              <tp:rationale>
                XMPP allows alternative-selection by language as well as
                by content-type.
              </tp:rationale>
            </dd>

            <dt>size (u)</dt>
            <dd>The size in bytes (if needs-retrieval is true, this MAY be an
              estimated or approximate size). SHOULD be omitted if 'content'
              is provided.

              <tp:rationale>
                There's no point in providing the size if you're already
                providing all the content.
              </tp:rationale>
              </dd>

            <dt>needs-retrieval (b)</dt>
            <dd>If false or omitted, the connection
              manager already holds this part in memory. If present and true,
              this part will be retrieved on demand (like MIME's
              message/external-body), so clients should expect retrieval to
              take time; if this specification is later extended to provide a
              streaming version of GetPendingMessageContent, clients should
              use it for parts with this flag.</dd>

            <dt>truncated (b)</dt>
            <dd>The content available via the 'content' key or
              GetPendingMessageContent has been truncated by the server
              or connection manager (equivalent to
              Channel_Text_Message_Flag_Truncated in the Text interface).
            </dd>

            <dt>content (s or ay)</dt>
            <dd>The part's content, if it is available and
              sufficiently small to include here (implies that
              'needs-retrieval' is false or omitted). Otherwise, omitted.
              If the part is human-readable text or HTML, the value for this
              key MUST be a UTF-8 string (D-Bus signature 's').
              If the part is not text, the value MUST be a byte-array
              (D-Bus signature 'ay'). If the part is a text-based format
              that is not the main body of the message (e.g. an iCalendar
              or an attached XML document), the value SHOULD be a UTF-8 string,
              transcoding from another charset to UTF-8 if necessary, but
              MAY be a byte-array (of unspecified character set) if
              transcoding fails or the source charset is not known.</dd>

              <!-- FIXME: "sufficiently small to include" is not currently
              defined; we should add some API so clients can tell the
                CM how large a message it should emit in the signal.-->

            <dt>interface (s - <tp:type>DBus_Interface</tp:type>)</dt>
            <dd>This part is specific to the given interface, which is
              neither Text nor Messages. It SHOULD be ignored if that
              interface is not supported. (Note that an 'interface' key
              can also appear on the first part, where it indicates that the
              entire message should be ignored if unsupported.)</dd>
          </dl>

        </div>


        <div>
          <p>Delivery reports are also represented as messages, of type
            Channel_Text_Message_Type_Delivery_Report, with the
            Non_Text_Content flag in the Text interface.</p>

          <p>Whenever a message of type
            Channel_Text_Message_Type_Delivery_Report is signalled for a
            delivery error report, Channel.Type.Text.SendError SHOULD also
            be emitted; whenever Channel.Type.Text.SendError is emitted by a
            channel which supports this interface, a message of type
            Channel_Text_Message_Type_Delivery_Report MUST also be emitted.</p>

          <p>The corresponding message in the Messages interface MUST contain
            &quot;headers&quot; for the delivery report, as specified below, in its
            first Message_Part.</p>

          <dl>
            <dt>message-sender (u - Contact_Handle as defined above)</dt>
            <dd>MUST be the intended recipient of the original message, if
              available (zero or omitted if the intended recipient is
              unavailable or is not a contact, e.g. a chatroom), even if the
              delivery report actually came from an intermediate server.</dd>

            <dt>message-type (u - Channel_Text_Message_Type as defined
              above)</dt>
            <dd>MUST be Channel_Text_Message_Type_Delivery_Report.</dd>

            <dt>delivery-status (u - Delivery_Status)</dt>
            <dd>The status of the message. All delivery reports MUST contain
              this key in the first Message_Part.</dd>

            <dt>delivery-token (s - Sent_Message_Token)</dt>

            <dd>
              <p>An identifier for the message to which this delivery report
                refers. MUST NOT be an empty string. Omitted if not
                available.</p>

              <p>Clients may match this against the token produced by the
                SendMessage method and MessageSent signal. A status report
                with no token could match any sent message, and a sent
                message with an empty token could match any status report.
                If multiple sent messages match, clients SHOULD use some
                reasonable heuristic.</p>

              <tp:rationale>
                In an ideal world, we could unambiguously match reports
                against messages; however, deployed protocols are not ideal,
                and not all reports and messages can be matched.
              </tp:rationale>
            </dd>

            <dt>delivery-error (u - Channel_Text_Send_Error)</dt>
            <dd>
              The reason for the failure. MUST be omitted if this was a
              successful delivery; SHOULD be omitted if it would be
              Channel_Text_Send_Error_Unknown.
            </dd>

            <dt>delivery-dbus-error (s - DBus_Error_Name)</dt>
            <dd>
              The reason for the failure, specified as a (possibly
              implementation-specific) D-Bus error. MUST be omitted if this was
              a successful delivery. If set, the 'delivery-error' key SHOULD be
              set to the closest available value.
            </dd>

            <dt>delivery-error-message (s)</dt>
            <dd>
              Debugging information on why the message could not be delivered.
              MUST be omitted if this was a successful delivery; MAY always be
              omitted.
            </dd>

            <dt>delivery-echo (aa{sv} - Message_Part[])</dt>
            <dd>
              <p>The message content, as defined by the Messages interface.
                Omitted if no content is available. Content MAY have been
                truncated, message parts MAY have been removed, and message
                parts MAY have had their content removed (i.e. the message part
                metadata is present, but the 'content' key is not).</p>

              <tp:rationale>
                Some protocols, like XMPP, echo the failing message back to
                the sender. This is sometimes the only way to match it
                against the sent message, so we include it here.
              </tp:rationale>

              <p>Unlike in the Messages interface, content not visible
                in the value for this key cannot be retrieved by another
                means, so the connection manager SHOULD be more
                aggressive about including (possibly truncated) message
                content in the 'content' key.</p>

              <tp:rationale>
                The Messages interface needs to allow all content to be
                retrieved, but in this interface, the content we provide is
                merely a hint; so some is better than none, and it doesn't
                seem worth providing an API as complex as Messages'
                GetPendingMessageContent for the echoed message.
              </tp:rationale>
            </dd>

          </dl>

          <p>The second and subsequent Message_Part dictionaries, if present,
            are a human-readable report from the IM service.</p>

          <p>Clients MUST NOT attempt to send delivery reports using the
            SendMessage method in the Messages API, and connection managers
            MUST NOT allow this to be done. If support for sending delivery
            reports is later added, it will be part of this interface.</p>

          <p>Some example delivery reports in a Python-like syntax (in which
            arrays are indicated by [a, b] and dictionaries by {k1: v1, k2: v2})
            follow.</p>

          <dl>
            <dt>A minimal delivery report indicating permanent failure of the
              sent message whose token was
              <code>b9a991bd-8845-4d7f-a704-215186f43bb4</code> for an unknown
              reason</dt>
            <dd><pre>
[{
# header
'message-sender': 123,
'message-type': Channel_Text_Message_Type_Delivery_Report,
'delivery-status': Delivery_Status_Permanently_Failed,
'delivery-token': 'b9a991bd-8845-4d7f-a704-215186f43bb4',
}
# no body
]
</pre></dd>

            <dt>A delivery report where the failed message is echoed back to the
              sender rather than being referenced by ID, and the failure reason
              is that this protocol cannot send messages to offline contacts
              such as the contact with handle 123</dt>
            <dd><pre>
[{ # header
'message-sender': 123,
'message-type': Channel_Text_Message_Type_Delivery_Report,
'delivery-status': Delivery_Status_Temporarily_Failed,
'delivery-error': Channel_Text_Send_Error_Offline,
'delivery-echo':
    [{ # header of original message
    'message-sender': 1,
    'message-sent': 1210067943,
    },
    { # body of original message
    'content-type': 'text/plain',
    'content': 'Hello, world!',
    }]
  ],

# no body
]
</pre></dd>

            <dt>A maximally complex delivery report: the server reports a
              bilingual human-readable failure message because the user sent
              a message &quot;Hello, world!&quot; with token
              <code>b9a991bd-8845-4d7f-a704-215186f43bb4</code> to a contact
              with handle 123, but that handle represents a contact who does not
              actually exist</dt>
            <dd><pre>
[{ # header
'message-sender': 123,
'message-type': Channel_Text_Message_Type_Delivery_Report,
'delivery-status': Delivery_Status_Permanently_Failed,
'delivery-error': Channel_Text_Send_Error_Invalid_Contact,
'delivery-token': 'b9a991bd-8845-4d7f-a704-215186f43bb4',
'delivery-echo':
    [{ # header of original message
    'message-sender': 1,
    'message-sent': 1210067943,
    },
    { # body of original message
    'content-type': 'text/plain',
    'content': 'Hello, world!',
    }]
  ],
},
{ # message from server (alternative in English)
'alternative': '404',
'content-type': 'text/plain',
'lang': 'en',
'content': 'I have no contact with that name',
},
{ # message from server (alternative in German)
'alternative': '404'.
'content-type': 'text/plain',
'lang': 'de',
'content', 'Ich habe keinen Kontakt mit diesem Namen',
}
]
</pre></dd>

            <dt>A minimal delivery report indicating successful delivery
              of the sent message whose token was
              <code>b9a991bd-8845-4d7f-a704-215186f43bb4</code></dt>
            <dd><pre>
[{
# header
'message-sender': 123,
'message-type': Channel_Text_Message_Type_Delivery_Report,
'delivery-status': Delivery_Status_Delivered,
'delivery-token': 'b9a991bd-8845-4d7f-a704-215186f43bb4',
}
# no body
]
</pre></dd>

          </dl>

        </div>
      </tp:docstring>

      <tp:member name="Key" type="s">
        <tp:docstring>
          A key, which SHOULD be one of the well-known keys specified, if
          possible.
        </tp:docstring>
      </tp:member>

      <tp:member name="Value" type="v">
        <tp:docstring>
          The value corresponding to the given key, which must be of one of
          the types indicated.
        </tp:docstring>
      </tp:member>
    </tp:mapping>

    <tp:simple-type array-name="Message_Part_Index_List" name="Message_Part_Index" type="u">
      <tp:added version="0.17.17"/>
      <tp:docstring>
        The index of a message part within a message.
      </tp:docstring>
    </tp:simple-type>

    <tp:mapping name="Message_Part_Content_Map">
      <tp:added version="0.17.17"/>
      <tp:docstring>
        A mapping from message part indexes to their content, as returned by
        <tp:member-ref>GetPendingMessageContent</tp:member-ref>.
      </tp:docstring>

      <tp:member name="Part" tp:type="Message_Part_Index" type="u">
        <tp:docstring>
          Indexes into the array of <tp:type>Message_Part</tp:type>s that
          represents a message. The &quot;headers&quot; part (which is not a valid
          argument to GetPendingMessageContent) is considered to be part 0,
          so the valid part numbers start at 1 (for the second message part).
        </tp:docstring>
      </tp:member>

      <tp:member name="Content" type="v">
        <tp:docstring>
          The message part's content. The variant MUST contain either type
          's' or 'ay' (UTF-8 text string, or byte array), following the
          same rules as for the value of the 'content' key in
          the <tp:type>Message_Part</tp:type> mappings.
        </tp:docstring>
      </tp:member>
    </tp:mapping>

    <tp:simple-type name="Sent_Message_Token" type="s">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>An opaque token used to identify sent messages. As a special case,
          the empty string indicates that there is no particular
          identification for a message.</p>

        <p>CM implementations SHOULD use an identifier expected to be unique,
          such as a UUID, if possible.</p>

        <p>Some protocols can only track a limited number of sent messages
          in a small message-ID space. As a result, clients MUST NOT assume
          that message tokens will not be re-used, and SHOULD use some
          reasonable heuristic to assign delivery reports to messages, such
          as matching on message content or timestamp (if available), or
          assuming that the delivery report refers to the most recent message
          with that ID.</p>
      </tp:docstring>
    </tp:simple-type>

    <method name="SendMessage" tp:name-for-bindings="Send_Message">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Submit a message to the server for sending.
          If this method returns successfully, the message has been submitted
          to the server and the <tp:member-ref>MessageSent</tp:member-ref>
          signal is emitted. A corresponding
          <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Sent</tp:dbus-ref>
          signal on the Text interface MUST also be emitted.</p>

        <p>This method MUST return before the MessageSent signal is
          emitted.</p>

        <tp:rationale>
          <p>This means that the process sending the message is the first
            to see the <tp:type>Sent_Message_Token</tp:type>, and can
            relate the message to the corresponding
            <tp:member-ref>MessageSent</tp:member-ref> signal by comparing
            message tokens (if supported by the protocol).</p>
        </tp:rationale>

        <p>If this method fails, message submission to the server has failed
          and no signal on this interface (or the Text interface) is
          emitted.</p>
      </tp:docstring>

      <arg direction="in" name="Message" tp:type="Message_Part[]" type="aa{sv}">
        <tp:docstring>
          The message content, including any attachments or alternatives
        </tp:docstring>
      </arg>
      <arg direction="in" name="Flags" tp:type="Message_Sending_Flags" type="u">
        <tp:docstring>
          Flags affecting how the message is sent.
        </tp:docstring>
      </arg>

      <arg direction="out" name="Token" tp:type="Sent_Message_Token" type="s">
        <tp:docstring>
          An opaque token used to match any incoming delivery or failure
          reports against this message, or an empty string if the message
          is not readily identifiable.
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring>
            The requested message is malformed and cannot be sent.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <tp:flags name="Message_Sending_Flags" type="u" value-prefix="Message_Sending_Flag">
      <tp:docstring>
        Flags altering the way a message is sent. The &quot;most usual&quot; action
        should always be to have these flags unset.
      </tp:docstring>

      <tp:flag suffix="Report_Delivery" value="1">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>Provide a successful delivery report if possible, even if this is
            not the default for this protocol. Ignored if delivery reports are
            not possible on this protocol.</p>

          <tp:rationale>
            <p>In some protocols, like XMPP, it is not conventional to request
              or send positive delivery notifications.</p>
          </tp:rationale>

          <p>Delivery failure reports SHOULD always be sent, but if this flag
            is present, the connection manager MAY also try harder to obtain
            failed delivery reports or allow them to be matched to outgoing
            messages.</p>
        </tp:docstring>
      </tp:flag>
    </tp:flags>

    <signal name="MessageSent" tp:name-for-bindings="Message_Sent">
      <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
        <p>Signals that a message has been submitted for sending. This
          MUST be emitted exactly once per emission of the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Sent</tp:dbus-ref>
          signal on the
          Text interface.</p>

        <tp:rationale>
          <p>This signal allows a process that is not the caller of
            SendMessage to log sent messages. The double signal-emission
            provides compatibility with older clients. Clients supporting
            Messages should listen for Messages.MessageSent only (if the
            channel has the Messages interface) or Text.Sent only
            (otherwise).</p>
        </tp:rationale>
      </tp:docstring>

      <arg name="Content" tp:type="Message_Part[]" type="aa{sv}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The message content (see <tp:type>Message_Part</tp:type> for full
            details). If the message that was passed to SendMessage has a
            formatted text part that the connection manager recognises, but no
            text/plain alternative, the CM MUST use the formatted text part to
            generate a text/plain alternative which is also included in this
            signal argument.</p>

          <p>If the connection manager can predict that the message will be
            altered during transmission, this argument SHOULD reflect what
            other contacts will receive, rather than being a copy of the
            argument to SendMessage (if the message is truncated,
            formatting or alternatives are dropped, etc., then the edited
            version SHOULD appear in this signal).</p>
        </tp:docstring>
      </arg>

      <arg name="Flags" tp:type="Message_Sending_Flags" type="u">
        <tp:docstring>
          <p>Flags affecting how the message was sent.  The flags might be a
            subset of those passed to SendMessage if the caller requested
            unsupported flags.</p>
        </tp:docstring>
      </arg>

      <arg name="Message_Token" tp:type="Sent_Message_Token" type="s">
        <tp:docstring>
          An opaque token used to match any incoming delivery or failure
          reports against this message, or an empty string if the message
          is not readily identifiable.
        </tp:docstring>
      </arg>
    </signal>

    <property access="read" name="PendingMessages" tp:name-for-bindings="Pending_Messages" tp:type="Message_Part[][]" type="aaa{sv}">
      <tp:docstring>
        A list of incoming messages that have neither been acknowledged nor
        rejected. This list is a more detailed version of the one returned
        by <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text.ListPendingMessages</tp:dbus-ref>,
        and contains the same messages, uniquely identified by the same
        pending message IDs. Its items can be removed using
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text.AcknowledgePendingMessages</tp:dbus-ref>.
      </tp:docstring>
    </property>

    <signal name="PendingMessagesRemoved" tp:name-for-bindings="Pending_Messages_Removed">
      <tp:docstring>
        The messages with the given IDs have been removed from the
        <tp:member-ref>PendingMessages</tp:member-ref> list. Clients SHOULD NOT
        attempt to acknowledge those messages.

        <tp:rationale>
          This completes change notification for the PendingMessages property
          (previously, there was change notification when pending messages
          were added, but not when they were removed).
        </tp:rationale>
      </tp:docstring>

      <arg name="Message_IDs" tp:type="Message_ID[]" type="au">
        <tp:docstring>
          The messages that have been removed from the pending message list.
        </tp:docstring>
      </arg>
    </signal>

    <method name="GetPendingMessageContent" tp:name-for-bindings="Get_Pending_Message_Content">
      <tp:docstring>
        Retrieve the content of one or more parts of a pending message.
        Note that this function may take a considerable amount of time
        to return if the part's 'needs-retrieval' flag is true; consider
        extending the default D-Bus method call timeout. Additional API is
        likely to be added in future, to stream large message parts.
      </tp:docstring>

      <arg direction="in" name="Message_ID" tp:type="Message_ID" type="u">
        <tp:docstring>
          The ID of a pending message
        </tp:docstring>
      </arg>

      <arg direction="in" name="Parts" tp:type="Message_Part_Index[]" type="au">
        <tp:docstring>
          The desired entries in the array of message parts, identified by
          their position. The &quot;headers&quot; part (which is not a valid argument
          to this method) is considered to be part 0, so the valid part
          numbers start at 1 (for the second Message_Part).
        </tp:docstring>
      </arg>

      <arg direction="out" name="Content" tp:type="Message_Part_Content_Map" type="a{uv}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          <p>The content of the requested parts. The keys in this mapping
            are positions in the array of message parts; the values are
            either of type 's' or 'ay' (UTF-8 text string, or byte array),
            following the same rules as for the value of the 'content' key in
            the <tp:type>Message_Part</tp:type> mappings.</p>

          <p>If the one of the requested part numbers was greater than zero
            but referred to a part that had no content (i.e. it had no
            'content-type' key or no 'content' key), it is simply omitted from
            this mapping; this is not considered to be an error condition.</p>
        </tp:docstring>
      </arg>

      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument">
          <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
            Either there is no pending message with the given message ID,
            or one of the part numbers given was 0 or too large.
          </tp:docstring>
        </tp:error>
        <tp:error name="org.freedesktop.Telepathy.Error.NotAvailable"/>
        <tp:error name="org.freedesktop.Telepathy.Error.PermissionDenied"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>

    <signal name="MessageReceived" tp:name-for-bindings="Message_Received">
      <tp:docstring>
        Signals that a message has been received and added to the pending
        messages queue. This MUST be emitted exactly once per emission of the
        <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Received</tp:dbus-ref>
        signal on the Text interface.

        <tp:rationale>
          The double signal-emission provides compatibility with older
          clients. Clients supporting Messages should listen for
          Messages.MessageReceived only (if the channel has the Messages
          interface) or Text.Received only (otherwise).
        </tp:rationale>
      </tp:docstring>

      <arg name="Message" tp:type="Message_Part[]" type="aa{sv}">
        <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
          The message content, including any attachments or alternatives
        </tp:docstring>
      </arg>
    </signal>

    <tp:enum name="Delivery_Status" plural="Delivery_Statuses" type="u" value-prefix="Delivery_Status">
      <tp:docstring>
        <p>The status of a message as indicated by a delivery report.</p>

        <p>If this enum is extended in future specifications, this should
          only be to add new, non-overlapping conditions (i.e. all failures
          should still be signalled as either Temporarily_Failed
          or Permanently_Failed). If additional detail is required (e.g.
          distinguishing between the various types of permanent failure) this
          will be done using additional keys in the Message_Part.</p>
      </tp:docstring>

      <tp:enumvalue suffix="Unknown" value="0">
        <tp:docstring>
          The message's disposition is unknown.
          Clients SHOULD consider all messages to have status
          Delivery_Status_Unknown unless otherwise specified; connection
          managers SHOULD NOT signal this delivery status explicitly.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Delivered" value="1">
        <tp:docstring>
          The message has been delivered to the intended recipient.
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Temporarily_Failed" value="2">
        <tp:docstring>
          Delivery of the message has failed. Clients SHOULD notify the user,
          but MAY automatically try sending another copy of the message.

          <tp:rationale>
            Similar to errors with type=&quot;wait&quot; in XMPP; analogous to
            4xx errors in SMTP.
          </tp:rationale>
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Permanently_Failed" value="3">
        <tp:docstring>
          Delivery of the message has failed. Clients SHOULD NOT try again
          unless by specific user action. If the user does not modify the
          message or alter configuration before re-sending, this error is
          likely to happen again.

          <tp:rationale>
            Similar to errors with type=&quot;cancel&quot;, type=&quot;modify&quot;
            or type=&quot;auth&quot; in XMPP; analogous to 5xx errors in SMTP.
          </tp:rationale>
        </tp:docstring>
      </tp:enumvalue>

      <tp:enumvalue suffix="Accepted" value="4">
        <tp:docstring>
          An intermediate server has accepted the message but the message
          has not been yet delivered to the ultimate recipient. The
          connection manager might send a Failed report or Delivered report
          later.

          <tp:rationale>
            Similar to &quot;202 Accepted&quot; success code in SIP; analogous to
            251 and 252 responses in SMTP.
          </tp:rationale>
        </tp:docstring>
      </tp:enumvalue>
    </tp:enum>

    <tp:flags name="Delivery_Reporting_Support_Flags" type="u" value-prefix="Delivery_Reporting_Support_Flag">
      <tp:docstring>
        Flags indicating the level of support for delivery reporting on this
        channel. Any future flags added to this set will conform to the
        convention that the presence of an extra flag implies that
        more operations will succeed.
      </tp:docstring>

      <tp:flag suffix="Receive_Failures" value="1">
        <tp:docstring>
          Clients MAY expect to receive negative delivery reports if
          Message_Sending_Flag_Report_Delivery is specified when sending.

          <tp:rationale>
            If senders want delivery reports, they should ask for them.
            If they don't want delivery reports, they can just ignore them,
            so there's no need to have capability discovery for what will
            happen if a delivery report isn't requested.
          </tp:rationale>
        </tp:docstring>
      </tp:flag>

      <tp:flag suffix="Receive_Successes" value="2">
        <tp:docstring>
          Clients MAY expect to receive positive delivery reports if
          Message_Sending_Flag_Report_Delivery is specified when sending.

          <tp:rationale>
            Same rationale as Receive_Failures.
          </tp:rationale>
        </tp:docstring>
      </tp:flag>

    </tp:flags>

    <property access="read" name="DeliveryReportingSupport" tp:name-for-bindings="Delivery_Reporting_Support" tp:type="Delivery_Reporting_Support_Flags" type="u">
      <tp:docstring>
        A bitfield indicating features supported by this channel.
      </tp:docstring>
    </property>

  </interface>
</node>
<node name="/Channel_Interface_Password" xml:base="../spec/Channel_Interface_Password.xml">
  <tp:copyright>
Copyright © 2005-2009 Collabora Limited
Copyright © 2005-2009 Nokia Corporation
Copyright © 2006 INdT
  </tp:copyright>
  <tp:license>
    This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  </tp:license>
  <interface name="org.freedesktop.Telepathy.Channel.Interface.Password">
    <tp:requires interface="org.freedesktop.Telepathy.Channel"/>
    <tp:flags name="Channel_Password_Flags" type="u" value-prefix="Channel_Password_Flag">
      <tp:flag suffix="Provide" value="8">
        <tp:docstring>
          The <tp:member-ref>ProvidePassword</tp:member-ref> method must be
          called now for the user to join the channel
        </tp:docstring>
      </tp:flag>
    </tp:flags>
    <method name="GetPasswordFlags" tp:name-for-bindings="Get_Password_Flags">
      <arg direction="out" name="Password_Flags" tp:type="Channel_Password_Flags" type="u">
        <tp:docstring>
          An integer with the logical OR of all the flags set
          (values of ChannelPasswordFlags)
        </tp:docstring>
      </arg>
      <tp:docstring>
        Returns the bitwise-OR of the flags relevant to the password on this
        channel.  The user interface can use this to present information about
        which operations are currently valid.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
      </tp:possible-errors>
    </method>
    <signal name="PasswordFlagsChanged" tp:name-for-bindings="Password_Flags_Changed">
      <arg name="Added" tp:type="Channel_Password_Flags" type="u">
        <tp:docstring>
          A bitwise OR of the flags which have been set
        </tp:docstring>
      </arg>
      <arg name="Removed" tp:type="Channel_Password_Flags" type="u">
        <tp:docstring>
          A bitwise OR of the flags which have been cleared
        </tp:docstring>
      </arg>
      <tp:docstring>
        Emitted when the flags as returned by
        <tp:member-ref>GetPasswordFlags</tp:member-ref> are changed.
        The user interface should be updated as appropriate.
      </tp:docstring>
    </signal>
    <method name="ProvidePassword" tp:name-for-bindings="Provide_Password">
      <arg direction="in" name="Password" type="s">
        <tp:docstring>
          The password
        </tp:docstring>
      </arg>
      <arg direction="out" name="Correct" type="b">
        A boolean indicating whether or not the password was correct
      </arg>
      <tp:docstring>
        Provide the password so that the channel can be joined. Must be
        called with the correct password in order for channel joining to
        proceed if the 'provide' password flag is set.
      </tp:docstring>
      <tp:possible-errors>
        <tp:error name="org.freedesktop.Telepathy.Error.Disconnected"/>
        <tp:error name="org.freedesktop.Telepathy.Error.NetworkError"/>
        <tp:error name="org.freedesktop.Telepathy.Error.InvalidArgument"/>
      </tp:possible-errors>
    </method>
    <tp:docstring xmlns="http://www.w3.org/1999/xhtml">
      <p>Interface for channels that may have a password set that users need
    to provide before being able to join, or may be able to view or change
    once they have joined the channel.</p>

    <p>The <tp:member-ref>GetPasswordFlags</tp:member-ref> method and the
    associated <tp:member-ref>PasswordFlagsChanged</tp:member-ref>
    signal indicate whether the channel has a password, whether the user
    must now provide it to join, and whether it can be viewed or changed
    by the user.</p>
    </tp:docstring>
  </interface>
</node>

</tp:spec>
