<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ClientObserverInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>
  </div>
<div class="contents">
<h1>ClientObserverInterface Class Reference</h1><!-- doxytag: class="Tp::Client::ClientObserverInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-client_8h_source.html">TelepathyQt4/Client</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ClientObserverInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#ec9265acf1eb73e9147de89a22217935">ObserveChannels</a> (const QDBusObjectPath &amp;account, const QDBusObjectPath &amp;connection, const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;channels, const QDBusObjectPath &amp;dispatchOperation, const <a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> &amp;requestsSatisfied, const QVariantMap &amp;observerInfo)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#07ef928d07a34ee9fd0c6e45b360c8d2">ClientObserverInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#43cf574526221d929b31df8e71f4b094">ClientObserverInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#5a7f90c61e1eb42f27142f71480b3c18">ClientObserverInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#5b63596cf043f59a3f823f0d8dc23439">ClientObserverInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;mainInterface)
<li><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#e4c85adec93a81e23d650d63e2c40748">ClientObserverInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;mainInterface, QObject *parent)
<li><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#34afd25a60378cc9cd9146bf0205f546">ObserverChannelFilter</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html#2c5266a2b6e3c516cd13b02d216906e2">ObserverChannelFilter</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Observer." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="07ef928d07a34ee9fd0c6e45b360c8d2"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="07ef928d07a34ee9fd0c6e45b360c8d2" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="43cf574526221d929b31df8e71f4b094"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="43cf574526221d929b31df8e71f4b094" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a7f90c61e1eb42f27142f71480b3c18"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="5a7f90c61e1eb42f27142f71480b3c18" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5b63596cf043f59a3f823f0d8dc23439"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="5b63596cf043f59a3f823f0d8dc23439" args="(const Tp::Client::ClientInterface &amp;mainInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a> associated with the same object as the given proxy. Additionally, the created proxy will have the same parent as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e4c85adec93a81e23d650d63e2c40748"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ClientObserverInterface" ref="e4c85adec93a81e23d650d63e2c40748" args="(const Tp::Client::ClientInterface &amp;mainInterface, QObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientObserverInterface.html">ClientObserverInterface</a> associated with the same object as the given proxy. However, a different parent object can be specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.Client.Observer", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="34afd25a60378cc9cd9146bf0205f546"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ObserverChannelFilter" ref="34afd25a60378cc9cd9146bf0205f546" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> ObserverChannelFilter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "ObserverChannelFilter".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec9265acf1eb73e9147de89a22217935"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ObserveChannels" ref="ec9265acf1eb73e9147de89a22217935" args="(const QDBusObjectPath &amp;account, const QDBusObjectPath &amp;connection, const Tp::ChannelDetailsList &amp;channels, const QDBusObjectPath &amp;dispatchOperation, const Tp::ObjectPathList &amp;requestsSatisfied, const QVariantMap &amp;observerInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply ObserveChannels           </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatchOperation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>requestsSatisfied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>observerInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "ObserveChannels" on the remote object.<p>
Called by the channel dispatcher when channels in which the observer has registered an interest are announced in a &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests"&gt;NewChannels&lt;/tp:dbus-ref&gt; signal.<p>
If the same NewChannels signal announces some channels that match the filter, and some that do not, then only a subset of the channels (those that do match the filter) are passed to this method.<p>
If the channel dispatcher will split up the channels from a single NewChannels signal and dispatch them separately (for instance because no installed Handler can handle all of them), it will call ObserveChannels several times.<p>
The observer MUST NOT return from this method call until it is ready for a handler for the channel to run (which may change the channel's state).<p>
&lt;tp:rationale&gt; <p>
The channel dispatcher must wait for observers to start up, to avoid the following race: text channel logger (observer) gets ObserveChannels, text channel handler gets &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler"&gt;HandleChannels&lt;/tp:dbus-ref&gt; channel handler starts up faster and acknowledges messages, logger never sees those messages. &lt;/tp:rationale&gt;<p>
The channel dispatcher SHOULD NOT change its behaviour based on whether this method succeeds or fails: there are no defined D-Bus errors for this method, and if it fails, this only indicates that an Observer is somehow broken.<p>
&lt;tp:rationale&gt; <p>
The expected error response in the channel dispatcher is to log a warning, and otherwise continue as though this method had succeeded. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>account</em>&nbsp;</td><td>The <a class="el" href="classTp_1_1Account.html">Account</a> with which the channels are associated. The well-known bus name to use is that of the <a class="el" href="classTp_1_1AccountManager.html" title="The AccountManager class provides an object representing a Telepathy account manager...">AccountManager</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The <a class="el" href="classTp_1_1Connection.html">Connection</a> with which the channels are associated. The well-known bus name to use can be derived from this object path by removing the leading '/' and replacing all subsequent '/' by '.'.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>The Channels and their properties. Their well-known bus names are all the same as that of the <a class="el" href="classTp_1_1Connection.html">Connection</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dispatchOperation</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
The path to the &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;<a class="el" href="classTp_1_1ChannelDispatchOperation.html">ChannelDispatchOperation</a>&lt;/tp:dbus-ref&gt; for these channels, or the special value '/' if there is no <a class="el" href="classTp_1_1ChannelDispatchOperation.html">ChannelDispatchOperation</a> (because the channels were requested, not incoming).<p>
If the Observer calls &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation"&gt;Claim&lt;/tp:dbus-ref&gt; or &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation"&gt;HandleWith&lt;/tp:dbus-ref&gt; on the dispatch operation, it MUST be careful to avoid deadlock, since these methods cannot return until the Observer has returned from &lt;tp:member-ref&gt;ObserveChannels&lt;/tp:member-ref&gt;.<p>
&lt;tp:rationale&gt; <p>
This allows an Observer to &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation"&gt;Claim&lt;/tp:dbus-ref&gt; a set of channels without having to match up calls to this method with calls to &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Approver"&gt;AddDispatchOperation&lt;/tp:dbus-ref&gt;. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>requestsSatisfied</em>&nbsp;</td><td>The requests satisfied by these channels. If the same process is an Observer and a Handler, it can be useful to be given this information as soon as possible (it will also be passed to Handler.HandleChannels).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>observerInfo</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
Additional information about these channels. No keys are currently defined.<p>
If keys are defined for this dictionary, all will be optional; observers MAY safely ignore any entry in this dictionary. 
</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="2c5266a2b6e3c516cd13b02d216906e2"></a><!-- doxytag: member="Tp::Client::ClientObserverInterface::ObserverChannelFilter" ref="2c5266a2b6e3c516cd13b02d216906e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> ObserverChannelFilter<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "ObserverChannelFilter" on the remote object.<p>
A specification of the channels in which this observer is interested. The &lt;tp:member-ref&gt;ObserveChannels&lt;/tp:member-ref&gt; method should be called by the channel dispatcher whenever any of the new channels in a &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests"&gt;NewChannels&lt;/tp:dbus-ref&gt; signal match this description.<p>
Only certain D-Bus types have useful semantics for matching like this, so only certain types are allowed:<p>
<dl>
<dt>Integers of all sizes, including byte (y, n, q, i, u, x, t) </dt>
<dd>Matched by numeric value, regardless of type (e.g. 42 as a 16-bit signed integer 'n' is considered equal to 42 as a 32-bit unsigned integer 'u')<p>
</dd>
<dt>Booleans (b) </dt>
<dd>Matched by equality in the obvious way; not considered equal to any other type<p>
</dd>
<dt>Strings (s) </dt>
<dd>Matched by equality in the obvious way; not considered equal to any other type<p>
</dd>
<dt>Object paths (o) </dt>
<dd>Matched by equality in the obvious way; not considered equal to any other type<p>
</dd>
</dl>
<p>
This property never changes while the observer process owns its <a class="el" href="namespaceTp_1_1Client.html">Client</a> bus name. For activatable processes, the filter can change due to an upgrade - the channel dispatcher SHOULD observe changes to .client files using a mechanism like inotify.<p>
&lt;tp:rationale&gt; <p>
Not allowing this property to change is a simplification, particularly for activatable processes (we reject the possibility that a process with a .client file, when activated, has a filter that differs from what its .client file said).<p>
If an Observer wants to add extra channels to its list of interests at runtime, it can register an additional <a class="el" href="namespaceTp_1_1Client.html">Client</a> bus name (for instance, the org.freedesktop.Telepathy.Client.Empathy process with unique name :1.42 could additionally register org.freedesktop.Telepathy.Client.Empathy._1_42) with additional filters. To remove those filters, it can release the bus name; it could even re-claim the bus name immediately, with different filters.<p>
The same principle is applied to Approvers and Handlers. &lt;/tp:rationale&gt;<p>
For observers that have a .client file, the channel dispatcher may discover this property from keys of the form <code><em>propertyname</em>/<em>type</em></code>, in groups in the .client file whose name is the name of this interface followed by <code>.ObserverChannelFilter</code>, a space and an ASCII decimal number starting from 0.<p>
Integers in the .client file are encoded in ASCII decimal, booleans are encoded as "true" or "false", and strings are encoded in the usual way for desktop files (including the C-style backslash escapes documented in the Desktop Entry specification).<p>
For instance, a .client file for an observer that is only interested in Text channels, with CONTACT or ROOM handles, that were requested by a local client:<p>
<pre>
 [org.freedesktop.Telepathy.Client]
 Interfaces=org.freedesktop.Telepathy.Client.Observer;</pre><p>
<pre> [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 0]
 org.freedesktop.Telepathy.Channel.Type s=org.freedesktop.Telepathy.Channel.Type.Text
 org.freedesktop.Telepathy.Channel.TargetHandleType u=1
 org.freedesktop.Telepathy.Channel.Requested b=true</pre><p>
<pre> [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 1]
 org.freedesktop.Telepathy.Channel.Type s=org.freedesktop.Telepathy.Channel.Type.Text
 org.freedesktop.Telepathy.Channel.TargetHandleType u=2
 org.freedesktop.Telepathy.Channel.Requested b=true
 </pre> 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
