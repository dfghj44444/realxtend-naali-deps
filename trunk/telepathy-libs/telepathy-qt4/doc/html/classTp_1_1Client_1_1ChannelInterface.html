<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ChannelInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a>
  </div>
<div class="contents">
<h1>ChannelInterface Class Reference<br>
<small>
[<a class="el" href="group__clientchannel.html">Channel proxies</a>]</small>
</h1><!-- doxytag: class="Tp::Client::ChannelInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-channel_8h_source.html">TelepathyQt4/Channel</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ChannelInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#80e97ca00833a32471ef135d0d1c091d">Close</a> ()
<li>QDBusPendingReply&lt; QString &gt; <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#100202692215b9631c8620f1829a293b">GetChannelType</a> ()
<li>QDBusPendingReply&lt; uint, uint &gt; <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#5e841a1b7e9e88262d056b0a51673e92">GetHandle</a> ()
<li>QDBusPendingReply&lt; QStringList &gt; <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#26c2973ffb797ed7628090d1a38d2bf9">GetInterfaces</a> ()
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#3a010b637a1c1718ebb633f55bcbb8ff">Closed</a> ()
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#a958b7a196351273e6e665ad6316cef4">ChannelInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#71eb2975bdb274de5aaba9a5e8fe3c3d">ChannelInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#16bc1e3544a896df8bc1f06753a0a653">ChannelInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#efad9c2f44fe65b26ed6ea409446e86a">ChannelType</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#1e7330854dda747f56ecd5a1afe559a7">Interfaces</a> () const TELEPATHY_GNUC_DEPRECATED
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#e7cd69008d15aa1adc2dc45bf9f94832">TargetHandle</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#1560e41be2a8d919e00f047e5c147ac9">TargetID</a> () const TELEPATHY_GNUC_DEPRECATED
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#58f98ce993139cbbe4fa3acb6cae78c7">TargetHandleType</a> () const TELEPATHY_GNUC_DEPRECATED
<li>bool <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#af7efbac72cf1ced6dae5f33f0f57d45">Requested</a> () const TELEPATHY_GNUC_DEPRECATED
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#353702171507acc369d24836c109e0bb">InitiatorHandle</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#7d6f93cabde5b0a5554306ad3a1cded1">InitiatorID</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#5fb06f0b52f7d2aad8a73e672ac5e4ee">ChannelType</a>
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#ab5c116b609edc59def091bd92e98f14">Interfaces</a>
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#c0cd28bfe5fc523cf523a9e5d74cb2c6">TargetHandle</a>
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#efe35c2e7f98837843bd3375f0d7632c">TargetID</a>
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#125b56e342a39997a425bf2d5d0fb785">TargetHandleType</a>
<li>bool <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#b89cb5e46ac50b4c8fa6b794b523db1f">Requested</a>
<li>uint <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#68885695ce20aadba0a2a639a79cd5bc">InitiatorHandle</a>
<li>QString <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html#25058c41118a2213f52afcf1ce832e5e">InitiatorID</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a958b7a196351273e6e665ad6316cef4"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="a958b7a196351273e6e665ad6316cef4" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="71eb2975bdb274de5aaba9a5e8fe3c3d"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="71eb2975bdb274de5aaba9a5e8fe3c3d" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16bc1e3544a896df8bc1f06753a0a653"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelInterface" ref="16bc1e3544a896df8bc1f06753a0a653" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">ChannelInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ChannelInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.Channel", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efad9c2f44fe65b26ed6ea409446e86a"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelType" ref="efad9c2f44fe65b26ed6ea409446e86a" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ChannelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "ChannelType".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e7330854dda747f56ecd5a1afe559a7"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Interfaces" ref="1e7330854dda747f56ecd5a1afe559a7" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Interfaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Interfaces".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7cd69008d15aa1adc2dc45bf9f94832"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetHandle" ref="e7cd69008d15aa1adc2dc45bf9f94832" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TargetHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "TargetHandle".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1560e41be2a8d919e00f047e5c147ac9"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetID" ref="1560e41be2a8d919e00f047e5c147ac9" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString TargetID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "TargetID".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58f98ce993139cbbe4fa3acb6cae78c7"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetHandleType" ref="58f98ce993139cbbe4fa3acb6cae78c7" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TargetHandleType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "TargetHandleType".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af7efbac72cf1ced6dae5f33f0f57d45"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Requested" ref="af7efbac72cf1ced6dae5f33f0f57d45" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Requested           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Requested".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="353702171507acc369d24836c109e0bb"></a><!-- doxytag: member="Tp::Client::ChannelInterface::InitiatorHandle" ref="353702171507acc369d24836c109e0bb" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint InitiatorHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "InitiatorHandle".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d6f93cabde5b0a5554306ad3a1cded1"></a><!-- doxytag: member="Tp::Client::ChannelInterface::InitiatorID" ref="7d6f93cabde5b0a5554306ad3a1cded1" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString InitiatorID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "InitiatorID".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80e97ca00833a32471ef135d0d1c091d"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Close" ref="80e97ca00833a32471ef135d0d1c091d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "Close" on the remote object.<p>
Request that the channel be closed. This is not the case until the Closed signal has been emitted, and depending on the connection manager this may simply remove you from the channel on the server, rather than causing it to stop existing entirely. Some channels such as contact list channels may not be closed. 
</div>
</div><p>
<a class="anchor" name="100202692215b9631c8620f1829a293b"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetChannelType" ref="100202692215b9631c8620f1829a293b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QString&gt; GetChannelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetChannelType" on the remote object.<p>
Returns the interface name for the type of this channel. Clients SHOULD use the ChannelType property instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The interface name 
</div>
</div><p>
<a class="anchor" name="5e841a1b7e9e88262d056b0a51673e92"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetHandle" ref="5e841a1b7e9e88262d056b0a51673e92" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;uint, uint&gt; GetHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetHandle" on the remote object.<p>
Returns the handle type and number if this channel represents a communication with a particular contact, room or server-stored list, or zero if it is transient and defined only by its contents. Clients SHOULD use the TargetHandle and TargetHandleType properties instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The same as TargetHandleType.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The same as TargetHandle. 
</div>
</div><p>
<a class="anchor" name="26c2973ffb797ed7628090d1a38d2bf9"></a><!-- doxytag: member="Tp::Client::ChannelInterface::GetInterfaces" ref="26c2973ffb797ed7628090d1a38d2bf9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QStringList&gt; GetInterfaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetInterfaces" on the remote object.<p>
Get the optional interfaces implemented by the channel. Clients SHOULD use the Interfaces property instead, falling back to this method only if necessary. The GetAll method lets clients retrieve all properties in one round-trip.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An array of the D-Bus interface names 
</div>
</div><p>
<a class="anchor" name="3a010b637a1c1718ebb633f55bcbb8ff"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Closed" ref="3a010b637a1c1718ebb633f55bcbb8ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Closed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "Closed" on the remote object.<p>
Emitted when the channel has been closed. Method calls on the channel are no longer valid after this signal has been emitted, and the connection manager may then remove the object from the bus at any point. 
</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ChannelInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="5fb06f0b52f7d2aad8a73e672ac5e4ee"></a><!-- doxytag: member="Tp::Client::ChannelInterface::ChannelType" ref="5fb06f0b52f7d2aad8a73e672ac5e4ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ChannelType<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "ChannelType" on the remote object.<p>
The channel's type. This cannot change once the channel has been created.<p>
For compatibility between older connection managers and newer clients, if this is unavailable or is an empty string, clients MUST use the result of calling &lt;tp:member-ref&gt;GetChannelType&lt;/tp:member-ref&gt;.<p>
&lt;tp:rationale&gt; The GetAll method lets clients retrieve all properties in one round-trip, which is desirable. &lt;/tp:rationale&gt;<p>
When requesting a channel, the request MUST specify a channel type, and the request MUST fail if the specified channel type cannot be supplied.<p>
&lt;tp:rationale&gt; Common sense. &lt;/tp:rationale&gt; 
</div>
</div><p>
<a class="anchor" name="ab5c116b609edc59def091bd92e98f14"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Interfaces" ref="ab5c116b609edc59def091bd92e98f14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Interfaces<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Interfaces" on the remote object.<p>
Extra interfaces provided by this channel. This SHOULD NOT include the channel type and the <a class="el" href="classTp_1_1Channel.html">Channel</a> interface itself, and cannot change once the channel has been created.<p>
For compatibility between older connection managers and newer clients, if this is unavailable, or if this is an empty list and &lt;tp:member-ref&gt;ChannelType&lt;/tp:member-ref&gt; is an empty string, clients MUST use the result of calling &lt;tp:member-ref&gt;GetInterfaces&lt;/tp:member-ref&gt; instead. If this is an empty list but ChannelType is non-empty, clients SHOULD NOT call GetInterfaces; this implies that connection managers that implement the ChannelType property MUST also implement the Interfaces property correctly.<p>
&lt;tp:rationale&gt; The GetAll method lets clients retrieve all properties in one round-trip, which is desirable. &lt;/tp:rationale&gt;<p>
When requesting a channel with a particular value for this property, the request must fail without side-effects unless the connection manager expects to be able to provide a channel whose interfaces include at least the interfaces requested. 
</div>
</div><p>
<a class="anchor" name="c0cd28bfe5fc523cf523a9e5d74cb2c6"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetHandle" ref="c0cd28bfe5fc523cf523a9e5d74cb2c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TargetHandle<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "TargetHandle" on the remote object.<p>
The handle (a representation for the identifier) of the contact, chatroom, etc. with which this handle communicates. Its type is given by the &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; property.<p>
This is fixed for the lifetime of the channel, so channels which could potentially be used to communicate with multiple contacts (such as streamed media calls defined by their members, or ad-hoc chatrooms like MSN switchboards) must have TargetHandleType set to Handle_Type_None and TargetHandle set to 0.<p>
Unlike in the telepathy-spec 0.16 API, there is no particular uniqueness guarantee - there can be many channels with the same (channel type, handle type, handle) tuple. This is necessary to support conversation threads in XMPP and SIP, for example.<p>
If this is present in a channel request, it must be nonzero, &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; MUST be present and not Handle_Type_None, and &lt;tp:member-ref&gt;TargetID&lt;/tp:member-ref&gt; MUST NOT be present.<p>
The channel that satisfies the request MUST either:<p>
<ul>
<li>
have the specified TargetHandle property; or </li>
<li>
have &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; = Handle_Type_None, TargetHandle = 0, and be configured such that it could communicate with the specified handle in some other way (e.g. have the requested contact handle in its Group interface) </li>
</ul>

</div>
</div><p>
<a class="anchor" name="efe35c2e7f98837843bd3375f0d7632c"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetID" ref="efe35c2e7f98837843bd3375f0d7632c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString TargetID<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "TargetID" on the remote object.<p>
The string that would result from inspecting the &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt; property (i.e. the identifier in the IM protocol of the contact, room, etc. with which this channel communicates), or the empty string if the TargetHandle is 0.<p>
&lt;tp:rationale&gt; <p>
The presence of this property avoids the following race condition:<p>
<ul>
<li>
New channel C is signalled with target handle T </li>
<li>
<a class="el" href="namespaceTp_1_1Client.html">Client</a> calls &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection"&gt;InspectHandles&lt;/tp:dbus-ref&gt;(CONTACT, [T]) </li>
<li>
<a class="el" href="classTp_1_1Channel.html">Channel</a> C closes, removing the last reference to handle T </li>
<li>
&lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection"&gt;InspectHandles&lt;/tp:dbus-ref&gt;(CONTACT, [T]) returns an error </li>
</ul>
&lt;/tp:rationale&gt;<p>
If this is present in a channel request, &lt;tp:member-ref&gt;TargetHandleType&lt;/tp:member-ref&gt; MUST be present and not Handle_Type_None, and &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt; MUST NOT be present. The request MUST fail with error InvalidHandle, without side-effects, if the requested TargetID would not be accepted by &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection"&gt;RequestHandles&lt;/tp:dbus-ref&gt;.<p>
The returned channel must be related to the handle corresponding to the given identifier, in the same way as if TargetHandle had been part of the request instead.<p>
&lt;tp:rationale&gt; <p>
Requesting channels with a string identifier saves a round-trip (the call to RequestHandles). It also allows the channel dispatcher to accept a channel request for an account that is not yet connected (and thus has no valid handles), bring the account online, and pass on the same parameters to the new connection's CreateChannel method. &lt;/tp:rationale&gt; 
</div>
</div><p>
<a class="anchor" name="125b56e342a39997a425bf2d5d0fb785"></a><!-- doxytag: member="Tp::Client::ChannelInterface::TargetHandleType" ref="125b56e342a39997a425bf2d5d0fb785" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint TargetHandleType<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "TargetHandleType" on the remote object.<p>
The type of &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt;.<p>
If this is omitted from a channel request, connection managers SHOULD treat this as equivalent to Handle_Type_None.<p>
If this is omitted or is Handle_Type_None, &lt;tp:member-ref&gt;TargetHandle&lt;/tp:member-ref&gt; and &lt;tp:member-ref&gt;TargetID&lt;/tp:member-ref&gt; MUST be omitted from the request. 
</div>
</div><p>
<a class="anchor" name="b89cb5e46ac50b4c8fa6b794b523db1f"></a><!-- doxytag: member="Tp::Client::ChannelInterface::Requested" ref="b89cb5e46ac50b4c8fa6b794b523db1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Requested<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Requested" on the remote object.<p>
True if this channel was created in response to a local request, such as a call to &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.RequestChannel&lt;/tp:dbus-ref&gt; or &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.Interface.Requests.CreateChannel&lt;/tp:dbus-ref&gt;.<p>
&lt;tp:rationale&gt; <p>
The idea of this property is to distinguish between "incoming" and "outgoing" channels, in a way that doesn't break down when considering special cases like contact lists that are automatically created on connection to the server, or chatrooms that an IRC proxy/bouncer like irssi-proxy or bip was already in.<p>
The reason we want to make that distinction is that UIs for things that the user explicitly requested should start up automatically, whereas for incoming messages and VoIP calls we should first ask the user whether they want to open the messaging UI or accept the call. &lt;/tp:rationale&gt;<p>
If the channel was not explicitly requested (even if it was created as a side-effect of a call to one of those functions, e.g. because joining a Tube in a MUC context on XMPP implies joining that MUC), then this property is false.<p>
For compatibility with older connection managers, clients SHOULD assume that this property is true if they see a channel announced by the &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.NewChannel&lt;/tp:dbus-ref&gt; signal with the suppress_handler parameter set to true.<p>
&lt;tp:rationale&gt; <p>
In a correct connection manager, the only way to get such a channel is to request it. &lt;/tp:rationale&gt;<p>
Clients MAY additionally assume that this property is false if they see a channel announced by the NewChannel signal with the suppress_handler parameter set to false.<p>
&lt;tp:rationale&gt; <p>
This is more controversial, since it's possible to get that parameter set to false by requesting a channel. However, there's no good reason to do so, and we've deprecated this practice.<p>
In the particular case of the channel dispatcher, the only side-effect of wrongly thinking a channel is unrequested is likely to be that the user has to confirm that they want to use it, so it seems fairly harmless to assume in the channel dispatcher that channels with suppress_handler false are indeed unrequested. &lt;/tp:rationale&gt;<p>
It does not make sense for this property to be in channel requests—it will always be true for channels returned by CreateChannel, and callers of EnsureChannel cannot control whether an existing channel was originally requested locally—so it MUST NOT be accepted. 
</div>
</div><p>
<a class="anchor" name="68885695ce20aadba0a2a639a79cd5bc"></a><!-- doxytag: member="Tp::Client::ChannelInterface::InitiatorHandle" ref="68885695ce20aadba0a2a639a79cd5bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint InitiatorHandle<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "InitiatorHandle" on the remote object.<p>
The contact who initiated the channel. For channels requested by the local user, this MUST be the value of &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.SelfHandle&lt;/tp:dbus-ref&gt; at the time the channel was created (i.e. not a channel-specific handle).<p>
&lt;tp:rationale&gt; <p>
The careful wording about the self-handle is because the Renaming interface can cause the return from Connection.GetSelfHandle to change. It's something of a specification bug that we don't signal this in the <a class="el" href="classTp_1_1Connection.html">Connection</a> interface yet. &lt;/tp:rationale&gt;<p>
For channels requested by a remote user, this MUST be their handle. If unavailable or not applicable, this MUST be 0 (for instance, contact lists are not really initiated by anyone in particular, and it's easy to imagine a protocol where chatroom invitations can be anonymous).<p>
For channels with the &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface"&gt;Group&lt;/tp:dbus-ref&gt; interface, this SHOULD be the same contact who is signalled as the "Actor" causing the self-handle to be placed in the local-pending set.<p>
This SHOULD NOT be a channel-specific handle, if possible.<p>
It does not make sense for this property to be in channel requests - the initiator will always be the local user - so it MUST NOT be accepted. 
</div>
</div><p>
<a class="anchor" name="25058c41118a2213f52afcf1ce832e5e"></a><!-- doxytag: member="Tp::Client::ChannelInterface::InitiatorID" ref="25058c41118a2213f52afcf1ce832e5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString InitiatorID<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "InitiatorID" on the remote object.<p>
The string that would result from inspecting the &lt;tp:member-ref&gt;InitiatorHandle&lt;/tp:member-ref&gt; property (i.e. the initiator's identifier in the IM protocol).<p>
&lt;tp:rationale&gt; <p>
The presence of this property avoids the following race condition:<p>
<ul>
<li>
New StreamedMedia channel C is signalled with initiator handle I </li>
<li>
<a class="el" href="namespaceTp_1_1Client.html">Client</a> calls &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection"&gt;InspectHandles&lt;/tp:dbus-ref&gt;(CONTACT, [I]) </li>
<li>
<a class="el" href="classTp_1_1Channel.html">Channel</a> C closes, removing the last reference to handle I </li>
<li>
&lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection"&gt;InspectHandles&lt;/tp:dbus-ref&gt;(CONTACT, [I]) returns an error </li>
<li>
<a class="el" href="namespaceTp_1_1Client.html">Client</a> can indicate that a call was missed, but not who called! </li>
</ul>
&lt;/tp:rationale&gt;<p>
It does not make sense for this property to be in channel requests - the initiator will always be the local user - so it MUST NOT be accepted. 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
