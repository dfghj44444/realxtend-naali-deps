<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ClientHandlerInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>
  </div>
<div class="contents">
<h1>ClientHandlerInterface Class Reference</h1><!-- doxytag: class="Tp::Client::ClientHandlerInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-client_8h_source.html">TelepathyQt4/Client</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ClientHandlerInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#03ec43993ce18c5f1b50b7bf712dd261">HandleChannels</a> (const QDBusObjectPath &amp;account, const QDBusObjectPath &amp;connection, const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;channels, const <a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> &amp;requestsSatisfied, qulonglong userActionTime, const QVariantMap &amp;handlerInfo)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#1101373443f95d34875a02aa8c23570c">ClientHandlerInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#d6bfab168a207794d7a3deeffceeb558">ClientHandlerInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#de2026d0fbf64862e2cbcb727e3cc42c">ClientHandlerInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#9ae5f75052a8f21c6ad0e65ac1e7e3de">ClientHandlerInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;mainInterface)
<li><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#880052726de6fe0555fd72b7f2b0c2b4">ClientHandlerInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;mainInterface, QObject *parent)
<li><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#1342b578754874b3e3ce50df7216e164">HandlerChannelFilter</a> () const TELEPATHY_GNUC_DEPRECATED
<li>bool <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#bd76d37dd964d53fab125c83fe98cd78">BypassApproval</a> () const TELEPATHY_GNUC_DEPRECATED
<li><a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#e276501f4e9b87af725c79b73d1fdf16">HandledChannels</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#8e6856c967ab818571db9191ad689957">HandlerChannelFilter</a>
<li>bool <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#1c2efd57105abb8ea9fcc6645f72e600">BypassApproval</a>
<li><a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html#534530565d8eb75c4ea14c1b8d465ee2">HandledChannels</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Handler." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1101373443f95d34875a02aa8c23570c"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::ClientHandlerInterface" ref="1101373443f95d34875a02aa8c23570c" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d6bfab168a207794d7a3deeffceeb558"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::ClientHandlerInterface" ref="d6bfab168a207794d7a3deeffceeb558" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de2026d0fbf64862e2cbcb727e3cc42c"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::ClientHandlerInterface" ref="de2026d0fbf64862e2cbcb727e3cc42c" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ae5f75052a8f21c6ad0e65ac1e7e3de"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::ClientHandlerInterface" ref="9ae5f75052a8f21c6ad0e65ac1e7e3de" args="(const Tp::Client::ClientInterface &amp;mainInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a> associated with the same object as the given proxy. Additionally, the created proxy will have the same parent as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="880052726de6fe0555fd72b7f2b0c2b4"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::ClientHandlerInterface" ref="880052726de6fe0555fd72b7f2b0c2b4" args="(const Tp::Client::ClientInterface &amp;mainInterface, QObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ClientInterface.html">Tp::Client::ClientInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ClientHandlerInterface.html">ClientHandlerInterface</a> associated with the same object as the given proxy. However, a different parent object can be specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.Client.Handler", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1342b578754874b3e3ce50df7216e164"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::HandlerChannelFilter" ref="1342b578754874b3e3ce50df7216e164" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> HandlerChannelFilter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "HandlerChannelFilter".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd76d37dd964d53fab125c83fe98cd78"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::BypassApproval" ref="bd76d37dd964d53fab125c83fe98cd78" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BypassApproval           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "BypassApproval".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e276501f4e9b87af725c79b73d1fdf16"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::HandledChannels" ref="e276501f4e9b87af725c79b73d1fdf16" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> HandledChannels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "HandledChannels".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="03ec43993ce18c5f1b50b7bf712dd261"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::HandleChannels" ref="03ec43993ce18c5f1b50b7bf712dd261" args="(const QDBusObjectPath &amp;account, const QDBusObjectPath &amp;connection, const Tp::ChannelDetailsList &amp;channels, const Tp::ObjectPathList &amp;requestsSatisfied, qulonglong userActionTime, const QVariantMap &amp;handlerInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply HandleChannels           </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>account</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>requestsSatisfied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qulonglong&nbsp;</td>
          <td class="paramname"> <em>userActionTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>handlerInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "HandleChannels" on the remote object.<p>
Called by the channel dispatcher when this client should handle these channels, or when this client should present channels that it is already handling to the user (e.g. bring them into the foreground).<p>
&lt;tp:rationale&gt; <p>
Clients are expected to know what channels they're already handling, and which channel object path corresponds to which window or tab. This can easily be done using a hash table keyed by channels' object paths. &lt;/tp:rationale&gt;<p>
This method can raise any D-Bus error. If it does, the handler is assumed to have failed or crashed, and the channel dispatcher MUST recover in an implementation-specific way; it MAY attempt to dispatch the channels to another handler, or close the channels.<p>
If closing the channels, it is RECOMMENDED that the channel dispatcher attempts to close the channels using &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Channel.Close&lt;/tp:dbus-ref&gt;, but resorts to calling &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Channel.Interface.Destroyable.Destroy&lt;/tp:dbus-ref&gt; (if available) or ignoring the channel (if not) if the same handler repeatedly fails to handle channels.<p>
After HandleChannels returns successfully, the client process is considered to be responsible for the channel until it its unique name disappears from the bus.<p>
&lt;tp:rationale&gt; <p>
If a process has multiple <a class="el" href="namespaceTp_1_1Client.html">Client</a> bus names - some temporary and some long-lived - and drops one of the temporary bus names in order to reduce the set of channels that it will handle, any channels that it is already handling should remain unaffected. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>account</em>&nbsp;</td><td>The <a class="el" href="classTp_1_1Account.html">Account</a> with which the channels are associated. The well-known bus name to use is that of the <a class="el" href="classTp_1_1AccountManager.html" title="The AccountManager class provides an object representing a Telepathy account manager...">AccountManager</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The <a class="el" href="classTp_1_1Connection.html">Connection</a> with which the channels are associated. The well-known bus name to use can be derived from this object path by removing the leading '/' and replacing all subsequent '/' by '.'.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>The channels and their immutable properties. Their well-known bus name is the same as that of the <a class="el" href="classTp_1_1Connection.html">Connection</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requestsSatisfied</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
The requests satisfied by these channels.<p>
&lt;tp:rationale&gt; <p>
If the handler implements Requests, this tells it that these channels match previous &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Interface.Requests"&gt;AddRequest&lt;/tp:dbus-ref&gt; calls that it may have received.<p>
There can be more than one, if they were EnsureChannel requests. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>userActionTime</em>&nbsp;</td><td>The time at which user action occurred, or 0 if this channel is to be handled for some reason not involving user action. Handlers SHOULD use this for focus-stealing prevention, if applicable.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlerInfo</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
Additional information about these channels. No keys are currently defined.<p>
If keys are defined for this dictionary, all will be optional; handlers MAY safely ignore any entry in this dictionary. 
</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="8e6856c967ab818571db9191ad689957"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::HandlerChannelFilter" ref="8e6856c967ab818571db9191ad689957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#gf475b807e7631bbca45229a9118afdb3">Tp::ChannelClassList</a> HandlerChannelFilter<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "HandlerChannelFilter" on the remote object.<p>
A specification of the channels that this channel handler can deal with. It will be offered to approvers as a potential channel handler for bundles that contain only suitable channels, or for suitable channels that must be handled separately.<p>
This property works in exactly the same way as the &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Client.Observer.ObserverChannelFilter&lt;/tp:dbus-ref&gt; property. In particular, it cannot change while the handler process continues to own the corresponding <a class="el" href="namespaceTp_1_1Client.html">Client</a> bus name.<p>
In the .client file, it is represented in the same way as ObserverChannelFilter, but the group has the same name as this interface and the keys start with HandlerChannelFilter instead of ObserverChannelFilter. 
</div>
</div><p>
<a class="anchor" name="1c2efd57105abb8ea9fcc6645f72e600"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::BypassApproval" ref="1c2efd57105abb8ea9fcc6645f72e600" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BypassApproval<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "BypassApproval" on the remote object.<p>
If true, channels destined for this handler are automatically handled, without invoking approvers.<p>
&lt;tp:rationale&gt; <p>
The intended usage is to allow a client handling one channel to pick up closely related channels. Suppose a client capable of handling both Text and StreamedMedia, <code>org.freedesktop.Telepathy.Client.Empathy</code>, is handling a StreamedMedia channel. That client can take a second well-known bus name, say <code>org.freedesktop.Telepathy.Client.Empathy._1._42.Bundle1</code>, and configure an object at <code>/org/freedesktop/Telepathy/Client/Empathy/_1/_42/Bundle1</code> with BypassApproval = TRUE, whose &lt;tp:member-ref&gt;HandlerChannelFilter&lt;/tp:member-ref&gt; matches closely related Text channels by their Bundle property. (This is use-case dis5) &lt;/tp:rationale&gt; 
</div>
</div><p>
<a class="anchor" name="534530565d8eb75c4ea14c1b8d465ee2"></a><!-- doxytag: member="Tp::Client::ClientHandlerInterface::HandledChannels" ref="534530565d8eb75c4ea14c1b8d465ee2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTp_1_1ObjectPathList.html">Tp::ObjectPathList</a> HandledChannels<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "HandledChannels" on the remote object.<p>
A list of the channels that this process is currently handling.<p>
There is no change notification.<p>
&lt;tp:rationale&gt; <p>
This property exists for state recovery - it makes it possible for channel handling to survive a ChannelDispatcher crash.<p>
If the channel dispatcher is automatically replaced, the replacement can discover all Handlers by looking for the <a class="el" href="namespaceTp_1_1Client.html">Client</a> well-known bus names, and discover which channels they are currently handling. Once this has been done, all unhandled channels can be re-dispatched, and the only issue visible to the user is that unhandled channels that they have already approved might be sent back to Approvers. &lt;/tp:rationale&gt;<p>
The value of this property SHOULD be the same for all <a class="el" href="namespaceTp_1_1Client.html">Client</a> instances that share a unique bus name, and SHOULD include all channels that are being handled, even if they were conceptually handled by a different <a class="el" href="namespaceTp_1_1Client.html">Client</a> instance.<p>
&lt;tp:rationale&gt; <p>
Otherwise, when a process released a temporary <a class="el" href="namespaceTp_1_1Client.html">Client</a> name, channels that it handled because of that <a class="el" href="namespaceTp_1_1Client.html">Client</a> name would no longer be state-recoverable. &lt;/tp:rationale&gt; 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
