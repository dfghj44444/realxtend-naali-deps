<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ConnectionInterfaceRequestsInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>
  </div>
<div class="contents">
<h1>ConnectionInterfaceRequestsInterface Class Reference<br>
<small>
[<a class="el" href="group__clientconn.html">Connection proxies</a>]</small>
</h1><!-- doxytag: class="Tp::Client::ConnectionInterfaceRequestsInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-connection_8h_source.html">TelepathyQt4/Connection</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply<br class="typebreak">
&lt; QDBusObjectPath, QVariantMap &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#afa522c3c7252501b3b62fd6442d23c1">CreateChannel</a> (const QVariantMap &amp;request)
<li>QDBusPendingReply&lt; bool, <br class="typebreak">
QDBusObjectPath, QVariantMap &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#564fef6a0c2b3adcc2a057685898d772">EnsureChannel</a> (const QVariantMap &amp;request)
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#4b800e431a54e06fa7603d08611543aa">NewChannels</a> (const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;channels)
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#76e8900d636fda5e11be7f448bf1da94">ChannelClosed</a> (const QDBusObjectPath &amp;removed)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#0b73093d09265155713d2a838024bfb7">ConnectionInterfaceRequestsInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#10c45b5e9439ef8d2eb911af7cd24076">ConnectionInterfaceRequestsInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#5ba014dc5e39ac20ae16e97f0b733c12">ConnectionInterfaceRequestsInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#bc36baf28a458193a2542d41bca34030">ConnectionInterfaceRequestsInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">Tp::Client::ConnectionInterface</a> &amp;mainInterface)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#4b668b42c9217699bb847f4acc8d181b">ConnectionInterfaceRequestsInterface</a> (const <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">Tp::Client::ConnectionInterface</a> &amp;mainInterface, QObject *parent)
<li><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#72e0c5674f2c593570987e8e3192f52e">Channels</a> () const TELEPATHY_GNUC_DEPRECATED
<li><a class="el" href="group__list.html#g48668e4e507a0be09a983de8fdd8f514">Tp::RequestableChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#2918031b99b52e5bd851693ce7e5a964">RequestableChannelClasses</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#64b7d01063f3cf0096cb04cb63f8956c">Channels</a>
<li><a class="el" href="group__list.html#g48668e4e507a0be09a983de8fdd8f514">Tp::RequestableChannelClassList</a> <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html#9a1a669483ccd7cc7afa408a13aeecbd">RequestableChannelClasses</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Requests." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0b73093d09265155713d2a838024bfb7"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ConnectionInterfaceRequestsInterface" ref="0b73093d09265155713d2a838024bfb7" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="10c45b5e9439ef8d2eb911af7cd24076"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ConnectionInterfaceRequestsInterface" ref="10c45b5e9439ef8d2eb911af7cd24076" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5ba014dc5e39ac20ae16e97f0b733c12"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ConnectionInterfaceRequestsInterface" ref="5ba014dc5e39ac20ae16e97f0b733c12" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc36baf28a458193a2542d41bca34030"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ConnectionInterfaceRequestsInterface" ref="bc36baf28a458193a2542d41bca34030" args="(const Tp::Client::ConnectionInterface &amp;mainInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">Tp::Client::ConnectionInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a> associated with the same object as the given proxy. Additionally, the created proxy will have the same parent as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4b668b42c9217699bb847f4acc8d181b"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ConnectionInterfaceRequestsInterface" ref="4b668b42c9217699bb847f4acc8d181b" args="(const Tp::Client::ConnectionInterface &amp;mainInterface, QObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">Tp::Client::ConnectionInterface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterfaceRequestsInterface.html">ConnectionInterfaceRequestsInterface</a> associated with the same object as the given proxy. However, a different parent object can be specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Requests", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="72e0c5674f2c593570987e8e3192f52e"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::Channels" ref="72e0c5674f2c593570987e8e3192f52e" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> Channels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Channels".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2918031b99b52e5bd851693ce7e5a964"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::RequestableChannelClasses" ref="2918031b99b52e5bd851693ce7e5a964" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g48668e4e507a0be09a983de8fdd8f514">Tp::RequestableChannelClassList</a> RequestableChannelClasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "RequestableChannelClasses".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="afa522c3c7252501b3b62fd6442d23c1"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::CreateChannel" ref="afa522c3c7252501b3b62fd6442d23c1" args="(const QVariantMap &amp;request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QDBusObjectPath, QVariantMap&gt; CreateChannel           </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "CreateChannel" on the remote object.<p>
Request that an entirely new channel is created.<p>
&lt;tp:rationale&gt; <p>
There is deliberately no flag corresponding to the suppress_handler argument to &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.RequestChannel&lt;/tp:dbus-ref&gt;, because passing a FALSE value for that argument is deprecated. Requests made using this interface always behave as though suppress_handler was TRUE. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
A dictionary containing desirable properties, which MUST include &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel"&gt;ChannelType&lt;/tp:dbus-ref&gt;. Some properties are defined such that only an exact match makes sense, and connection managers MUST NOT satisfy a request with a channel where that property does not match; some properties are defined such that the connection manager MAY treat the request as merely a hint, and make a best-effort attempt to satisfy it. This is documented separately for each property.<p>
If this dictionary contains a property whose semantics are not known to the connection manager, this method MUST fail without side-effects (in particular it must not create a new channel).<p>
&lt;tp:rationale&gt; <p>
This is necessary if we want to be able to invent properties in future that, when used in a request, are hard requirements rather than just hints. A connection manager that did not know the semantics of those properties could incorrectly return a new channel that did not satisfy the requirements. &lt;/tp:rationale&gt;<p>
The connection manager MUST NOT respond successfully, and SHOULD NOT create a new channel or cause any other side-effects, unless it can create a new channel that satisfies the client's requirements.<p>
Properties that will be set by this argument need not have write access after the channel has been created - indeed, it is expected that most will be read-only.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<p>
The <a class="el" href="classTp_1_1Channel.html">Channel</a> object, which MUST NOT be signalled with &lt;tp:member-ref&gt;NewChannels&lt;/tp:member-ref&gt; until after this method returns.<p>
&lt;tp:rationale&gt; <p>
This allows the requester to alter its handling of NewChannels by knowing whether one of the channels satisfied a request it made. &lt;/tp:rationale&gt;<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<p>
Properties of the channel that was produced, equivalent to the properties in &lt;tp:type&gt;Channel_Details&lt;/tp:type&gt;. <a class="el" href="classTp_1_1Connection.html">Connection</a> managers MUST NOT include properties here whose values can change, for the same reasons as in &lt;tp:type&gt;Channel_Details&lt;/tp:type&gt;. 
</div>
</div><p>
<a class="anchor" name="564fef6a0c2b3adcc2a057685898d772"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::EnsureChannel" ref="564fef6a0c2b3adcc2a057685898d772" args="(const QVariantMap &amp;request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;bool, QDBusObjectPath, QVariantMap&gt; EnsureChannel           </td>
          <td>(</td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "EnsureChannel" on the remote object.<p>
Request that channels are ensured to exist.<p>
&lt;tp:rationale&gt; <p>
The connection manager is in the best position to determine which existing channels could satisfy which requests. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
A dictionary containing desirable properties, with the same semantics as the corresponding parameter to &lt;tp:member-ref&gt;CreateChannel&lt;/tp:member-ref&gt;.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<p>
If false, the caller of EnsureChannel MUST assume that some other process is handling this channel; if true, the caller of EnsureChannel SHOULD handle it themselves or delegate it to another client.<p>
If the creation of a channel makes several calls to EnsureChannel (and no other requests) successful, exactly one of those calls MUST return a true value for this argument.<p>
If the creation of a channel makes other requests successful, the value returned for this argument MUST be such that exactly one of the clients making requests ends up responsible for the channel. In particular, if &lt;tp:member-ref&gt;CreateChannel&lt;/tp:member-ref&gt; returns a channel <em>C</em>, any EnsureChannel calls that also return <em>C</em> MUST return a false value for this argument.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The <a class="el" href="classTp_1_1Channel.html">Channel</a> object. If it was created as a result of this method call, it MUST NOT be signalled by NewChannels until after this method returns. This allows the requester to alter its handling of NewChannels by knowing whether one of the channels satisfied a request it made.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
<p>
Properties of the channel that was produced, equivalent to the properties in &lt;tp:type&gt;Channel_Details&lt;/tp:type&gt;. <a class="el" href="classTp_1_1Connection.html">Connection</a> managers MUST NOT include properties here whose values can change, for the same reasons as in &lt;tp:type&gt;Channel_Details&lt;/tp:type&gt;. 
</div>
</div><p>
<a class="anchor" name="4b800e431a54e06fa7603d08611543aa"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::NewChannels" ref="4b800e431a54e06fa7603d08611543aa" args="(const Tp::ChannelDetailsList &amp;channels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewChannels           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>channels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "NewChannels" on the remote object.<p>
New channels have been created. The connection manager SHOULD emit a single signal for any group of closely related channels that are created at the same time, so that the channel dispatcher can try to dispatch them to a handler as a unit.<p>
In particular, if additional channels are created as a side-effect of a call to &lt;tp:member-ref&gt;CreateChannel&lt;/tp:member-ref&gt;, these channels SHOULD appear in the same NewChannels signal as the channel that satisfies the request.<p>
&lt;tp:rationale&gt; <p>
Joining a MUC Tube in XMPP requires joining the corresponding MUC (chatroom), so a &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type"&gt;Text&lt;/tp:dbus-ref&gt; channel can be created as a side-effect. &lt;/tp:rationale&gt;<p>
Every time NewChannels is emitted, it MUST be followed by a &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Connection.NewChannel&lt;/tp:dbus-ref&gt; signal for each channel.<p>
&lt;tp:rationale&gt; <p>
The double signal emission is for the benefit of older Telepathy clients, which won't be listening for NewChannels.<p>
The more informative NewChannels signal comes first so that clients that did not examine the connection to find out whether Requests is supported will see the more informative signal for each channel first, and then ignore the less informative signal because it announces a new channel of which they are already aware. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>The channels and their details. All channels that are signalled together like this MUST have the same Bundle property, which may either refer to an existing bundle, or establish a new bundle. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="76e8900d636fda5e11be7f448bf1da94"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::ChannelClosed" ref="76e8900d636fda5e11be7f448bf1da94" args="(const QDBusObjectPath &amp;removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelClosed           </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>removed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "ChannelClosed" on the remote object.<p>
Emitted when a channel is closed and hence disappears from the Channels property. This is redundant with the Closed signal on the channel itself, but it does provide full change notification for the Channels property.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>removed</em>&nbsp;</td><td>The channel which has been removed from the Channels property </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="64b7d01063f3cf0096cb04cb63f8956c"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::Channels" ref="64b7d01063f3cf0096cb04cb63f8956c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> Channels<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Channels" on the remote object.<p>
A list of all the channels which currently exist on this connection. Change notification is via the NewChannels and ChannelClosed signals. 
</div>
</div><p>
<a class="anchor" name="9a1a669483ccd7cc7afa408a13aeecbd"></a><!-- doxytag: member="Tp::Client::ConnectionInterfaceRequestsInterface::RequestableChannelClasses" ref="9a1a669483ccd7cc7afa408a13aeecbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g48668e4e507a0be09a983de8fdd8f514">Tp::RequestableChannelClassList</a> RequestableChannelClasses<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "RequestableChannelClasses" on the remote object.<p>
The classes of channel that are expected to be available on this connection, i.e. those for which &lt;tp:member-ref&gt;CreateChannel&lt;/tp:member-ref&gt; can reasonably be expected to succeed. User interfaces can use this information to show or hide UI components.<p>
This property cannot change after the connection has gone to state Connection_Status_Connected, so there is no change notification (if the connection has context-dependent capabilities, it SHOULD advertise support for all classes of channel that it might support during its lifetime). Before this state has been reached, the value of this property is undefined.<p>
&lt;tp:rationale&gt; <p>
This is not on an optional interface, because connection managers can always offer some sort of clue about the channel classes they expect to support (at worst, they can announce support for everything for which they have code). &lt;/tp:rationale&gt; 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
