<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: PendingChannel Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="classTp_1_1PendingChannel.html">PendingChannel</a>
  </div>
<div class="contents">
<h1>PendingChannel Class Reference<br>
<small>
[<a class="el" href="group__clientconn.html">Connection proxies</a>]</small>
</h1><!-- doxytag: class="Tp::PendingChannel" --><!-- doxytag: inherits="Tp::PendingOperation" --><code>#include &lt;<a class="el" href="pending-channel_8h_source.html">TelepathyQt4/PendingChannel</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1PendingOperation.html">Tp::PendingOperation</a>.
<p>

<p>
<a href="classTp_1_1PendingChannel-members.html">List of all members.</a><h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1PendingChannel.html#c8d1a52347ef4ec3a061d642b636f33e">~PendingChannel</a> ()
<li><a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> <a class="el" href="classTp_1_1PendingChannel.html#d7dfedd8a11393b66a7b09bf1462d448">connection</a> () const 
<li>bool <a class="el" href="classTp_1_1PendingChannel.html#ca49db5899ff412f3daac36cfe65e6df">yours</a> () const 
<li>const QString &amp; <a class="el" href="classTp_1_1PendingChannel.html#244891e03d060b19af3023aac88ec8de">channelType</a> () const 
<li>uint <a class="el" href="classTp_1_1PendingChannel.html#98ffc001c0632d3c4cdaa81279722a0b">targetHandleType</a> () const 
<li>uint <a class="el" href="classTp_1_1PendingChannel.html#7b3aed3725a40cf7f03792e5faee17d4">targetHandle</a> () const 
<li>QVariantMap <a class="el" href="classTp_1_1PendingChannel.html#24b13e210ff5ffe6fea14d3a36ec36f7">immutableProperties</a> () const 
<li><a class="el" href="classTp_1_1SharedPtr.html">ChannelPtr</a> <a class="el" href="classTp_1_1PendingChannel.html#0f09004fcf60546ef80f897e8fae15d1">channel</a> () const 
<li>QString <a class="el" href="classTp_1_1PendingChannel.html#99ab8975b471ff4587157bab61b08171">objectPath</a> () const 
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class containing the parameters of and the reply to an asynchronous channel request. Instances of this class cannot be constructed directly; the only way to get one is trough <a class="el" href="classTp_1_1Connection.html">Connection</a>. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c8d1a52347ef4ec3a061d642b636f33e"></a><!-- doxytag: member="Tp::PendingChannel::~PendingChannel" ref="c8d1a52347ef4ec3a061d642b636f33e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classTp_1_1PendingChannel.html">PendingChannel</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class destructor. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d7dfedd8a11393b66a7b09bf1462d448"></a><!-- doxytag: member="Tp::PendingChannel::connection" ref="d7dfedd8a11393b66a7b09bf1462d448" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> connection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classTp_1_1Connection.html">Connection</a> object through which the channel request was made.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="classTp_1_1Connection.html">Connection</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca49db5899ff412f3daac36cfe65e6df"></a><!-- doxytag: member="Tp::PendingChannel::yours" ref="ca49db5899ff412f3daac36cfe65e6df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool yours           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether this channel belongs to this process.<p>
If false, the caller MUST assume that some other process is handling this channel; if true, the caller SHOULD handle it themselves or delegate it to another client.<p>
Note that the value is undefined until the operation finishes.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean indicating whether this channel belongs to this process. </dd></dl>

</div>
</div><p>
<a class="anchor" name="244891e03d060b19af3023aac88ec8de"></a><!-- doxytag: member="Tp::PendingChannel::channelType" ref="244891e03d060b19af3023aac88ec8de" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QString &amp; channelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the channel type specified in the channel request.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name of the interface specific to the requested channel type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="98ffc001c0632d3c4cdaa81279722a0b"></a><!-- doxytag: member="Tp::PendingChannel::targetHandleType" ref="98ffc001c0632d3c4cdaa81279722a0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint targetHandleType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the channel request has finished, return the handle type of the resulting channel. Otherwise, return the handle type that was requested.<p>
(One example of a request producing a different target handle type is that on protocols like MSN, one-to-one conversations don't really exist, and if you request a text channel with handle type HandleTypeContact, what you will actually get is a text channel with handle type HandleTypeNone, with the requested contact as a member.)<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The handle type, as specified in <a class="el" href="group__enumtypeconsts.html#g126a76c59a74d758b3d0cdc357315fac">HandleType</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b3aed3725a40cf7f03792e5faee17d4"></a><!-- doxytag: member="Tp::PendingChannel::targetHandle" ref="7b3aed3725a40cf7f03792e5faee17d4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint targetHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the channel request has finished, return the target handle of the resulting channel. Otherwise, return the target handle that was requested (which might be different in some situations - see targetHandleType).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The handle. </dd></dl>

</div>
</div><p>
<a class="anchor" name="24b13e210ff5ffe6fea14d3a36ec36f7"></a><!-- doxytag: member="Tp::PendingChannel::immutableProperties" ref="24b13e210ff5ffe6fea14d3a36ec36f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariantMap immutableProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If this channel request has finished, return the immutable properties of the resulting channel. Otherwise, return an empty map.<p>
The keys and values in this map are defined by the Telepathy D-Bus specification, or by third-party extensions to that specification. These are the properties that cannot change over the lifetime of the channel; they're announced in the result of the request, for efficiency. This map should be passed to the constructor of <a class="el" href="classTp_1_1Channel.html">Channel</a> or its subclasses (such as <a class="el" href="classTp_1_1TextChannel.html">TextChannel</a>).<p>
These properties can also be used to process channels in a way that does not require the creation of a <a class="el" href="classTp_1_1Channel.html">Channel</a> object - for instance, a ChannelDispatcher implementation should be able to classify and process channels based on their immutable properties, without needing to create <a class="el" href="classTp_1_1Channel.html">Channel</a> objects.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A map in which the keys are D-Bus property names and the values are the corresponding values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f09004fcf60546ef80f897e8fae15d1"></a><!-- doxytag: member="Tp::PendingChannel::channel" ref="0f09004fcf60546ef80f897e8fae15d1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1SharedPtr.html">ChannelPtr</a> channel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a shared pointer to a <a class="el" href="classTp_1_1Channel.html">Channel</a> high-level proxy object associated with the remote channel resulting from the channel request. If <a class="el" href="classTp_1_1PendingOperation.html#ac1b70a2ed67ead038c4d3f5ac4d8a81">isValid()</a> returns <code>false</code>, the request has not (at least yet) completed successfully, and a null ChannelPtr will be returned.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Shared pointer to the new <a class="el" href="classTp_1_1Channel.html">Channel</a> object, 0 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="99ab8975b471ff4587157bab61b08171"></a><!-- doxytag: member="Tp::PendingChannel::objectPath" ref="99ab8975b471ff4587157bab61b08171" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString objectPath           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the channel object path or an empty string on error.<p>
This method is useful for creating custom <a class="el" href="classTp_1_1Channel.html">Channel</a> objects, so instead of using <a class="el" href="classTp_1_1PendingChannel.html#0f09004fcf60546ef80f897e8fae15d1">PendingChannel::channel</a>, one could construct a new custom channel with the object path.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classTp_1_1Channel.html">Channel</a> object path. </dd></dl>

</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
