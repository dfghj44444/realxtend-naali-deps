<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ChannelDispatchOperationInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a>
  </div>
<div class="contents">
<h1>ChannelDispatchOperationInterface Class Reference<br>
<small>
[<a class="el" href="group__clientchanneldispatchoperation.html">ChannelDispatchOperation proxies</a>]</small>
</h1><!-- doxytag: class="Tp::Client::ChannelDispatchOperationInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-channel-dispatch-operation_8h_source.html">TelepathyQt4/ChannelDispatchOperation</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ChannelDispatchOperationInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#cbf71d52c4a9749f4140ab4840b8c503">HandleWith</a> (const QString &amp;handler)
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#fc113f43874a77bb1588638b6c8124f3">Claim</a> ()
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#6863d53d07df239ccc3390ce07d56b71">ChannelLost</a> (const QDBusObjectPath &amp;channel, const QString &amp;error, const QString &amp;message)
<li>void <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#729cc359899015c4d42616a4af1d7944">Finished</a> ()
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#40ef5480b8971046f39f1d8fd9fcf05d">ChannelDispatchOperationInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#6039e4f17d15fa1c41299a97dd42db4a">ChannelDispatchOperationInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#d462ba329c0b416b2dfcd99c9c0c831a">ChannelDispatchOperationInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#1e7330854dda747f56ecd5a1afe559a7">Interfaces</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QDBusObjectPath <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#0aee6a681555b16210cba616ce98ddda">Connection</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QDBusObjectPath <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#01f262077ac3ebfc4cdf34b0c5138509">Account</a> () const TELEPATHY_GNUC_DEPRECATED
<li><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#72e0c5674f2c593570987e8e3192f52e">Channels</a> () const TELEPATHY_GNUC_DEPRECATED
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#6a5b0fbb9ac374e3142d226f7099c77f">PossibleHandlers</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#ab5c116b609edc59def091bd92e98f14">Interfaces</a>
<li>QDBusObjectPath <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#16289929cf0d5ebceb17cfdec7f3c81d">Connection</a>
<li>QDBusObjectPath <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#245187852e258b9dbf716c929307c87c">Account</a>
<li><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#64b7d01063f3cf0096cb04cb63f8956c">Channels</a>
<li>QStringList <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html#a92888655a940613f8fe42285e30319a">PossibleHandlers</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.ChannelDispatchOperation." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="40ef5480b8971046f39f1d8fd9fcf05d"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::ChannelDispatchOperationInterface" ref="40ef5480b8971046f39f1d8fd9fcf05d" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6039e4f17d15fa1c41299a97dd42db4a"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::ChannelDispatchOperationInterface" ref="6039e4f17d15fa1c41299a97dd42db4a" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d462ba329c0b416b2dfcd99c9c0c831a"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::ChannelDispatchOperationInterface" ref="d462ba329c0b416b2dfcd99c9c0c831a" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ChannelDispatchOperationInterface.html">ChannelDispatchOperationInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.ChannelDispatchOperation", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e7330854dda747f56ecd5a1afe559a7"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Interfaces" ref="1e7330854dda747f56ecd5a1afe559a7" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Interfaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Interfaces".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0aee6a681555b16210cba616ce98ddda"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Connection" ref="0aee6a681555b16210cba616ce98ddda" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusObjectPath <a class="el" href="classTp_1_1Connection.html">Connection</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Connection".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01f262077ac3ebfc4cdf34b0c5138509"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Account" ref="01f262077ac3ebfc4cdf34b0c5138509" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusObjectPath <a class="el" href="classTp_1_1Account.html">Account</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Account".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="72e0c5674f2c593570987e8e3192f52e"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Channels" ref="72e0c5674f2c593570987e8e3192f52e" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> Channels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "Channels".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a5b0fbb9ac374e3142d226f7099c77f"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::PossibleHandlers" ref="6a5b0fbb9ac374e3142d226f7099c77f" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList PossibleHandlers           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "PossibleHandlers".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbf71d52c4a9749f4140ab4840b8c503"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::HandleWith" ref="cbf71d52c4a9749f4140ab4840b8c503" args="(const QString &amp;handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply HandleWith           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>handler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "HandleWith" on the remote object.<p>
Called by an approver to accept a channel bundle and request that the given handler be used to handle it.<p>
If successful, this method will cause the <a class="el" href="classTp_1_1ChannelDispatchOperation.html">ChannelDispatchOperation</a> object to disappear, emitting &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;.<p>
However, this method may fail because the dispatch has already been completed and the object has already gone. If this occurs, it indicates that another approver has asked for the bundle to be handled by a particular handler. The approver MUST NOT attempt to interact with the channels further in this case, unless it is separately invoked as the handler.<p>
Approvers which are also channel handlers SHOULD use &lt;tp:member-ref&gt;Claim&lt;/tp:member-ref&gt; instead of HandleWith to request that they can handle a channel bundle themselves.<p>
(FIXME: list some possible errors)<p>
If the channel handler raises an error from &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler"&gt;HandleChannels&lt;/tp:dbus-ref&gt;, this method MAY respond by raising that same error, even if it is not specifically documented here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
The well-known bus name (starting with <code>org.freedesktop.Telepathy.Client.</code>) of the channel handler that should handle the channel, or the empty string if the client has no preferred channel handler. 
</div>
</div><p>
<a class="anchor" name="fc113f43874a77bb1588638b6c8124f3"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Claim" ref="fc113f43874a77bb1588638b6c8124f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Claim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "Claim" on the remote object.<p>
Called by an approver to claim channels for handling internally. If this method is called successfully, the process calling this method becomes the handler for the channel, but <em>does not</em> have the &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler"&gt;HandleChannels&lt;/tp:dbus-ref&gt; method called on it.<p>
Clients that call Claim on channels but do not immediately close them SHOULD implement the Handler interface and its &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler"&gt;HandledChannels&lt;/tp:dbus-ref&gt; property.<p>
Approvers wishing to reject channels MUST call this method to claim ownership of them, and MUST NOT call &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel"&gt;Close&lt;/tp:dbus-ref&gt; on the channels unless/until this method returns successfully.<p>
&lt;tp:rationale&gt; <p>
The channel dispatcher can't know how best to close arbitrary channel types, so it leaves it up to the approver to do so. For instance, for Text channels it is necessary to acknowledge any messages that have already been displayed to the user first - ideally, the approver would display and then acknowledge the messages - or to call &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;Channel.Interface.Destroyable.Destroy&lt;/tp:dbus-ref&gt; if the destructive behaviour of that method is desired.<p>
Similarly, an Approver for StreamedMedia channels can close the channel with a reason (e.g. "busy") if desired. The channel dispatcher, which is designed to have no specific knowledge of particular channel types, can't do that. &lt;/tp:rationale&gt;<p>
If successful, this method will cause the <a class="el" href="classTp_1_1ChannelDispatchOperation.html">ChannelDispatchOperation</a> object to disappear, emitting &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;, in the same way as for &lt;tp:member-ref&gt;HandleWith&lt;/tp:member-ref&gt;.<p>
This method may fail because the dispatch operation has already been completed. Again, see HandleWith for more details. The approver MUST NOT attempt to interact with the channels further in this case.<p>
(FIXME: list some other possible errors) 
</div>
</div><p>
<a class="anchor" name="6863d53d07df239ccc3390ce07d56b71"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::ChannelLost" ref="6863d53d07df239ccc3390ce07d56b71" args="(const QDBusObjectPath &amp;channel, const QString &amp;error, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChannelLost           </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "ChannelLost" on the remote object.<p>
A channel has closed before it could be claimed or handled. If this is emitted for the last remaining channel in a channel dispatch operation, it MUST immediately be followed by &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;.<p>
This signal MUST NOT be emitted until all Approvers that were invoked have returned (successfully or with an error) from their &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Approver"&gt;AddDispatchOperation&lt;/tp:dbus-ref&gt; method.<p>
&lt;tp:rationale&gt; <p>
This means that Approvers can connect to the ChannelLost signal in a race-free way. Non-approver processes that discover a channel dispatch operation in some way (such as observers) will have to follow the usual "connect to signals then recover state" model - first connect to ChannelLost and &lt;tp:member-ref&gt;Finished&lt;/tp:member-ref&gt;, then download &lt;tp:member-ref&gt;Channels&lt;/tp:member-ref&gt; (and on error, perhaps assume that the operation has already Finished). &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The <a class="el" href="classTp_1_1Channel.html">Channel</a> that closed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
The name of a D-Bus error indicating why the channel closed. If no better reason can be found, <code>org.freedesktop.Telepathy.Error.NotAvailable</code> MAY be used as a fallback; this means that this error SHOULD NOT be given any more specific meaning.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A string associated with the D-Bus error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="729cc359899015c4d42616a4af1d7944"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Finished" ref="729cc359899015c4d42616a4af1d7944" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Finished           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "Finished" on the remote object.<p>
Emitted when this dispatch operation finishes. The dispatch operation is no longer present and further methods must not be called on it.<p>
Approvers that have a user interface SHOULD stop notifying the user about the channels in response to this signal; they MAY assume that on errors, they would have received &lt;tp:member-ref&gt;ChannelLost&lt;/tp:member-ref&gt; first.<p>
Its object path SHOULD NOT be reused for a subsequent dispatch operation; the ChannelDispatcher MUST choose object paths in a way that avoids immediate re-use.<p>
&lt;tp:rationale&gt; <p>
Otherwise, clients might accidentally call &lt;tp:member-ref&gt;HandleWith&lt;/tp:member-ref&gt; or &lt;tp:member-ref&gt;Claim&lt;/tp:member-ref&gt; on a new dispatch operation instead of the one they intended to handle. &lt;/tp:rationale&gt;<p>
This signal MUST NOT be emitted until all Approvers that were invoked have returned (successfully or with an error) from their &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Approver"&gt;AddDispatchOperation&lt;/tp:dbus-ref&gt; method.<p>
&lt;tp:rationale&gt; <p>
This means that Approvers can connect to the ChannelLost signal in a race-free way. Non-approver processes that discover a channel dispatch operation in some way (such as observers) will have to follow the usual "connect to signals then recover state" model - first connect to &lt;tp:member-ref&gt;ChannelLost&lt;/tp:member-ref&gt; and Finished, then download &lt;tp:member-ref&gt;Channels&lt;/tp:member-ref&gt; (and on error, perhaps assume that the operation has already Finished). &lt;/tp:rationale&gt; 
</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="ab5c116b609edc59def091bd92e98f14"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Interfaces" ref="ab5c116b609edc59def091bd92e98f14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList Interfaces<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Interfaces" on the remote object.<p>
A list of the extra interfaces provided by this channel dispatch operation. This property cannot change. 
</div>
</div><p>
<a class="anchor" name="16289929cf0d5ebceb17cfdec7f3c81d"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Connection" ref="16289929cf0d5ebceb17cfdec7f3c81d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusObjectPath <a class="el" href="classTp_1_1Connection.html">Connection</a><code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Connection" on the remote object.<p>
The <a class="el" href="classTp_1_1Connection.html">Connection</a> with which the Channels are associated. The well-known bus name to use can be derived from this object path by removing the leading '/' and replacing all subsequent '/' by '.'. This property cannot change. 
</div>
</div><p>
<a class="anchor" name="245187852e258b9dbf716c929307c87c"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Account" ref="245187852e258b9dbf716c929307c87c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusObjectPath <a class="el" href="classTp_1_1Account.html">Account</a><code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Account" on the remote object.<p>
The <a class="el" href="classTp_1_1Account.html">Account</a> with which the <a class="el" href="classTp_1_1Connection.html">Connection</a> and Channels are associated. This property cannot change. 
</div>
</div><p>
<a class="anchor" name="64b7d01063f3cf0096cb04cb63f8956c"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::Channels" ref="64b7d01063f3cf0096cb04cb63f8956c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__list.html#g75775051e01274f75ceeb330b4647e3a">Tp::ChannelDetailsList</a> Channels<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "Channels" on the remote object.<p>
The Channels to be dispatched, and their properties. Change notification is via the ChannelLost signal (channels cannot be added to this property, only removed). 
</div>
</div><p>
<a class="anchor" name="a92888655a940613f8fe42285e30319a"></a><!-- doxytag: member="Tp::Client::ChannelDispatchOperationInterface::PossibleHandlers" ref="a92888655a940613f8fe42285e30319a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList PossibleHandlers<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "PossibleHandlers" on the remote object.<p>
The well known bus names (starting with org.freedesktop.Telepathy.Client.) of the possible Handlers for these channels. The channel dispatcher MUST place the most preferred handlers first, according to some reasonable heuristic. As a result, approvers SHOULD use the first handler by default. The heuristic used to prioritize handlers SHOULD give a higher priority to handlers that are already running. If, for instance, Empathy and Kopete have similar functionality, and Empathy is running, we should prefer to send channels to it rather than launching Kopete via service activation. 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
