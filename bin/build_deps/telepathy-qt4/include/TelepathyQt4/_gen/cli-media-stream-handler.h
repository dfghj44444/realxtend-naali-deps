/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef IN_TELEPATHY_QT4_HEADER
#error IN_TELEPATHY_QT4_HEADER
#endif

#include <TelepathyQt4/Types>

#include <QtGlobal>

#include <QString>
#include <QObject>
#include <QVariant>

#include <QDBusPendingReply>

#include <TelepathyQt4/AbstractInterface>
#include <TelepathyQt4/DBusProxy>

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
namespace Client
{

/**
 * \class MediaStreamHandlerInterface
 * \headerfile TelepathyQt4/media-stream-handler.h <TelepathyQt4/MediaStreamHandler>
 * \ingroup clientmstrh
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Media.StreamHandler."
 */
class MediaStreamHandlerInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Media.StreamHandler", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Media.StreamHandler";
    }

    /**
     * Creates a MediaStreamHandlerInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    MediaStreamHandlerInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a MediaStreamHandlerInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    MediaStreamHandlerInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a MediaStreamHandlerInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    MediaStreamHandlerInterface(Tp::DBusProxy *proxy);

    /**
     * Represents property "STUNServers" on the remote object.
     * 
     * The IP addresses of possible STUN servers to use for NAT traversal, as 
     * dotted-quad IPv4 address literals or RFC2373 IPv6 address literals. 
     * This property cannot change once the stream has been created, so there 
     * is no change notification. The IP addresses MUST NOT be given as DNS 
     * hostnames. High-quality connection managers already need an 
     * asynchronous DNS resolver, so they might as well resolve this name to 
     * an IP to make life easier for streaming implementations.
     */
    Q_PROPERTY(Tp::SocketAddressIPList STUNServers READ STUNServers)

    /**
     * Getter for the remote object property "STUNServers".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SocketAddressIPList STUNServers() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SocketAddressIPList>(internalPropGet("STUNServers"));
    }

    /**
     * Represents property "CreatedLocally" on the remote object.
     * 
     * True if we were the creator of this stream, false otherwise. This 
     * information is needed for some nat traversal mechanisms, such as 
     * ICE-UDP, where the creator gets the role of the controlling agent.
     */
    Q_PROPERTY(bool CreatedLocally READ CreatedLocally)

    /**
     * Getter for the remote object property "CreatedLocally".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool CreatedLocally() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("CreatedLocally"));
    }

    /**
     * Represents property "NATTraversal" on the remote object.
     * 
     * <p>The transport (NAT traversal technique) to be used for this
     *   stream. Well-known values include:</p>
     * 
     * <dl>
     *   <dt>none</dt>
     *   <dd>Raw UDP, with or without STUN, should be used. If the
     *     <tp:member-ref>STUNServers</tp:member-ref> property is non-empty,
     *     STUN SHOULD be used.</dd>
     * 
     *   <dt>stun</dt>
     *   <dd>A deprecated synonym for 'none'.</dd>
     * 
     *   <dt>gtalk-p2p</dt>
     *   <dd>Google Talk peer-to-peer connectivity establishment should be
     *     used, as implemented in libjingle 0.3.</dd>
     * 
     *   <dt>ice-udp</dt>
     *   <dd>Interactive Connectivity Establishment should be used,
     *     as defined by the IETF MMUSIC working group.</dd>
     * 
     *   <dt>wlm-8.5</dt>
     *   <dd>The transport used by Windows Live Messenger 8.5 or later,
     *     which resembles ICE draft 6, should be used.</dd>
     * 
     *   <dt>wlm-2009</dt>
     *   <dd>The transport used by Windows Live Messenger 2009 or later,
     *     which resembles ICE draft 19, should be used.</dd>
     * </dl>
     * 
     * <p>This property cannot change once the stream has been created, so
     *   there is no change notification.</p>
     */
    Q_PROPERTY(QString NATTraversal READ NATTraversal)

    /**
     * Getter for the remote object property "NATTraversal".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString NATTraversal() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("NATTraversal"));
    }

    /**
     * Represents property "RelayInfo" on the remote object.
     * 
     * <p>A list of mappings describing TURN or Google relay servers
     *   available for the client to use in its candidate gathering, as
     *   determined from the protocol. Map keys are:</p>
     * 
     * <dl>
     *   <dt><code>ip</code> - s</dt>
     *   <dd>The IP address of the relay server as a dotted-quad IPv4
     *     address literal or an RFC2373 IPv6 address literal. This MUST NOT
     *     be a DNS hostname.
     * 
     *     <tp:rationale>
     *       High-quality connection managers already need an asynchronous
     *       DNS resolver, so they might as well resolve this name to an IP
     *       and make life easier for streaming implementations.
     *     </tp:rationale>
     *   </dd>
     * 
     *   <dt><code>type</code> - s</dt>
     *   <dd>
     *     <p>Either <code>udp</code> for UDP (UDP MUST be assumed if this
     *       key is omitted), <code>tcp</code> for TCP, or
     *       <code>tls</code>.</p>
     * 
     *     <p>The precise meaning of this key depends on the
     *       <tp:member-ref>NATTraversal</tp:member-ref> property: if
     *       NATTraversal is <code>ice-udp</code>, <code>tls</code> means
     *       TLS over TCP as referenced by ICE draft 19, and if
     *       NATTraversal is <code>gtalk-p2p</code>, <code>tls</code> means
     *       a fake SSL session over TCP as implemented by libjingle.</p>
     *   </dd>
     * 
     *   <dt><code>port</code> - q</dt>
     *   <dd>The UDP or TCP port of the relay server as an ASCII unsigned
     *     integer</dd>
     * 
     *   <dt><code>username</code> - s</dt>
     *   <dd>The username to use</dd>
     * 
     *   <dt><code>password</code> - s</dt>
     *   <dd>The password to use</dd>
     * 
     *   <dt><code>component</code> - u</dt>
     *   <dd>The component number to use this relay server for, as an
     *     ASCII unsigned integer; if not included, this relay server
     *     may be used for any or all components.
     * 
     *     <tp:rationale>
     *       In ICE draft 6, as used by Google Talk, credentials are only
     *       valid once, so each component needs relaying separately.
     *     </tp:rationale>
     *   </dd>
     * </dl>
     * 
     * <tp:rationale>
     *   <p>An equivalent of the gtalk-p2p-relay-token property on
     *     MediaSignalling channels is not included here. The connection
     *     manager should be responsible for making the necessary HTTP
     *     requests to turn the token into a username and password.</p>
     * </tp:rationale>
     * 
     * <p>The type of relay server that this represents depends on
     *   the value of the <tp:member-ref>NATTraversal</tp:member-ref>
     *   property. If NATTraversal is ice-udp, this is a TURN server;
     *   if NATTraversal is gtalk-p2p, this is a Google relay server;
     *   otherwise, the meaning of RelayInfo is undefined.</p>
     * 
     * <p>If relaying is not possible for this stream, the list is empty.</p>
     * 
     * <p>This property cannot change once the stream has been created, so
     *   there is no change notification.</p>
     */
    Q_PROPERTY(Tp::StringVariantMapList RelayInfo READ RelayInfo)

    /**
     * Getter for the remote object property "RelayInfo".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::StringVariantMapList RelayInfo() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::StringVariantMapList>(internalPropGet("RelayInfo"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "CodecChoice" on the remote object.
     * 
     * Inform the connection manager of codec used to receive data.
     */
    inline QDBusPendingReply<> CodecChoice(uint codecID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(codecID);
        return asyncCallWithArgumentList(QLatin1String("CodecChoice"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "Error" on the remote object.
     * 
     * Inform the connection manager that an error occured in this stream. The 
     * connection manager should emit the StreamError signal for the stream on 
     * the relevant channel, and remove the stream from the session.
     *
     * \param errorCode
     *     
     *     ID of error, from the MediaStreamError enumeration
     *
     * \param message
     *     
     *     String describing the error
     */
    inline QDBusPendingReply<> Error(uint errorCode, const QString& message)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(errorCode) << QVariant::fromValue(message);
        return asyncCallWithArgumentList(QLatin1String("Error"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "NativeCandidatesPrepared" on the remote object.
     * 
     * Informs the connection manager that all possible native candisates have 
     * been discovered for the moment.
     */
    inline QDBusPendingReply<> NativeCandidatesPrepared()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("NativeCandidatesPrepared"));
    }

    /**
     * Begins a call to the D-Bus method "NewActiveCandidatePair" on the remote object.
     * 
     * Informs the connection manager that a valid candidate pair has been 
     * discovered and streaming is in progress.
     */
    inline QDBusPendingReply<> NewActiveCandidatePair(const QString& nativeCandidateID, const QString& remoteCandidateID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(nativeCandidateID) << QVariant::fromValue(remoteCandidateID);
        return asyncCallWithArgumentList(QLatin1String("NewActiveCandidatePair"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "NewNativeCandidate" on the remote object.
     * 
     * Inform this MediaStreamHandler that a new native transport candidate 
     * has been ascertained.
     *
     * \param candidateID
     *     
     *     String identifier for this candidate
     *
     * \param transports
     *     
     *     Array of transports for this candidate, with fields:
     *     <ul>
     *       <li>component number</li>
     *       <li>IP address (as a string)</li>
     *       <li>port</li>
     *       <li>base network protocol (one of the values of MediaStreamBaseProto)</li>
     *       <li>proto subtype (e.g. RTP)</li>
     *       <li>proto profile (e.g. AVP)</li>
     *       <li>our preference value of this transport (double in range 0.0-1.0
     *         inclusive); 1 signals the most preferred transport</li>
     *       <li>transport type, one of the values of MediaStreamTransportType</li>
     *       <li>username if authentication is required</li>
     *       <li>password if authentication is required</li>
     *     </ul>
     */
    inline QDBusPendingReply<> NewNativeCandidate(const QString& candidateID, const Tp::MediaStreamHandlerTransportList& transports)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(candidateID) << QVariant::fromValue(transports);
        return asyncCallWithArgumentList(QLatin1String("NewNativeCandidate"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "Ready" on the remote object.
     * 
     * Inform the connection manager that a client is ready to handle this 
     * StreamHandler. Also provide it with info about all supported codecs.
     *
     * \param codecs
     *     
     *     Locally-supported codecs.
     */
    inline QDBusPendingReply<> Ready(const Tp::MediaStreamHandlerCodecList& codecs)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(codecs);
        return asyncCallWithArgumentList(QLatin1String("Ready"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetLocalCodecs" on the remote object.
     * 
     * <p>Used to provide codecs after Ready(), so the media client can go
     *   ready for an incoming call and exchange candidates/codecs before
     *   knowing what local codecs are available.</p>
     * 
     * <p>This is useful for gatewaying calls between two connection managers.
     *   Given an incoming call, you need to call
     *   <tp:member-ref>Ready</tp:member-ref> to get the remote codecs before
     *   you can use them as the &quot;local&quot; codecs to place the outgoing call,
     *   and hence receive the outgoing call's remote codecs to use as the
     *   incoming call's &quot;local&quot; codecs.</p>
     * 
     * <p>In this situation, you would pass an empty list of codecs to the
     *   incoming call's Ready method, then later call SetLocalCodecs on the
     *   incoming call in order to respond to the offer.</p>
     *
     * \param codecs
     *     
     *     Locally-supported codecs
     */
    inline QDBusPendingReply<> SetLocalCodecs(const Tp::MediaStreamHandlerCodecList& codecs)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(codecs);
        return asyncCallWithArgumentList(QLatin1String("SetLocalCodecs"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "StreamState" on the remote object.
     * 
     * Informs the connection manager of the stream&apos;s current state, as 
     * as specified in Channel.Type.StreamedMedia::ListStreams.
     */
    inline QDBusPendingReply<> StreamState(uint state)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(state);
        return asyncCallWithArgumentList(QLatin1String("StreamState"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SupportedCodecs" on the remote object.
     * 
     * Inform the connection manager of the supported codecs for this session. 
     * This is called after the connection manager has emitted SetRemoteCodecs 
     * to notify what codecs are supported by the peer, and will thus be an 
     * intersection of all locally supported codecs (passed to Ready) and 
     * those supported by the peer.
     *
     * \param codecs
     *     
     *     Locally supported codecs.
     */
    inline QDBusPendingReply<> SupportedCodecs(const Tp::MediaStreamHandlerCodecList& codecs)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(codecs);
        return asyncCallWithArgumentList(QLatin1String("SupportedCodecs"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "CodecsUpdated" on the remote object.
     * 
     * Inform the connection manager that the parameters of the supported 
     * codecs for this session have changed. The connection manager should 
     * send the new parameters to the remote contact. This is required for 
     * H.264 and Theora, for example.
     *
     * \param codecs
     *     
     *     Locally supported codecs, which SHOULD be the same as were 
     *     previously in effect, but possibly with different parameters.
     */
    inline QDBusPendingReply<> CodecsUpdated(const Tp::MediaStreamHandlerCodecList& codecs)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(codecs);
        return asyncCallWithArgumentList(QLatin1String("CodecsUpdated"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "HoldState" on the remote object.
     * 
     * Notify the connection manager that the stream&apos;s hold state has 
     * been changed successfully in response to SetStreamHeld.
     *
     * \param held
     *     
     *     If true, the stream is now on hold.
     */
    inline QDBusPendingReply<> HoldState(bool held)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(held);
        return asyncCallWithArgumentList(QLatin1String("HoldState"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "UnholdFailure" on the remote object.
     * 
     * Notify the connection manager that an attempt to reacquire the 
     * necessary hardware or software resources to unhold the stream, in 
     * response to SetStreamHeld, has failed.
     */
    inline QDBusPendingReply<> UnholdFailure()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("UnholdFailure"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "AddRemoteCandidate" on the remote object.
     * 
     * Signal emitted when the connection manager wishes to inform the client 
     * of a new remote candidate.
     *
     * \param candidateID
     *     
     *     String identifier for this candidate
     *
     * \param transports
     *     
     *     Array of transports for this candidate with fields, as defined in 
     *     NewNativeCandidate
     */
    void AddRemoteCandidate(const QString& candidateID, const Tp::MediaStreamHandlerTransportList& transports);

    /**
     * Represents the signal "Close" on the remote object.
     * 
     * Signal emitted when the connection manager wishes the stream to be 
     * closed.
     */
    void Close();

    /**
     * Represents the signal "RemoveRemoteCandidate" on the remote object.
     * 
     * Signal emitted when the connection manager wishes to inform the client 
     * that the remote end has removed a previously usable candidate. It 
     * seemed like a good idea at the time, but wasn&apos;t.
     *
     * \param candidateID
     *     
     *     String identifier for remote candidate to drop
     */
    void RemoveRemoteCandidate(const QString& candidateID);

    /**
     * Represents the signal "SetActiveCandidatePair" on the remote object.
     * 
     * Emitted by the connection manager to inform the client that a valid 
     * candidate pair has been discovered by the remote end and streaming is 
     * in progress.
     */
    void SetActiveCandidatePair(const QString& nativeCandidateID, const QString& remoteCandidateID);

    /**
     * Represents the signal "SetRemoteCandidateList" on the remote object.
     * 
     * Signal emitted when the connection manager wishes to inform the client 
     * of all the available remote candidates at once.
     *
     * \param remoteCandidates
     *     
     *     A list of candidate id and a list of transports as defined in 
     *     NewNativeCandidate
     */
    void SetRemoteCandidateList(const Tp::MediaStreamHandlerCandidateList& remoteCandidates);

    /**
     * Represents the signal "SetRemoteCodecs" on the remote object.
     * 
     * Signal emitted when the connection manager wishes to inform the client 
     * of the codecs supported by the remote end. 	If these codecs are 
     * compatible with the remote codecs, then the client must call 
     * SupportedCodecs, otherwise call Error.
     *
     * \param codecs
     *     
     *     Codecs supported by the remote peer.
     */
    void SetRemoteCodecs(const Tp::MediaStreamHandlerCodecList& codecs);

    /**
     * Represents the signal "SetStreamPlaying" on the remote object.
     * 
     * If emitted with argument TRUE, this means that the connection manager 
     * wishes to set the stream playing; this means that the streaming 
     * implementation should expect to receive data. If emitted with argument 
     * FALSE this signal is basically meaningless and should be ignored. 
     * We&apos;re very sorry.
     */
    void SetStreamPlaying(bool playing);

    /**
     * Represents the signal "SetStreamSending" on the remote object.
     * 
     * Signal emitted when the connection manager wishes to set whether or not 
     * the stream sends to the remote end.
     */
    void SetStreamSending(bool sending);

    /**
     * Represents the signal "StartTelephonyEvent" on the remote object.
     * 
     * Request that a telephony event (as defined by RFC 4733) is transmitted 
     * over this stream until StopTelephonyEvent is called.
     *
     * \param event
     *     
     *     A telephony event code as defined by RFC 4733.
     */
    void StartTelephonyEvent(uchar event);

    /**
     * Represents the signal "StopTelephonyEvent" on the remote object.
     * 
     * Request that any ongoing telephony events (as defined by RFC 4733) 
     * being transmitted over this stream are stopped.
     */
    void StopTelephonyEvent();

    /**
     * Represents the signal "SetStreamHeld" on the remote object.
     * 
     * <p>Emitted when the connection manager wishes to place the stream on
     *   hold (so the streaming client should free hardware or software
     *   resources) or take the stream off hold (so the streaming client
     *   should reacquire the necessary resources).</p>
     * 
     * <p>When placing a channel's streams on hold, the connection manager
     *   SHOULD notify the remote contact that this will be done (if
     *   appropriate in the protocol) before it emits this signal.</p>
     * 
     * <tp:rationale>
     *   <p>It is assumed that relinquishing a resource will not fail.
     *     If it does, the call is probably doomed anyway.</p>
     * </tp:rationale>
     * 
     * <p>When unholding a channel's streams, the connection manager
     *   SHOULD emit this signal and wait for success to be indicated
     *   via HoldState before it notifies the remote contact that the
     *   channel has been taken off hold.</p>
     * 
     * <tp:rationale>
     *   <p>This means that if a resource is unavailable, the remote
     *     contact will never even be told that we tried to acquire it.</p>
     * </tp:rationale>
     *
     * \param held
     *     
     *     If true, the stream is to be placed on hold.
     */
    void SetStreamHeld(bool held);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};
}
}
