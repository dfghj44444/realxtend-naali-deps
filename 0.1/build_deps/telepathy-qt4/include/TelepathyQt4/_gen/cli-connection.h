/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef IN_TELEPATHY_QT4_HEADER
#error IN_TELEPATHY_QT4_HEADER
#endif

#include <TelepathyQt4/Types>

#include <QtGlobal>

#include <QString>
#include <QObject>
#include <QVariant>

#include <QDBusPendingReply>

#include <TelepathyQt4/AbstractInterface>
#include <TelepathyQt4/DBusProxy>

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
namespace Client
{

/**
 * \class ConnectionInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection."
 */
class ConnectionInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection";
    }

    /**
     * Creates a ConnectionInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterface(Tp::DBusProxy *proxy);

    /**
     * Represents property "SelfHandle" on the remote object.
     * 
     * The handle which represents the user on this connection, which will 
     * remain valid for the lifetime of this connection, or until a change in 
     * the user&apos;s identifier is signalled by the SelfHandleChanged 
     * signal. If the connection is not yet in the CONNECTED state, the value 
     * of this property MAY be zero.
     */
    Q_PROPERTY(uint SelfHandle READ SelfHandle)

    /**
     * Getter for the remote object property "SelfHandle".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint SelfHandle() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("SelfHandle"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "Connect" on the remote object.
     * 
     * <p>Request that the connection be established. This will be done
     *   asynchronously and errors will be returned by emitting
     *   <tp:member-ref>StatusChanged</tp:member-ref> signals.</p>
     * 
     * <p>Calling this method on a Connection that is already connecting
     *   or connected is allowed, and has no effect.</p>
     */
    inline QDBusPendingReply<> Connect()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Connect"));
    }

    /**
     * Begins a call to the D-Bus method "Disconnect" on the remote object.
     * 
     * Request that the connection be closed. This closes the connection if 
     * it&apos;s not already in DISCONNECTED state, and destroys the 
     * connection object.
     */
    inline QDBusPendingReply<> Disconnect()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Disconnect"));
    }

    /**
     * Begins a call to the D-Bus method "GetInterfaces" on the remote object.
     * 
     * <p>Get the optional interfaces supported by this connection.
     *   Before the connection status changes to CONNECTED, the return
     *   from this method may change at any time, but it is guaranteed that
     *   interfaces will only be added, not removed. After the connection
     *   status changes to CONNECTED, the return from this method cannot
     *   change further.</p>
     * 
     * <p>There is no explicit change notification; reasonable behaviour
     *   for a client would be to retrieve the interfaces list once
     *   initially, and once more when it becomes CONNECTED.</p>
     * 
     * <tp:rationale>
     *   <p>In some connection managers, certain capabilities of a connection
     *     are known to be implemented for all connections (e.g. support
     *     for SimplePresence), and some interfaces (like SimplePresence) can
     *     even be used before connecting. Other capabilities may
     *     or may not exist, depending on server functionality; by the time
     *     the connection goes CONNECTED, the connection manager is expected
     *     to have evaluated the server's functionality and enabled any extra
     *     interfaces for the remainder of the Connection's lifetime.</p>
     * </tp:rationale>
     *
     * \return
     *     
     *     An array of D-Bus interface names
     */
    inline QDBusPendingReply<QStringList> GetInterfaces()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetInterfaces"));
    }

    /**
     * Begins a call to the D-Bus method "GetProtocol" on the remote object.
     * 
     * Get the protocol this connection is using.
     *
     * \return
     *     
     *     A string identifier for the protocol
     */
    inline QDBusPendingReply<QString> GetProtocol()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetProtocol"));
    }

    /**
     * Begins a call to the D-Bus method "GetSelfHandle" on the remote object.
     * 
     * Returns the value of the SelfHandle property. Change notification is 
     * via the SelfHandleChanged signal.
     *
     * \return
     *     
     *     The value of the SelfHandle property
     */
    inline QDBusPendingReply<uint> GetSelfHandle()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetSelfHandle"));
    }

    /**
     * Begins a call to the D-Bus method "GetStatus" on the remote object.
     * 
     * Get the current status as defined in the StatusChanged signal.
     *
     * \return
     *     
     *     An integer representing the current status
     */
    inline QDBusPendingReply<uint> GetStatus()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetStatus"));
    }

    /**
     * Begins a call to the D-Bus method "HoldHandles" on the remote object.
     * 
     * <p>Notify the connection manger that your client is holding a copy
     * of handles which may not be in use in any existing channel or
     * list, and were not obtained by using the
     * <tp:member-ref>RequestHandles</tp:member-ref> method. For
     * example, a handle observed in an emitted signal, or displayed
     * somewhere in the UI that is not associated with a channel. The
     * connection manager must not deallocate a handle where any clients
     * have used this method to indicate it is in use until the
     * <tp:member-ref>ReleaseHandles</tp:member-ref>
     * method is called, or the clients disappear from the bus.</p>
     * 
     * <p>Note that HoldHandles is idempotent - calling it multiple times
     *   is equivalent to calling it once. If a handle is &quot;referenced&quot; by
     *   several components which share a D-Bus unique name, the client
     *   should perform reference counting internally, and only call
     *   ReleaseHandles when none of the cooperating components need the
     *   handle any longer.</p>
     *
     * \param handleType
     *     
     *     The type of handle to be held
     *
     * \param handles
     *     
     *     A array of integer handles to hold
     */
    inline QDBusPendingReply<> HoldHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("HoldHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "InspectHandles" on the remote object.
     * 
     * Return a string representation for a number of handles of a given type.
     *
     * \param handleType
     *     
     *     The type of handle to be inspected
     *
     * \param handles
     *     
     *     An array of integer handles of this type
     *
     * \return
     *     
     *     An array of handle names in the same order as the given numbers
     */
    inline QDBusPendingReply<QStringList> InspectHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("InspectHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ListChannels" on the remote object.
     * 
     * List all the channels which currently exist on this connection.
     *
     * \return
     *     
     *     An array of structs representing channels.
     */
    inline QDBusPendingReply<Tp::ChannelInfoList> ListChannels()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ChannelInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ListChannels"));
    }

    /**
     * Begins a call to the D-Bus method "ReleaseHandles" on the remote object.
     * 
     * Explicitly notify the connection manager that your client is no longer 
     * holding any references to the given handles, and that they may be 
     * deallocated if they are not held by any other clients or referenced by 
     * any existing channels. See HoldHandles for notes.
     *
     * \param handleType
     *     
     *     An integer handle type (as defined in RequestHandle)
     *
     * \param handles
     *     
     *     An array of integer handles being held by the client
     */
    inline QDBusPendingReply<> ReleaseHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("ReleaseHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestChannel" on the remote object.
     * 
     * <p>Request a channel satisfying the specified type and communicating
     *   with the contact, room, list etc. indicated by the given
     *   handle_type and handle. The handle_type and handle may both be
     *   zero to request the creation of a new, empty channel, which may
     *   or may not be possible, depending on the protocol and channel
     *   type.</p>
     * 
     * <p>On success, the returned channel will always be of the requested
     *   type (i.e. implement the requested channel-type interface).</p>
     * 
     * <p>If a new, empty channel is requested, on success the returned
     *   channel will always be an &quot;anonymous&quot; channel for which the type
     *   and handle are both zero.</p>
     * 
     * <p>If a channel to a contact, room etc. is requested, on success, the
     *   returned channel may either be a new or existing channel to
     *   the requested entity (i.e. its
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandleType</tp:dbus-ref>
     *   and <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandle</tp:dbus-ref>
     *   properties are the
     *   requested handle type and handle), or a newly created &quot;anonymous&quot;
     *   channel associated with the requested handle in some
     *   implementation-specific way.</p>
     * 
     * <p>For example, for a contact handle, the returned channel
     *   might be &quot;anonymous&quot;, but implement the groups interface and have
     *   the requested contact already present among the members.</p>
     * 
     * <p>If the request cannot be satisfied, an error is raised and no
     *   channel is created.</p>
     *
     * \param type
     *     
     *     A D-Bus interface name representing base channel type
     *
     * \param handleType
     *     
     *     An integer representing the handle type, or Handle_Type_None if no 
     *     handle is specified
     *
     * \param handle
     *     
     *     A nonzero integer handle representing a contact, room, list etc. 
     *     according to handle_type, or zero if the handle_type is 
     *     Handle_Type_None
     *
     * \param suppressHandler
     *     
     *     Clients SHOULD always set this to true. The historical meaning was 
     *     that clients that did not intend to take responsibility for 
     *     displaying the channel to the user could set this to FALSE, in 
     *     which case the channel dispatcher would launch an appropriate 
     *     channel handler. However, clients whose functionality relies on 
     *     having a working channel dispatcher should obtain that 
     *     functionality by calling methods on the channel dispatcher, so that 
     *     they will get an appropriate error if the channel dispatcher is 
     *     missing or not working. The channel dispatcher itself should set 
     *     this to true too, so that it will ignore the NewChannel signal that 
     *     results from the creation of the channel. It can then dispatch the 
     *     channel returned from this method to an appropriate handler. So, 
     *     there is no sensible use-case for setting this to false, and 
     *     setting it to false can result in unhandled channels (in the case 
     *     where clients assume that a channel dispatcher is present, but it 
     *     isn&apos;t).
     *
     * \return
     *     
     *     The D-Bus object path for the channel created or retrieved
     */
    inline QDBusPendingReply<QDBusObjectPath> RequestChannel(const QString& type, uint handleType, uint handle, bool suppressHandler)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusObjectPath>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(type) << QVariant::fromValue(handleType) << QVariant::fromValue(handle) << QVariant::fromValue(suppressHandler);
        return asyncCallWithArgumentList(QLatin1String("RequestChannel"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestHandles" on the remote object.
     * 
     * Request several handles from the connection manager which represent a 
     * number of contacts, rooms or server-stored lists on the service. The 
     * connection manager should record that these handles are in use by the 
     * client who invokes this method, and must not deallocate the handles 
     * until the client disconnects from the bus or calls the ReleaseHandles 
     * method. Where the name refers to an entity that already has a handle in 
     * this connection manager, this handle should be returned instead. The 
     * handle number 0 must not be returned by the connection manager.
     *
     * \param handleType
     *     
     *     The type of handle required
     *
     * \param names
     *     
     *     An array of names of entities to request handles for
     *
     * \return
     *     
     *     An array of integer handle numbers in the same order as the given 
     *     strings
     */
    inline QDBusPendingReply<Tp::UIntList> RequestHandles(uint handleType, const QStringList& names)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(names);
        return asyncCallWithArgumentList(QLatin1String("RequestHandles"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "SelfHandleChanged" on the remote object.
     * 
     * Emitted whenever the SelfHandle property changes. If the connection is 
     * not yet in the CONNECTED state, this signal is not guaranteed to be 
     * emitted.
     *
     * \param selfHandle
     *     
     *     The new value of the SelfHandle property.
     */
    void SelfHandleChanged(uint selfHandle);

    /**
     * Represents the signal "NewChannel" on the remote object.
     * 
     * Emitted when a new Channel object is created, either through user 
     * request or incoming information from the service.
     *
     * \param objectPath
     *     
     *     A D-Bus object path for the channel object on this service
     *
     * \param channelType
     *     
     *     A D-Bus interface name representing the channel type
     *
     * \param handleType
     *     
     *     An integer representing the type of handle this channel 
     *     communicates with, or Handle_Type_None if no handle is specified
     *
     * \param handle
     *     
     *     A handle indicating the specific contact, room or list this channel 
     *     communicates with, or zero if no handle is specified
     *
     * \param suppressHandler
     *     
     *     <p>If true, the channel was requested by a client that intends to
     *       present it to the user itself (i.e. it passed suppress_handler=TRUE
     *       to the <tp:member-ref>RequestChannel</tp:member-ref> method), so no
     *       other handler should be
     *       launched. Clients MAY assume that channels where this is true
     *       were created by a user request.</p>
     *     
     *     <p>If false, either the channel was created due to incoming
     *       information from the service, or the channel was requested by
     *       a local client that does not intend to handle the channel itself
     *       (this usage is deprecated).</p>
     *     
     *     <p>Clients MUST NOT assume that only incoming channels will have
     *       this flag set to false.</p>
     */
    void NewChannel(const QDBusObjectPath& objectPath, const QString& channelType, uint handleType, uint handle, bool suppressHandler);

    /**
     * Represents the signal "ConnectionError" on the remote object.
     * 
     * <p>Emitted when an error occurs that renders this connection unusable.
     * </p>
     * 
     * <p>Whenever this signal is emitted, it MUST immediately be followed by
     *   a <tp:member-ref>StatusChanged</tp:member-ref> signal with status
     *   Connection_Status_Reason_Disconnected and an appropriate reason
     *   code.</p>
     * 
     * <p>Connection managers SHOULD emit this signal on disconnection, but
     *   need not do so. Clients MUST support connection managers that emit
     *   StatusChanged(Disconnected, ...) without first emitting
     *   ConnectionError.</p>
     * 
     * <tp:rationale>
     *   <p>This signal provides additional information about the reason
     *     for disconnection. The reason for connection is always
     *     straightforward - it was requested - so it does not need further
     *     explanation. However, on errors, it can be useful to provide
     *     additional information.</p>
     * 
     *   <p>The <tp:type>Connection_Status_Reason</tp:type> is not given
     *     here, since it will be signalled in
     *     <tp:member-ref>StatusChanged</tp:member-ref>. A reasonable client
     *     implementation would be to store the information given by this
     *     signal until StatusChanged is received, at which point the
     *     information given by this signal can be used to supplement the
     *     StatusChanged signal.</p>
     * </tp:rationale>
     *
     * \param error
     *     
     *     The name of a D-Bus error describing the error that occurred, which 
     *     may correspond to a Connection_Status_Reason or be a 
     *     protocol-specific or connection-manager-specific error in a 
     *     suitable namespace. For instance, a SIP connection manager could 
     *     signal &quot;402 Payment Required&quot; as an error in a 
     *     connection-manager-specific namespace, or a link-local XMPP 
     *     implementation that used Avahi could provide the error given to it 
     *     by the avahi-daemon.
     *
     * \param details
     *     
     *     <p>Additional information about the error, which may include
     *       the following well-known keys:</p>
     *     
     *     <dl>
     *       <dt>debug-message (s)</dt>
     *       <dd>Debugging information on the change, corresponding to the
     *         message part of a D-Bus error message, which SHOULD NOT be
     *         displayed to users under normal circumstances</dd>
     *     </dl>
     *     
     *     <tp:rationale>
     *       <p>This argument allows for future extensions. For instance,
     *         if indicating DNS lookup failure, we could define a key
     *         that indicates the hostname that could not be found.</p>
     *     </tp:rationale>
     */
    void ConnectionError(const QString& error, const QVariantMap& details);

    /**
     * Represents the signal "StatusChanged" on the remote object.
     * 
     * Emitted when the status of the connection changes. All states and 
     * reasons have numerical values, as defined in ConnectionStatus and 
     * ConnectionStatusReason.
     *
     * \param status
     *     
     *     An integer indicating the new status, as defined by ConnectionStatus
     *
     * \param reason
     *     
     *     An integer indicating the reason for the status change, as defined 
     *     by ConnectionStatusReason
     */
    void StatusChanged(uint status, uint reason);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceAliasingInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Aliasing."
 */
class ConnectionInterfaceAliasingInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Aliasing", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Aliasing";
    }

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceAliasingInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceAliasingInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetAliasFlags" on the remote object.
     * 
     * Return a bitwise OR of flags detailing the behaviour of aliases on this 
     * connection.
     *
     * \return
     *     
     *     An integer with a bitwise OR of flags from ConnectionAliasFlags
     */
    inline QDBusPendingReply<uint> GetAliasFlags()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAliasFlags"));
    }

    /**
     * Begins a call to the D-Bus method "RequestAliases" on the remote object.
     * 
     * Request the value of several contacts&apos; aliases at once.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A list of aliases in the same order as the contact handles
     */
    inline QDBusPendingReply<QStringList> RequestAliases(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestAliases"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetAliases" on the remote object.
     * 
     * Request the value of several contacts&apos; aliases at once. This 
     * SHOULD only return cached aliases, falling back on the handle name if 
     * none is present. Also if there was no cached alias, a request SHOULD be 
     * started of which the result is later signalled by AliasesChanged.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A dictionary mapping contact handles to aliases
     */
    inline QDBusPendingReply<Tp::AliasMap> GetAliases(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::AliasMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetAliases"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetAliases" on the remote object.
     * 
     * Request that the alias of the given contact be changed. Success will be 
     * indicated by emitting an AliasesChanged signal. On connections where 
     * the CONNECTION_ALIAS_FLAG_USER_SET flag is not set, this method will 
     * only ever succeed if the contact is the user&apos;s own handle (as 
     * returned by Connection.GetSelfHandle).
     *
     * \param aliases
     *     
     *     A dictionary mapping integer handles of contacts to strings of the 
     *     new alias to set.
     */
    inline QDBusPendingReply<> SetAliases(const Tp::AliasMap& aliases)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(aliases);
        return asyncCallWithArgumentList(QLatin1String("SetAliases"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "AliasesChanged" on the remote object.
     * 
     * Signal emitted when a contact&apos;s alias (or that of the user) is 
     * changed.
     *
     * \param aliases
     *     
     *     An array containing structs of:
     *     <ul>
     *       <li>the handle representing the contact</li>
     *       <li>the new alias</li>
     *     </ul>
     */
    void AliasesChanged(const Tp::AliasPairList& aliases);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceAvatarsInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Avatars."
 */
class ConnectionInterfaceAvatarsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Avatars", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Avatars";
    }

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceAvatarsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceAvatarsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "SupportedAvatarMIMETypes" on the remote object.
     * 
     * An array of supported MIME types (e.g. &quot;image/jpeg&quot;). Clients 
     * MAY assume that the first type in this array is preferred. This 
     * property cannot change after the Connection goes to the Connected state.
     */
    Q_PROPERTY(QStringList SupportedAvatarMIMETypes READ SupportedAvatarMIMETypes)

    /**
     * Getter for the remote object property "SupportedAvatarMIMETypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList SupportedAvatarMIMETypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("SupportedAvatarMIMETypes"));
    }

    /**
     * Represents property "MinimumAvatarHeight" on the remote object.
     * 
     * The minimum height in pixels of an avatar on this protocol, which MAY 
     * be 0. This property cannot change after the Connection goes to the 
     * Connected state.
     */
    Q_PROPERTY(uint MinimumAvatarHeight READ MinimumAvatarHeight)

    /**
     * Getter for the remote object property "MinimumAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MinimumAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MinimumAvatarHeight"));
    }

    /**
     * Represents property "MinimumAvatarWidth" on the remote object.
     * 
     * The minimum width in pixels of an avatar on this protocol, which MAY be 
     * 0. This property cannot change after the Connection goes to the 
     * Connected state.
     */
    Q_PROPERTY(uint MinimumAvatarWidth READ MinimumAvatarWidth)

    /**
     * Getter for the remote object property "MinimumAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MinimumAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MinimumAvatarWidth"));
    }

    /**
     * Represents property "RecommendedAvatarHeight" on the remote object.
     * 
     * The recommended height in pixels of an avatar on this protocol, or 0 if 
     * there is no preferred height. This property cannot change after the 
     * Connection goes to the Connected state. In XMPP a recommended width is 
     * given by the protocol specification; in proprietary protocols, using 
     * the same avatar size as the proprietary client is likely to lead to the 
     * best display to other users.
     */
    Q_PROPERTY(uint RecommendedAvatarHeight READ RecommendedAvatarHeight)

    /**
     * Getter for the remote object property "RecommendedAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint RecommendedAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("RecommendedAvatarHeight"));
    }

    /**
     * Represents property "RecommendedAvatarWidth" on the remote object.
     * 
     * The recommended width in pixels of an avatar on this protocol, or 0 if 
     * there is no preferred width. This property cannot change after the 
     * Connection goes to the Connected state. The rationale is the same as 
     * for RecommendedAvatarHeight.
     */
    Q_PROPERTY(uint RecommendedAvatarWidth READ RecommendedAvatarWidth)

    /**
     * Getter for the remote object property "RecommendedAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint RecommendedAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("RecommendedAvatarWidth"));
    }

    /**
     * Represents property "MaximumAvatarHeight" on the remote object.
     * 
     * The maximum height in pixels of an avatar on this protocol, or 0 if 
     * there is no limit. This property cannot change after the Connection 
     * goes to the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarHeight READ MaximumAvatarHeight)

    /**
     * Getter for the remote object property "MaximumAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarHeight"));
    }

    /**
     * Represents property "MaximumAvatarWidth" on the remote object.
     * 
     * The maximum width in pixels of an avatar on this protocol, or 0 if 
     * there is no limit. This property cannot change after the Connection 
     * goes to the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarWidth READ MaximumAvatarWidth)

    /**
     * Getter for the remote object property "MaximumAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarWidth"));
    }

    /**
     * Represents property "MaximumAvatarBytes" on the remote object.
     * 
     * The maximum size in bytes of an avatar on this protocol, or 0 if there 
     * is no limit. This property cannot change after the Connection goes to 
     * the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarBytes READ MaximumAvatarBytes)

    /**
     * Getter for the remote object property "MaximumAvatarBytes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarBytes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarBytes"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetAvatarRequirements" on the remote object.
     * 
     * Get the required format of avatars on this connection.
     *
     * \return
     *     
     *     An array of supported MIME types (eg image/jpeg)
     *
     * \return
     *     
     *     The minimum image width in pixels
     *
     * \return
     *     
     *     The minimum image height in pixels
     *
     * \return
     *     
     *     The maximum image width in pixels, or 0 if there is no limit
     *
     * \return
     *     
     *     The maximum image height in pixels, or 0 if there is no limit
     *
     * \return
     *     
     *     The maximum image size in bytes, or 0 if there is no limit
     */
    inline QDBusPendingReply<QStringList, ushort, ushort, ushort, ushort, uint> GetAvatarRequirements()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList, ushort, ushort, ushort, ushort, uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAvatarRequirements"));
    }

    /**
     * Begins a call to the D-Bus method "GetAvatarTokens" on the remote object.
     * 
     * Get the unique tokens for all of the given contacts&apos; avatars. 
     * Using this method in new Telepathy clients is deprecated; use 
     * GetKnownAvatarTokens instead.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     An array of avatar tokens or empty strings (if no avatar is set) in 
     *     the same order as the given array of contact handles
     */
    inline QDBusPendingReply<QStringList> GetAvatarTokens(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetAvatarTokens"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetKnownAvatarTokens" on the remote object.
     * 
     * Get the unique tokens for the given contacts&apos; avatars. These 
     * tokens can be persisted across connections, and should be used by the 
     * client to check whether the avatars have been updated. For handles 
     * other than the self handle, only tokens that are already known are 
     * returned; an empty token means the given contact has no avatar. 
     * However, a CM must always have the tokens for the self handle if one is 
     * set (even if it is set to no avatar). On protocols where the avatar 
     * does not persist between connections, a CM should omit the self handle 
     * from the returned map until an avatar is explicitly set or cleared.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A dictionary of handles mapped to avatar tokens, containing only 
     *     the known avatar tokens.
     */
    inline QDBusPendingReply<Tp::AvatarTokenMap> GetKnownAvatarTokens(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::AvatarTokenMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetKnownAvatarTokens"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestAvatar" on the remote object.
     * 
     * Request the avatar for a given contact. Using this method in new 
     * Telepathy clients is deprecated; use RequestAvatars instead.
     *
     * \param contact
     *     
     *     An integer handle for the contact to request the avatar for
     *
     * \return
     *     
     *     An array of bytes containing the image data
     *
     * \return
     *     
     *     A string containing the image MIME type (eg image/jpeg), or empty 
     *     if unknown
     */
    inline QDBusPendingReply<QByteArray, QString> RequestAvatar(uint contact)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QByteArray, QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contact);
        return asyncCallWithArgumentList(QLatin1String("RequestAvatar"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestAvatars" on the remote object.
     * 
     * Request avatars for a number of contacts. The AvatarRetrieved signal is 
     * emitted for each avatar retrieved. If the handles are valid but 
     * retrieving an avatar fails (for any reason, including the contact not 
     * having an avatar) the AvatarRetrieved signal is not emitted for that 
     * contact.
     *
     * \param contacts
     *     
     *     The contacts to retrieve avatars for
     */
    inline QDBusPendingReply<> RequestAvatars(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestAvatars"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetAvatar" on the remote object.
     * 
     * Set a new avatar image for this connection. The avatar image must 
     * respect the requirements obtained by GetAvatarRequirements.
     *
     * \param avatar
     *     
     *     An array of bytes representing the avatar image data
     *
     * \param MIMEType
     *     
     *     A string representing the image MIME type
     *
     * \return
     *     
     *     The string token of the new avatar
     */
    inline QDBusPendingReply<QString> SetAvatar(const QByteArray& avatar, const QString& MIMEType)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(avatar) << QVariant::fromValue(MIMEType);
        return asyncCallWithArgumentList(QLatin1String("SetAvatar"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ClearAvatar" on the remote object.
     * 
     * Remove the avatar image for this connection.
     */
    inline QDBusPendingReply<> ClearAvatar()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ClearAvatar"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "AvatarUpdated" on the remote object.
     * 
     * Emitted when the avatar for a contact has been updated, or first 
     * discovered on this connection. If the token differs from the token 
     * associated with the client&apos;s cached avatar for this contact, the 
     * new avatar should be requested with RequestAvatars.
     *
     * \param contact
     *     
     *     An integer handle for the contact whose avatar has changed
     *
     * \param newAvatarToken
     *     
     *     Unique token for their new avatar
     */
    void AvatarUpdated(uint contact, const QString& newAvatarToken);

    /**
     * Represents the signal "AvatarRetrieved" on the remote object.
     * 
     * Emitted when the avatar for a contact has been retrieved.
     *
     * \param contact
     *     
     *     The contact whose avatar has been retrieved
     *
     * \param token
     *     
     *     The token corresponding to the avatar
     *
     * \param avatar
     *     
     *     An array of bytes containing the image data
     *
     * \param type
     *     
     *     A string containing the image MIME type (eg image/jpeg), or empty 
     *     if unknown
     */
    void AvatarRetrieved(uint contact, const QString& token, const QByteArray& avatar, const QString& type);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceCapabilitiesInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Capabilities."
 */
class ConnectionInterfaceCapabilitiesInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Capabilities", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Capabilities";
    }

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceCapabilitiesInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AdvertiseCapabilities" on the remote object.
     * 
     * <p>Used by user interfaces to indicate which channel types they are able
     * to handle on this connection. Because these may be provided by
     * different client processes, this method accepts channel types to add
     * and remove from the set already advertised on this connection. The type
     * of advertised capabilities (create versus invite) is protocol-dependent
     * and hence cannot be set by the this method. In the case of a client
     * adding an already advertised channel type but with new channel type
     * specific flags, the connection manager should simply add the new flags
     * to the set of advertised capabilities.</p>
     * 
     * <p>Upon a successful invocation of this method, the
     * <tp:member-ref>CapabilitiesChanged</tp:member-ref>
     * signal will be emitted for the user's own handle ( <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.GetSelfHandle</tp:dbus-ref>)
     * by the connection manager to indicate the changes
     * that have been made.  This signal should also be monitored to ensure
     * that the set is kept accurate - for example, a client may remove
     * capabilities or type specific capability flags when it exits
     * which are still provided by another client.</p>
     *
     * \param add
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of type specific capability flags</li>
     *     </ul>
     *
     * \param remove
     *     
     *     An array of D-Bus interface names of channel types to remove
     *
     * \return
     *     
     *     An array of structures describing the current capabilities 
     *     containing: a string channel type a bitwise OR of type specific 
     *     capability flags
     */
    inline QDBusPendingReply<Tp::CapabilityPairList> AdvertiseCapabilities(const Tp::CapabilityPairList& add, const QStringList& remove)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::CapabilityPairList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(add) << QVariant::fromValue(remove);
        return asyncCallWithArgumentList(QLatin1String("AdvertiseCapabilities"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetCapabilities" on the remote object.
     * 
     * Returns an array of capabilities for the given contact handles.
     *
     * \param handles
     *     
     *     <p>An array of contact handles for this connection.</p>
     *     
     *     <p>This may include zero, which originally meant a query for
     *       capabilities available on the connection itself. This usage
     *       is deprecated; clients SHOULD NOT do this, and connection managers
     *       SHOULD proceed as though zero had not been present in this
     *       list.</p>
     *
     * \return
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>an integer handle representing the contact</li>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of generic capability flags for the type</li>
     *       <li>a bitwise OR of type specific capability flags for the type</li>
     *     </ul>
     */
    inline QDBusPendingReply<Tp::ContactCapabilityList> GetCapabilities(const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactCapabilityList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("GetCapabilities"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "CapabilitiesChanged" on the remote object.
     * 
     * <p>Announce that there has been a change of capabilities on the
     *   given handle.</p>
     * 
     * <p>If the handle is zero, the capabilities refer to the connection
     *   itself, in some poorly defined way. This usage is deprecated and
     *   clients should ignore it.</p>
     *
     * \param caps
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>an integer handle representing the contact</li>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of the contact's old generic capability flags</li>
     *       <li>a bitwise OR of the contact's new generic capability flags</li>
     *       <li>a bitwise OR of the contact's old type specific capability flags</li>
     *       <li>a bitwise OR of the contact's new type specific capability flags</li>
     *     </ul>
     */
    void CapabilitiesChanged(const Tp::CapabilityChangeList& caps);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceContactsInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Contacts."
 */
class ConnectionInterfaceContactsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Contacts", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Contacts";
    }

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceContactsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceContactsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "ContactAttributeInterfaces" on the remote object.
     * 
     * A list of D-Bus interfaces for which GetContactAttributes is expected 
     * to work. This cannot change during the lifetime of the Connection.
     */
    Q_PROPERTY(QStringList ContactAttributeInterfaces READ ContactAttributeInterfaces)

    /**
     * Getter for the remote object property "ContactAttributeInterfaces".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList ContactAttributeInterfaces() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("ContactAttributeInterfaces"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetContactAttributes" on the remote object.
     * 
     * Return any number of contact attributes for the given handles.
     *
     * \param handles
     *     
     *     An array of handles representing contacts.
     *
     * \param interfaces
     *     
     *     <p>A list of strings indicating which D-Bus interfaces the calling
     *       process is interested in. All supported attributes from these
     *       interfaces, whose values can be obtained without additional network
     *       activity, will be in the reply.</p>
     *     
     *     <p>It is an error to request interfaces that are not supported by
     *       this Connection (i.e. mentioned in the
     *       <tp:member-ref>ContactAttributeInterfaces</tp:member-ref>
     *       property).</p>
     *     
     *     <tp:rationale>
     *       <p>This makes it possible to distinguish between interfaces for
     *         which the Connection has nothing to say (e.g. we don't know the
     *         avatar tokens of any of the contacts, so we omitted them all),
     *         and interfaces for which this API isn't supported.</p>
     *     </tp:rationale>
     *     
     *     <p>Attributes from the interface
     *       <tp:dbus-ref>org.freedesktop.Telepathy.Connection</tp:dbus-ref>
     *       are always returned, and need not be requested explicitly.</p>
     *     
     *     <p>As well as returning cached information immediately, the
     *       connection MAY start asynchronous requests to obtain better
     *       values for the contact attributes. If better values are later
     *       obtained by this process, they will be indicated with the usual
     *       signals (such as <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Aliasing">AliasesChanged</tp:dbus-ref>).</p>
     *     
     *     <tp:rationale>
     *       For instance, an XMPP connection manager could download vCards
     *       in response to a request for <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">Aliasing</tp:dbus-ref>
     *       attributes.
     *     </tp:rationale>
     *
     * \param hold
     *     
     *     If true, all handles in the result have been held on behalf of the 
     *     calling process, as if by a call to Connection.HoldHandles. For 
     *     further round-trip avoidance.
     *
     * \return
     *     
     *     <p>A dictionary mapping the contact handles to contact attributes.
     *       If any of the requested handles are in fact invalid, they are
     *       simply omitted from this mapping. If contact attributes are not
     *       immediately known, the behaviour is defined by the interface;
     *       the attribute should either be omitted from the result or
     *       replaced with a default value.</p>
     *     
     *     <p>Each contact's attributes will always include at least the
     *       identifier that would be obtained by inspecting the handle
     *       (<code>org.freedesktop.Telepathy.Connection/contact-id</code>).</p>
     */
    inline QDBusPendingReply<Tp::ContactAttributesMap> GetContactAttributes(const Tp::UIntList& handles, const QStringList& interfaces, bool hold)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactAttributesMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles) << QVariant::fromValue(interfaces) << QVariant::fromValue(hold);
        return asyncCallWithArgumentList(QLatin1String("GetContactAttributes"), argumentList);
    }

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfacePresenceInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Presence."
 */
class ConnectionInterfacePresenceInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Presence", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Presence";
    }

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfacePresenceInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfacePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AddStatus" on the remote object.
     * 
     * Request that a single presence status is published for the user, along 
     * with any desired parameters. Changes will be indicated by 
     * PresenceUpdate signals being emitted.
     *
     * \param status
     *     
     *     The string identifier of the desired status
     *
     * \param parameters
     *     
     *     A dictionary of optional parameter names mapped to their 
     *     variant-boxed values
     */
    inline QDBusPendingReply<> AddStatus(const QString& status, const QVariantMap& parameters)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status) << QVariant::fromValue(parameters);
        return asyncCallWithArgumentList(QLatin1String("AddStatus"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ClearStatus" on the remote object.
     * 
     * Request that all of a user&apos;s presence statuses be removed. Be 
     * aware that this request may simply result in the statuses being 
     * replaced by a default available status. Changes will be indicated by 
     * PresenceUpdate signals being emitted.
     */
    inline QDBusPendingReply<> ClearStatus()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ClearStatus"));
    }

    /**
     * Begins a call to the D-Bus method "GetPresence" on the remote object.
     * 
     * Get presence previously emitted by PresenceUpdate for the given 
     * contacts. Data is returned in the same structure as the PresenceUpdate 
     * signal. Using this method in favour of RequestPresence has the 
     * advantage that it will not wake up each client connected to the 
     * PresenceUpdate signal.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained
     *
     * \return
     *     
     *     Presence information in the same format as for the PresenceUpdate 
     *     signal
     */
    inline QDBusPendingReply<Tp::ContactPresences> GetPresence(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactPresences>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetStatuses" on the remote object.
     * 
     * Get a dictionary of the valid presence statuses for this connection. 
     * This is only available when online because only some statuses will be 
     * available on some servers.
     *
     * \return
     *     
     *     A dictionary of string identifiers mapped to a struct for each 
     *     status, containing: a type value from one of the values above a 
     *     boolean to indicate if this status may be set on yourself a boolean 
     *     to indicate if this is an exclusive status which you may not set 
     *     alongside any other a dictionary of valid optional string argument 
     *     names mapped to their types
     */
    inline QDBusPendingReply<Tp::StatusSpecMap> GetStatuses()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::StatusSpecMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetStatuses"));
    }

    /**
     * Begins a call to the D-Bus method "RemoveStatus" on the remote object.
     * 
     * Request that the given presence status is no longer published for the 
     * user. Changes will be indicated by PresenceUpdate signals being 
     * emitted. As with ClearStatus, removing a status may actually result in 
     * it being replaced by a default available status.
     *
     * \param status
     *     
     *     The string identifier of the status not to publish anymore for the 
     *     user
     */
    inline QDBusPendingReply<> RemoveStatus(const QString& status)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status);
        return asyncCallWithArgumentList(QLatin1String("RemoveStatus"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestPresence" on the remote object.
     * 
     * Request the presence for contacts on this connection. A PresenceUpdate 
     * signal will be emitted when they are received. This is not the same as 
     * subscribing to the presence of a contact, which must be done using the 
     * &apos;subscription&apos; ContactList, and on some protocols presence 
     * information may not be available unless a subscription exists.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained
     */
    inline QDBusPendingReply<> RequestPresence(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetLastActivityTime" on the remote object.
     * 
     * Request that the recorded last activity time for the user be updated on 
     * the server.
     *
     * \param time
     *     
     *     A UNIX timestamp of the user&apos;s last activity time (in UTC)
     */
    inline QDBusPendingReply<> SetLastActivityTime(uint time)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(time);
        return asyncCallWithArgumentList(QLatin1String("SetLastActivityTime"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetStatus" on the remote object.
     * 
     * <p>Request that the user's presence be changed to the given statuses
     *   and desired parameters. Changes will be reflected by
     *   <tp:member-ref>PresenceUpdate</tp:member-ref>
     *   signals being emitted.</p>
     * 
     * <p>Statuses whose <tp:type>Connection_Presence_Type</tp:type>
     *   is Offline, Error or Unknown MUST NOT be passed to this
     *   function. Connection managers SHOULD reject these statuses.</p>
     * 
     * <tp:rationale>
     *   <p>The same rationale as for <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">SimplePresence.SetPresence</tp:dbus-ref>
     *     applies.</p>
     * </tp:rationale>
     * 
     * <p>On certain protocols, this method may be
     *   called on a newly-created connection which is still in the
     *   DISCONNECTED state, and will sign on with the requested status.
     *   If the requested status is not available after signing on,
     *   NotAvailable will be returned and the connection will remain
     *   offline, or if the protocol does not support signing on with
     *   a certain status, Disconnected will be returned.</p>
     *
     * \param statuses
     *     
     *     A dictionary mapping status identifiers to dictionaries, which map 
     *     optional parameter names to their variant-boxed values
     */
    inline QDBusPendingReply<> SetStatus(const Tp::MultipleStatusMap& statuses)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(statuses);
        return asyncCallWithArgumentList(QLatin1String("SetStatus"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "PresenceUpdate" on the remote object.
     * 
     * This signal should be emitted when your own presence has been changed, 
     * or the presence of the member of any of the connection&apos;s channels 
     * has been changed, or when the presence requested by RequestPresence is 
     * available.
     *
     * \param presence
     *     
     *     A dictionary of contact handles mapped to a struct containing a 
     *     UNIX timestamp of the last activity time (in UTC), and a dictionary 
     *     mapping the contact&apos;s current status identifiers to a 
     *     dictionary of optional parameter names mapped to their 
     *     variant-boxed values
     */
    void PresenceUpdate(const Tp::ContactPresences& presence);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceRequestsInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Requests."
 */
class ConnectionInterfaceRequestsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Requests", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Requests";
    }

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceRequestsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceRequestsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Channels" on the remote object.
     * 
     * A list of all the channels which currently exist on this connection. 
     * Change notification is via the NewChannels and ChannelClosed signals.
     */
    Q_PROPERTY(Tp::ChannelDetailsList Channels READ Channels)

    /**
     * Getter for the remote object property "Channels".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::ChannelDetailsList Channels() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::ChannelDetailsList>(internalPropGet("Channels"));
    }

    /**
     * Represents property "RequestableChannelClasses" on the remote object.
     * 
     * <p>The classes of channel that are expected to be available on this
     *   connection, i.e. those for which
     *   <tp:member-ref>CreateChannel</tp:member-ref> can reasonably
     *   be expected to succeed. User interfaces can use this information
     *   to show or hide UI components.</p>
     * 
     * <p>This property cannot change after the connection has gone to
     *   state Connection_Status_Connected, so there is no change
     *   notification (if the connection has context-dependent capabilities,
     *   it SHOULD advertise support for all classes of channel that it might
     *   support during its lifetime). Before this state has been reached,
     *   the value of this property is undefined.</p>
     * 
     * <tp:rationale>
     *   <p>This is not on an optional interface, because connection
     *     managers can always offer some sort of clue about the channel
     *     classes they expect to support (at worst, they can announce
     *     support for everything for which they have code).</p>
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::RequestableChannelClassList RequestableChannelClasses READ RequestableChannelClasses)

    /**
     * Getter for the remote object property "RequestableChannelClasses".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::RequestableChannelClassList RequestableChannelClasses() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::RequestableChannelClassList>(internalPropGet("RequestableChannelClasses"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "CreateChannel" on the remote object.
     * 
     * <p>Request that an entirely new channel is created.</p>
     * 
     * <tp:rationale>
     *   <p>There is deliberately no flag corresponding to the
     *     suppress_handler argument to
     *     <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.RequestChannel</tp:dbus-ref>,
     *     because passing a FALSE value for that argument is deprecated.
     *     Requests made using this interface always behave as though
     *     suppress_handler was TRUE.</p>
     * </tp:rationale>
     *
     * \param request
     *     
     *     <p>A dictionary containing desirable properties, which MUST include
     *       <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">ChannelType</tp:dbus-ref>.
     *       Some properties
     *       are defined such that only an exact match makes sense, and
     *       connection managers MUST NOT satisfy a request with a channel
     *       where that property does not match; some properties are defined
     *       such that the connection manager MAY treat the request as merely
     *       a hint, and make a best-effort attempt to satisfy it. This is
     *       documented separately for each property.</p>
     *     
     *     <p>If this dictionary contains a property whose semantics
     *       are not known to the connection manager, this method MUST fail
     *       without side-effects (in particular it must not create a new
     *       channel).</p>
     *     
     *     <tp:rationale>
     *       <p>This is necessary if we want to be able to invent properties
     *         in future that, when used in a request, are hard requirements
     *         rather than just hints. A connection manager that did not know
     *         the semantics of those properties could incorrectly return a
     *         new channel that did not satisfy the requirements.</p>
     *     </tp:rationale>
     *     
     *     <p>The connection manager MUST NOT respond successfully,
     *       and SHOULD NOT create a new channel or cause any other
     *       side-effects, unless it can create a new channel that satisfies
     *       the client's requirements.</p>
     *     
     *     <p>Properties that will be set by this argument need not have write
     *       access after the channel has been created - indeed, it is
     *       expected that most will be read-only.</p>
     *
     * \return
     *     
     *     <p>The Channel object, which MUST NOT be signalled with
     *       <tp:member-ref>NewChannels</tp:member-ref> until after this method
     *       returns.</p>
     *     
     *     <tp:rationale>
     *       <p>This allows the requester to alter its handling of
     *         NewChannels by knowing whether one of the channels satisfied
     *         a request it made.</p>
     *     </tp:rationale>
     *
     * \return
     *     
     *     <p>Properties of the channel that was produced, equivalent to
     *       the properties in <tp:type>Channel_Details</tp:type>.
     *       Connection managers MUST NOT include properties here whose
     *       values can change, for the same reasons as in
     *       <tp:type>Channel_Details</tp:type>.</p>
     */
    inline QDBusPendingReply<QDBusObjectPath, QVariantMap> CreateChannel(const QVariantMap& request)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusObjectPath, QVariantMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(request);
        return asyncCallWithArgumentList(QLatin1String("CreateChannel"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "EnsureChannel" on the remote object.
     * 
     * <p>Request that channels are ensured to exist.</p>
     * 
     * <tp:rationale>
     *   <p>The connection manager is in the best position to determine which
     *     existing channels could satisfy which requests.</p>
     * </tp:rationale>
     *
     * \param request
     *     
     *     <p>A dictionary containing desirable properties, with the same
     *       semantics as the corresponding parameter to
     *       <tp:member-ref>CreateChannel</tp:member-ref>.</p>
     *
     * \return
     *     
     *     <p>If false, the caller of EnsureChannel MUST assume that some
     *       other process is handling this channel; if true, the caller of
     *       EnsureChannel SHOULD handle it themselves or delegate it to another
     *       client.</p>
     *     
     *     <p>If the creation of a channel makes several calls to EnsureChannel
     *       (and no other requests) successful, exactly one of those calls MUST
     *       return a true value for this argument.</p>
     *     
     *     <p>If the creation of a channel makes other requests successful,
     *       the value returned for this argument MUST be such that exactly
     *       one of the clients making requests ends up responsible for the
     *       channel. In particular, if
     *       <tp:member-ref>CreateChannel</tp:member-ref> returns a channel
     *       <em>C</em>, any EnsureChannel calls that also return <em>C</em>
     *       MUST return a false value for this argument.</p>
     *
     * \return
     *     
     *     The Channel object. If it was created as a result of this method 
     *     call, it MUST NOT be signalled by NewChannels until after this 
     *     method returns. This allows the requester to alter its handling of 
     *     NewChannels by knowing whether one of the channels satisfied a 
     *     request it made.
     *
     * \return
     *     
     *     <p>Properties of the channel that was produced, equivalent to
     *       the properties in <tp:type>Channel_Details</tp:type>.
     *       Connection managers MUST NOT include properties here whose
     *       values can change, for the same reasons as in
     *       <tp:type>Channel_Details</tp:type>.</p>
     */
    inline QDBusPendingReply<bool, QDBusObjectPath, QVariantMap> EnsureChannel(const QVariantMap& request)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<bool, QDBusObjectPath, QVariantMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(request);
        return asyncCallWithArgumentList(QLatin1String("EnsureChannel"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "NewChannels" on the remote object.
     * 
     * <p>New channels have been created. The connection manager SHOULD emit
     *   a single signal for any group of closely related channels that are
     *   created at the same time, so that the channel dispatcher can try to
     *   dispatch them to a handler as a unit.</p>
     * 
     * <p>In particular, if additional channels are created as a side-effect
     *   of a call to <tp:member-ref>CreateChannel</tp:member-ref>,
     *   these channels SHOULD appear in the same NewChannels signal as
     *   the channel that satisfies the request.</p>
     * 
     * <tp:rationale>
     *   <p>Joining a MUC Tube in XMPP requires joining the corresponding
     *     MUC (chatroom), so a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text</tp:dbus-ref>
     *     channel can be created as a side-effect.</p>
     * </tp:rationale>
     * 
     * <p>Every time NewChannels is emitted, it MUST be followed by
     *   a <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.NewChannel</tp:dbus-ref>
     *   signal for each channel.</p>
     * 
     * <tp:rationale>
     *   <p>The double signal emission is for the benefit of older Telepathy
     *     clients, which won't be listening for NewChannels.</p>
     * 
     *   <p>The more informative NewChannels signal comes first so that
     *     clients that did not examine the connection to find
     *     out whether Requests is supported will see the more informative
     *     signal for each channel first, and then ignore the less
     *     informative signal because it announces a new channel of which
     *     they are already aware.</p>
     * </tp:rationale>
     *
     * \param channels
     *     
     *     The channels and their details. All channels that are signalled 
     *     together like this MUST have the same Bundle property, which may 
     *     either refer to an existing bundle, or establish a new bundle.
     */
    void NewChannels(const Tp::ChannelDetailsList& channels);

    /**
     * Represents the signal "ChannelClosed" on the remote object.
     * 
     * Emitted when a channel is closed and hence disappears from the Channels 
     * property. This is redundant with the Closed signal on the channel 
     * itself, but it does provide full change notification for the Channels 
     * property.
     *
     * \param removed
     *     
     *     The channel which has been removed from the Channels property
     */
    void ChannelClosed(const QDBusObjectPath& removed);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceSimplePresenceInterface
 * \headerfile TelepathyQt4/connection.h <TelepathyQt4/Connection>
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.SimplePresence."
 */
class ConnectionInterfaceSimplePresenceInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.SimplePresence", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.SimplePresence";
    }

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceSimplePresenceInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceSimplePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Statuses" on the remote object.
     * 
     * <p>A dictionary where the keys are the presence statuses that are
     *   available on this connection, and the values are the corresponding
     *   presence types.</p>
     * 
     * <p>While the connection is in the DISCONNECTED state, it contains
     *   the set of presence statuses allowed to be set before connecting.
     *   The connection manager will attempt to set the appropriate status
     *   when the connection becomes connected, but cannot necessarily
     *   guarantee it. The available statuses cannot change until the
     *   connection status changes, so there is no change notification.</p>
     * 
     * <p>While the connection is in the CONNECTED state, this property
     *   contains the set of presence statuses which are actually available
     *   on this protocol. This set is constant for the remaining lifetime
     *   of the connection, so again, there is no change notification.</p>
     * 
     * <p>While the connection is in the CONNECTING state, the value of
     *   this property is undefined and SHOULD NOT be used. It can change
     *   at any time without notification (in particular, any cached values
     *   from when the connection was in the DISCONNECTED or CONNECTING
     *   state MUST NOT be assumed to still be correct when the state has
     *   become CONNECTED).</p>
     * 
     * <p>This property MUST include the special statuses &quot;unknown&quot; and
     *   &quot;error&quot; if and only if the connection manager can emit them
     *   as a contact's status.</p>
     * 
     * <tp:rationale>
     *   For instance, connection managers for local-xmpp (XEP-0174) would
     *   omit &quot;unknown&quot; since there is no such concept.
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::SimpleStatusSpecMap Statuses READ Statuses)

    /**
     * Getter for the remote object property "Statuses".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SimpleStatusSpecMap Statuses() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SimpleStatusSpecMap>(internalPropGet("Statuses"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "SetPresence" on the remote object.
     * 
     * <p>Request that the presence status and status message are published for
     *   the connection.  Changes will be indicated by
     *   <tp:member-ref>PresencesChanged</tp:member-ref>
     *   signals being emitted.</p>
     * 
     * <p>This method may be called on a newly-created connection while it
     *   is still in the DISCONNECTED state, to request that when the
     *   connection connects, it will do so with the selected status.</p>
     * 
     * <p>In DISCONNECTED state the
     *   <tp:member-ref>Statuses</tp:member-ref>
     *   property will indicate which statuses are allowed to be set
     *   while DISCONNECTED (none, if the Connection Manager doesn't allow
     *   this). This value MUST NOT be cached, as the set of allowed
     *   presences might change upon connecting.</p>
     *
     * \param status
     *     
     *     <p>The string identifier of the desired status. Possible status
     *       identifiers are defined in the
     *       <tp:member-ref>Statuses</tp:member-ref> property.</p>
     *     
     *     <p>Clients MUST NOT set a status whose string value they do not
     *       recognise, even if its presence type in Statuses
     *       matches what the user requested.</p>
     *     
     *     <tp:rationale>
     *       <p>Suppose a protocol has statuses that include 'phone' (of type
     *         BUSY) and 'in-a-meeting' (of type BUSY), but there is no
     *         generic 'busy' status.</p>
     *     
     *       <p>If the user requests &quot;Busy&quot; status from a menu, a
     *         client author might be tempted to pick an arbitrary status
     *         that has type BUSY. However, on this protocol, neither of
     *         the choices would be appropriate, and incorrect information
     *         about the user would be conveyed.</p>
     *     </tp:rationale>
     *     
     *     <p>Statuses whose <tp:type>Connection_Presence_Type</tp:type>
     *       is Offline, Error or Unknown MUST NOT be passed to this
     *       function. Connection managers SHOULD reject these statuses.</p>
     *     
     *     <tp:rationale>
     *       <p>To go offline, call <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">Disconnect</tp:dbus-ref>
     *       instead. The &quot;error&quot; and &quot;unknown&quot; statuses make no sense.</p>
     *     </tp:rationale>
     *
     * \param statusMessage
     *     
     *     The status message associated with the current status.
     */
    inline QDBusPendingReply<> SetPresence(const QString& status, const QString& statusMessage)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status) << QVariant::fromValue(statusMessage);
        return asyncCallWithArgumentList(QLatin1String("SetPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetPresences" on the remote object.
     * 
     * Get presence previously emitted by PresencesChanged for the given 
     * contacts. Data is returned in the same structure as the 
     * PresencesChanged signal; no additional network requests are made.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained.
     *
     * \return
     *     
     *     <p>Presence information in the same format as for the
     *       <tp:member-ref>PresencesChanged</tp:member-ref> signal.
     *       The returned mapping MUST include an entry for each contact
     *       in the method's argument.</p>
     *     
     *     <p>The definition of the connection presence types Unknown
     *       and Offline means that if a connection manager will return
     *       Unknown for contacts not on the subscribe list, it MUST delay
     *       the reply to this method call until it has found out which
     *       contacts are, in fact, on the subscribe list.</p>
     */
    inline QDBusPendingReply<Tp::SimpleContactPresences> GetPresences(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::SimpleContactPresences>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetPresences"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "PresencesChanged" on the remote object.
     * 
     * This signal should be emitted when your own presence has been changed, 
     * or the presence of the member of any of the connection&apos;s channels 
     * has been changed.
     *
     * \param presence
     *     
     *     A dictionary of contact handles mapped to the status, presence type 
     *     and status message.
     */
    void PresencesChanged(const Tp::SimpleContactPresences& presence);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};
}
}
