<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: Channel Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="classTp_1_1Channel.html">Channel</a>
  </div>
<div class="contents">
<h1>Channel Class Reference<br>
<small>
[<a class="el" href="group__clientchannel.html">Channel proxies</a>]</small>
</h1><!-- doxytag: class="Tp::Channel" --><!-- doxytag: inherits="Tp::StatefulDBusProxy,OptionalInterfaceFactory&lt; Channel &gt;,Tp::ReadyObject,Tp::RefCounted" --><code>#include &lt;<a class="el" href="channel_8h_source.html">TelepathyQt4/Channel</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1StatefulDBusProxy.html">Tp::StatefulDBusProxy</a>, <a class="el" href="classTp_1_1OptionalInterfaceFactory.html">OptionalInterfaceFactory&lt; Channel &gt;</a>, <a class="el" href="classTp_1_1ReadyObject.html">Tp::ReadyObject</a>, and <a class="el" href="classTp_1_1RefCounted.html">Tp::RefCounted</a>.
<p>
Inherited by <a class="el" href="classTp_1_1FileTransferChannel.html">FileTransferChannel</a>, <a class="el" href="classTp_1_1RoomListChannel.html">RoomListChannel</a>, <a class="el" href="classTp_1_1StreamedMediaChannel.html">StreamedMediaChannel</a>, and <a class="el" href="classTp_1_1TextChannel.html">TextChannel</a>.
<p>

<p>
<a href="classTp_1_1Channel-members.html">List of all members.</a><h2>Classes</h2>
<ul>
<li>class <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">GroupMemberChangeDetails</a>
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="classTp_1_1Channel.html#aa3e4efaeab550e78798458bfaddda07">groupCanAddContactsChanged</a> (bool canAddContacts)
<li>void <a class="el" href="classTp_1_1Channel.html#90bfbdfa1808d6d82a52ec157757d331">groupCanRemoveContactsChanged</a> (bool canRemoveContacts)
<li>void <a class="el" href="classTp_1_1Channel.html#daf8c439bdbf37c168bab45ebc217f83">groupCanRescindContactsChanged</a> (bool canRescindContacts)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="classTp_1_1Channel.html#ad279ec58dddf879ac20651fceffd4cf">~Channel</a> ()
<li><a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> <a class="el" href="classTp_1_1Channel.html#d7dfedd8a11393b66a7b09bf1462d448">connection</a> () const 
<li>QVariantMap <a class="el" href="classTp_1_1Channel.html#24b13e210ff5ffe6fea14d3a36ec36f7">immutableProperties</a> () const 
<li>QString <a class="el" href="classTp_1_1Channel.html#a562543eec8e4278c8d8e404a882f698">channelType</a> () const 
<li>uint <a class="el" href="classTp_1_1Channel.html#98ffc001c0632d3c4cdaa81279722a0b">targetHandleType</a> () const 
<li>uint <a class="el" href="classTp_1_1Channel.html#7b3aed3725a40cf7f03792e5faee17d4">targetHandle</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#22eebfd7562f69c28f4d348d99c13ef4">isRequested</a> () const 
<li><a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> <a class="el" href="classTp_1_1Channel.html#a72bf1046268b2d3a10176b93cfe06aa">initiatorContact</a> () const 
<li><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * <a class="el" href="classTp_1_1Channel.html#d44792e540565a2aadf025a78cf54b9e">requestClose</a> ()
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceMessagesInterface.html">Client::ChannelInterfaceMessagesInterface</a> * <a class="el" href="classTp_1_1Channel.html#f47a9cf9a66576173a7bfbf14a1f9cde">messagesInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static <a class="el" href="classTp_1_1SharedPtr.html">ChannelPtr</a> <a class="el" href="classTp_1_1Channel.html#613fa7581ab9ec8480b1c6d398ac06a1">create</a> (const <a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)
</ul>
<h2>Static Public Attributes</h2>
<ul>
<li>static const <a class="el" href="classTp_1_1Feature.html">Feature</a> <a class="el" href="classTp_1_1Channel.html#5000fb4b8588d0f682acb4f35f0fb94c">FeatureCore</a>
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Channel.html#08d8b7114028685632b7e2b849ff6100">Channel</a> (const <a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)
</ul>
<h2>Group interface</h2>
Cached access to state of the group interface on the associated remote object, if the interface is present. Almost all methods return undefined values if the list returned by <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#fc67bc67eb43553606889443d50df9b1">interfaces()</a> doesn't include <a class="el" href="group__ifacestrconsts.html#g7c613c607872398cf52e41c349710f88">TELEPATHY_INTERFACE_CHANNEL_INTERFACE_GROUP</a> or if the object is not ready.<p>
Some methods can be used when <a class="el" href="classTp_1_1Channel.html#98ffc001c0632d3c4cdaa81279722a0b">targetHandleType()</a> == HandleTypeContact, such as <a class="el" href="classTp_1_1Channel.html#7c3bf7d8004b19cf59c0fab3f933ce66">groupFlags()</a>, <a class="el" href="classTp_1_1Channel.html#05b0519639a41b379a109d3e1b458a7b">groupCanAddContacts()</a>, <a class="el" href="classTp_1_1Channel.html#00f6e322596bd36db0b429ae55dd1847">groupCanRemoveContacts()</a>, <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a> and <a class="el" href="classTp_1_1Channel.html#c07446161a375eb940600e37582eee9f">groupContacts()</a>.<p>
As the Group interface state can change freely during the lifetime of the group due to events like new contacts joining the group, the cached state is automatically kept in sync with the remote object's state by hooking to the change notification signals present in the D-Bus interface.<p>
As the cached value changes, change notification signals are emitted.<p>
There is a change notification signal &lt;attribute&gt;Changed corresponding to each cached attribute. The first parameter for each of these signals is the new value of the attribute, which is suited for displaying the value of the attribute in a widget in a model-view fashion. The remaining arguments depend on the attribute, but in general include at least the delta from the previous state of the attribute to the new state.<p>
Check the individual signals' descriptions for details. <ul>
<li>uint <a class="el" href="classTp_1_1Channel.html#7c3bf7d8004b19cf59c0fab3f933ce66">groupFlags</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#05b0519639a41b379a109d3e1b458a7b">groupCanAddContacts</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#3c5964155d6d7f5524e91850f234a7ae">groupCanAddContactsWithMessage</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#425c6b8080458e7399743338e104e77c">groupCanAcceptContactsWithMessage</a> () const 
<li><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * <a class="el" href="classTp_1_1Channel.html#d94e20e14b07e9f2c4a0b28ebcc25e49">groupAddContacts</a> (const QList&lt; <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &gt; &amp;contacts, const QString &amp;message=QString())
<li>bool <a class="el" href="classTp_1_1Channel.html#87c1315d7c52ab1cbc8e513e54636830">groupCanRescindContacts</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#9454b088c1a6eb08937d5b2220653149">groupCanRescindContactsWithMessage</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#00f6e322596bd36db0b429ae55dd1847">groupCanRemoveContacts</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#c98a1b1183e1a54910bfc69c44c3ac1d">groupCanRemoveContactsWithMessage</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#185fb1b3aa38e54705f286577e00493a">groupCanRejectContactsWithMessage</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#0d2877b8e03226ddd6662ee026207cc4">groupCanDepartWithMessage</a> () const 
<li><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * <a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts</a> (const QList&lt; <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &gt; &amp;contacts, const QString &amp;message=QString(), uint reason=ChannelGroupChangeReasonNone)
<li><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> <a class="el" href="classTp_1_1Channel.html#c07446161a375eb940600e37582eee9f">groupContacts</a> () const 
<li><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> <a class="el" href="classTp_1_1Channel.html#fc3e4a717febd9765b6f9204d0734a37">groupLocalPendingContacts</a> () const 
<li><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> <a class="el" href="classTp_1_1Channel.html#eea564f8a4125f42e071d92a885564ab">groupRemotePendingContacts</a> () const 
<li><a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">GroupMemberChangeDetails</a> <a class="el" href="classTp_1_1Channel.html#d9441474ba1e45528ebe4f2c16817c88">groupLocalPendingContactChangeInfo</a> (const <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &amp;contact) const 
<li><a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">GroupMemberChangeDetails</a> <a class="el" href="classTp_1_1Channel.html#143b8429433022ac622ba29700df38b6">groupSelfContactRemoveInfo</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#131ea23f2732d2510c149a0916ba7ae6">groupAreHandleOwnersAvailable</a> () const 
<li><a class="el" href="structTp_1_1HandleOwnerMap.html">HandleOwnerMap</a> <a class="el" href="classTp_1_1Channel.html#8a4414a993738c1e9b1c2ae04b32d0e6">groupHandleOwners</a> () const 
<li>bool <a class="el" href="classTp_1_1Channel.html#f1be22fdd24b182b2dbfb28c82f6d323">groupIsSelfContactTracked</a> () const 
<li><a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact</a> () const 
<li>void <a class="el" href="classTp_1_1Channel.html#0fadf9667c8aa6732c3ad0705e7a4cbc">groupFlagsChanged</a> (uint flags, uint added, uint removed)
<li>void <a class="el" href="classTp_1_1Channel.html#434d0ec9e98866789f37441b054d3660">groupMembersChanged</a> (const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;groupMembersAdded, const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;groupLocalPendingMembersAdded, const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;groupRemotePendingMembersAdded, const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;groupMembersRemoved, const <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">Tp::Channel::GroupMemberChangeDetails</a> &amp;details)
<li>void <a class="el" href="classTp_1_1Channel.html#be6d68fb9782467019688c4958162054">groupHandleOwnersChanged</a> (const <a class="el" href="structTp_1_1HandleOwnerMap.html">Tp::HandleOwnerMap</a> &amp;owners, const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;added, const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;removed)
<li>void <a class="el" href="classTp_1_1Channel.html#ebd8c47984b6f5a4a69f31996901d75c">groupSelfContactChanged</a> ()
<li>bool <a class="el" href="classTp_1_1Channel.html#cb16b08500593600376d6dbc5f380465">groupSelfHandleIsLocalPending</a> () const 
<li><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * <a class="el" href="classTp_1_1Channel.html#1ce5d469553bca13127eb274d3760687">groupAddSelfHandle</a> ()
</ul>
<h2>Optional interface proxy factory</h2>
Factory functions fabricating proxies for optional Channel interfaces and interfaces for specific channel types. <ul>
<li><a class="el" href="classTp_1_1Client_1_1DBus_1_1PropertiesInterface.html">Client::DBus::PropertiesInterface</a> * <a class="el" href="classTp_1_1Channel.html#b405b641ff735e5ded8bc45dd2fddcdc">propertiesInterface</a> () const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceCallStateInterface.html">Client::ChannelInterfaceCallStateInterface</a> * <a class="el" href="classTp_1_1Channel.html#6f64b32912e9c407948eb1ee877802a9">callStateInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceChatStateInterface.html">Client::ChannelInterfaceChatStateInterface</a> * <a class="el" href="classTp_1_1Channel.html#63a97518ffdd189d37a66b2339d4e7cf">chatStateInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceDTMFInterface.html">Client::ChannelInterfaceDTMFInterface</a> * <a class="el" href="classTp_1_1Channel.html#7ac1b6fbc54d814ec86e6616249bb464">DTMFInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceHoldInterface.html">Client::ChannelInterfaceHoldInterface</a> * <a class="el" href="classTp_1_1Channel.html#9c681b88a1c9ebbe9dcb9c7758ae6a23">holdInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceMediaSignallingInterface.html">Client::ChannelInterfaceMediaSignallingInterface</a> * <a class="el" href="classTp_1_1Channel.html#27c4c1edb196c3ec468ec0c770aed820">mediaSignallingInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfacePasswordInterface.html">Client::ChannelInterfacePasswordInterface</a> * <a class="el" href="classTp_1_1Channel.html#6e08ca2332ce4f521b0163fc3c835dde">passwordInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li>template&lt;class Interface &gt; Interface * <a class="el" href="classTp_1_1Channel.html#cd2bb2cfcb6239cfe5ebb3256cc4d118">typeInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelTypeRoomListInterface.html">Client::ChannelTypeRoomListInterface</a> * <a class="el" href="classTp_1_1Channel.html#574314a89fba8679e17b19e94ca48a2c">roomListInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelTypeStreamedMediaInterface.html">Client::ChannelTypeStreamedMediaInterface</a> * <a class="el" href="classTp_1_1Channel.html#849f4722aff2652803f458047cdd9bd0">streamedMediaInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelTypeTextInterface.html">Client::ChannelTypeTextInterface</a> * <a class="el" href="classTp_1_1Channel.html#c3ddb108708826242ba4f31871caf7c8">textInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelTypeTubesInterface.html">Client::ChannelTypeTubesInterface</a> * <a class="el" href="classTp_1_1Channel.html#efe20e2d68067926280cb16cbe0b29f8">tubesInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">Client::ChannelInterface</a> * <a class="el" href="classTp_1_1Channel.html#be1dc2d17ba74769e3c93dc5a975bf57">baseInterface</a> () const 
<li><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceGroupInterface.html">Client::ChannelInterfaceGroupInterface</a> * <a class="el" href="classTp_1_1Channel.html#42d6344939de8c2c06914b334fc53ed1">groupInterface</a> (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a> check=CheckInterfaceSupported) const 
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
High-level proxy object for accessing remote Telepathy <a class="el" href="classTp_1_1Channel.html">Channel</a> objects.<p>
It adds the following features compared to using ChannelInterface directly: <ul>
<li>
Life cycle tracking </li>
<li>
Getting the channel type, handle type, handle and interfaces automatically </li>
<li>
High-level methods for the group interface </li>
<li>
A fake group implementation when handle type != <a class="el" href="classTp_1_1Contact.html">Contact</a> </li>
<li>
Shared optional interface proxy instances </li>
</ul>
<p>
The remote object state accessor functions on this object (<a class="el" href="classTp_1_1OptionalInterfaceFactory.html#fc67bc67eb43553606889443d50df9b1">interfaces()</a>, <a class="el" href="classTp_1_1Channel.html#a562543eec8e4278c8d8e404a882f698">channelType()</a>, <a class="el" href="classTp_1_1Channel.html#98ffc001c0632d3c4cdaa81279722a0b">targetHandleType()</a>, <a class="el" href="classTp_1_1Channel.html#7b3aed3725a40cf7f03792e5faee17d4">targetHandle()</a>, requested(), <a class="el" href="classTp_1_1Channel.html#a72bf1046268b2d3a10176b93cfe06aa">initiatorContact()</a>, etc) don't make any DBus calls; instead, they return values cached from a previous introspection run. The introspection process populates their values in the most efficient way possible based on what the service implements. However, their value is not defined unless the object is ready, as returned by <a class="el" href="classTp_1_1ReadyObject.html#4058df48c0ffb0cde98ac0df319f7acf">isReady()</a>. becomeReady should be used to make sure channel is ready.<p>
Additionally, the state of the Group interface on the remote object (if present) will be cached in the introspection process, and also tracked for any changes.<p>
Each <a class="el" href="classTp_1_1Channel.html">Channel</a> is owned by a <a class="el" href="classTp_1_1Connection.html">Connection</a>. If the <a class="el" href="classTp_1_1Connection.html">Connection</a> becomes dead (as signaled by Connection::statusChanged(Disconnected)) or is deleted, the <a class="el" href="classTp_1_1Channel.html">Channel</a> object will transition to closed too. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ad279ec58dddf879ac20651fceffd4cf"></a><!-- doxytag: member="Tp::Channel::~Channel" ref="ad279ec58dddf879ac20651fceffd4cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classTp_1_1Channel.html">Channel</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Class destructor. 
</div>
</div><p>
<a class="anchor" name="08d8b7114028685632b7e2b849ff6100"></a><!-- doxytag: member="Tp::Channel::Channel" ref="08d8b7114028685632b7e2b849ff6100" args="(const ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Channel.html">Channel</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>immutableProperties</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classTp_1_1Channel.html">Channel</a> object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td><a class="el" href="classTp_1_1Connection.html">Connection</a> owning this <a class="el" href="classTp_1_1Channel.html">Channel</a>, and specifying the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>immutableProperties</em>&nbsp;</td><td>The immutable properties of the channel, as signalled by NewChannels or returned by CreateChannel or EnsureChannel </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="613fa7581ab9ec8480b1c6d398ac06a1"></a><!-- doxytag: member="Tp::Channel::create" ref="613fa7581ab9ec8480b1c6d398ac06a1" args="(const ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1SharedPtr.html">ChannelPtr</a> create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>immutableProperties</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classTp_1_1FileTransferChannel.html#9120a12f79eb368c5314dec5b81f8bf9">FileTransferChannel</a>, <a class="el" href="classTp_1_1RoomListChannel.html#44b6b39b8dac380642908e3fad021e97">RoomListChannel</a>, <a class="el" href="classTp_1_1StreamedMediaChannel.html#c649743b81121f7a3e0468cc4c154029">StreamedMediaChannel</a>, and <a class="el" href="classTp_1_1TextChannel.html#4e50bf31c7dc5fda31fbdb2752f98ab3">TextChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="d7dfedd8a11393b66a7b09bf1462d448"></a><!-- doxytag: member="Tp::Channel::connection" ref="d7dfedd8a11393b66a7b09bf1462d448" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1SharedPtr.html">ConnectionPtr</a> connection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the owning <a class="el" href="classTp_1_1Connection.html">Connection</a> of the <a class="el" href="classTp_1_1Channel.html">Channel</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classTp_1_1Connection.html">Connection</a> object that owns this <a class="el" href="classTp_1_1Channel.html">Channel</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="24b13e210ff5ffe6fea14d3a36ec36f7"></a><!-- doxytag: member="Tp::Channel::immutableProperties" ref="24b13e210ff5ffe6fea14d3a36ec36f7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariantMap immutableProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the immutable properties of the channel.<p>
If the channel is ready (<a class="el" href="classTp_1_1ReadyObject.html#4058df48c0ffb0cde98ac0df319f7acf">isReady()</a> returns true), the following keys are guaranteed to be present: org.freedesktop.Telepathy.Channel.ChannelType, org.freedesktop.Telepathy.Channel.TargetHandleType, org.freedesktop.Telepathy.Channel.TargetHandle and org.freedesktop.Telepathy.Channel.Requested.<p>
The keys and values in this map are defined by the Telepathy D-Bus specification, or by third-party extensions to that specification. These are the properties that cannot change over the lifetime of the channel; they're announced in the result of the request, for efficiency.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A map in which the keys are D-Bus property names and the values are the corresponding values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a562543eec8e4278c8d8e404a882f698"></a><!-- doxytag: member="Tp::Channel::channelType" ref="a562543eec8e4278c8d8e404a882f698" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString channelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type of this channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>D-Bus interface name for the type of the channel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="98ffc001c0632d3c4cdaa81279722a0b"></a><!-- doxytag: member="Tp::Channel::targetHandleType" ref="98ffc001c0632d3c4cdaa81279722a0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint targetHandleType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type of the handle returned by <a class="el" href="classTp_1_1Channel.html#7b3aed3725a40cf7f03792e5faee17d4">targetHandle()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type of the handle, as specified in HandleType. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b3aed3725a40cf7f03792e5faee17d4"></a><!-- doxytag: member="Tp::Channel::targetHandle" ref="7b3aed3725a40cf7f03792e5faee17d4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint targetHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the handle of the remote party with which this channel communicates.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The handle, which is of the type <a class="el" href="classTp_1_1Channel.html#98ffc001c0632d3c4cdaa81279722a0b">targetHandleType()</a> indicates. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22eebfd7562f69c28f4d348d99c13ef4"></a><!-- doxytag: member="Tp::Channel::isRequested" ref="22eebfd7562f69c28f4d348d99c13ef4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isRequested           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether this channel was created in response to a local request.<p>
Note that the value is undefined until the channel is ready.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if this channel was created in response to a local request, <code>false</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a72bf1046268b2d3a10176b93cfe06aa"></a><!-- doxytag: member="Tp::Channel::initiatorContact" ref="a72bf1046268b2d3a10176b93cfe06aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> initiatorContact           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the contact who initiated the channel.<p>
Note that the value is undefined until the channel is ready.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classTp_1_1Contact.html">Contact</a> object representing the contact who initiated the channel, or ContactPtr that points to null(0) if it can't be retrieved. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d44792e540565a2aadf025a78cf54b9e"></a><!-- doxytag: member="Tp::Channel::requestClose" ref="d44792e540565a2aadf025a78cf54b9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * requestClose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous request that the channel be closed. The returned <a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> object will signal the success or failure of this request; under normal circumstances, it can be expected to succeed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A PendingOperation, which will emit finished when the request finishes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c3bf7d8004b19cf59c0fab3f933ce66"></a><!-- doxytag: member="Tp::Channel::groupFlags" ref="7c3bf7d8004b19cf59c0fab3f933ce66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint groupFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a set of flags indicating the capabilities and behaviour of the group represented by the remote object.<p>
Change notification is via <a class="el" href="classTp_1_1Channel.html#0fadf9667c8aa6732c3ad0705e7a4cbc">groupFlagsChanged()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Bitfield combination of flags, as defined in <a class="el" href="group__flagtypeconsts.html#g958b3de84b9cd669fafbf6ebd6a126f1">ChannelGroupFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="05b0519639a41b379a109d3e1b458a7b"></a><!-- doxytag: member="Tp::Channel::groupCanAddContacts" ref="05b0519639a41b379a109d3e1b458a7b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanAddContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return if contacts can be added or invited to this channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if contacts can be added, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#d94e20e14b07e9f2c4a0b28ebcc25e49">groupAddContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c5964155d6d7f5524e91850f234a7ae"></a><!-- doxytag: member="Tp::Channel::groupCanAddContactsWithMessage" ref="3c5964155d6d7f5524e91850f234a7ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanAddContactsWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when inviting contacts who are not already members to this channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#d94e20e14b07e9f2c4a0b28ebcc25e49">groupAddContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="425c6b8080458e7399743338e104e77c"></a><!-- doxytag: member="Tp::Channel::groupCanAcceptContactsWithMessage" ref="425c6b8080458e7399743338e104e77c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanAcceptContactsWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when accepting contacts' requests to join this channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#d94e20e14b07e9f2c4a0b28ebcc25e49">groupAddContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d94e20e14b07e9f2c4a0b28ebcc25e49"></a><!-- doxytag: member="Tp::Channel::groupAddContacts" ref="d94e20e14b07e9f2c4a0b28ebcc25e49" args="(const QList&lt; ContactPtr &gt; &amp;contacts, const QString &amp;message=QString())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * groupAddContacts           </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em> = <code>QString()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add contacts to this channel.<p>
Contacts on the local pending list (those waiting for permission to join the channel) can always be added. If <a class="el" href="classTp_1_1Channel.html#425c6b8080458e7399743338e104e77c">groupCanAcceptContactsWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this; if not, the message parameter is likely to be ignored (so the user should not be asked for a message, and the message parameter should be left empty).<p>
Other contacts can only be added if <a class="el" href="classTp_1_1Channel.html#05b0519639a41b379a109d3e1b458a7b">groupCanAddContacts()</a> returns <code>true</code>. If <a class="el" href="classTp_1_1Channel.html#3c5964155d6d7f5524e91850f234a7ae">groupCanAddContactsWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this, and if not, the message parameter is likely to be ignored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contacts</em>&nbsp;</td><td>Contacts to be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A string message, which can be blank if desired. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> which will emit <a class="el" href="classTp_1_1PendingOperation.html#bf99e0568bf06827cf873d1693061c60">PendingOperation::finished</a> when the call has finished. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#05b0519639a41b379a109d3e1b458a7b">groupCanAddContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="87c1315d7c52ab1cbc8e513e54636830"></a><!-- doxytag: member="Tp::Channel::groupCanRescindContacts" ref="87c1315d7c52ab1cbc8e513e54636830" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanRescindContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether contacts in <a class="el" href="classTp_1_1Channel.html#eea564f8a4125f42e071d92a885564ab">groupRemotePendingContacts()</a> can be removed from this channel (i.e. whether an invitation can be rescinded).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if contacts can be removed, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9454b088c1a6eb08937d5b2220653149"></a><!-- doxytag: member="Tp::Channel::groupCanRescindContactsWithMessage" ref="9454b088c1a6eb08937d5b2220653149" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanRescindContactsWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when removing contacts who are in <a class="el" href="classTp_1_1Channel.html#eea564f8a4125f42e071d92a885564ab">groupRemotePendingContacts()</a> from this channel, i.e. rescinding an invitation.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="00f6e322596bd36db0b429ae55dd1847"></a><!-- doxytag: member="Tp::Channel::groupCanRemoveContacts" ref="00f6e322596bd36db0b429ae55dd1847" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanRemoveContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return if contacts in <a class="el" href="classTp_1_1Channel.html#c07446161a375eb940600e37582eee9f">groupContacts()</a> can be removed from this channel.<p>
Note that contacts in local pending lists, and the <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a>, can always be removed from the channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if contacts can be removed, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c98a1b1183e1a54910bfc69c44c3ac1d"></a><!-- doxytag: member="Tp::Channel::groupCanRemoveContactsWithMessage" ref="c98a1b1183e1a54910bfc69c44c3ac1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanRemoveContactsWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when removing contacts who are in <a class="el" href="classTp_1_1Channel.html#c07446161a375eb940600e37582eee9f">groupContacts()</a> from this channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="185fb1b3aa38e54705f286577e00493a"></a><!-- doxytag: member="Tp::Channel::groupCanRejectContactsWithMessage" ref="185fb1b3aa38e54705f286577e00493a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanRejectContactsWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when removing contacts who are in <a class="el" href="classTp_1_1Channel.html#fc3e4a717febd9765b6f9204d0734a37">groupLocalPendingContacts()</a> from this channel, i.e. rejecting a request to join.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d2877b8e03226ddd6662ee026207cc4"></a><!-- doxytag: member="Tp::Channel::groupCanDepartWithMessage" ref="0d2877b8e03226ddd6662ee026207cc4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupCanDepartWithMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a message is expected when removing the <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a> from this channel, i.e. departing from the channel.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if a message is expected, <code>false</code> otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#b13a88c36398a01489f1c531c4227200">groupRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b13a88c36398a01489f1c531c4227200"></a><!-- doxytag: member="Tp::Channel::groupRemoveContacts" ref="b13a88c36398a01489f1c531c4227200" args="(const QList&lt; ContactPtr &gt; &amp;contacts, const QString &amp;message=QString(), uint reason=ChannelGroupChangeReasonNone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * groupRemoveContacts           </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>contacts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em> = <code>QString()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>reason</em> = <code>ChannelGroupChangeReasonNone</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove contacts from this channel.<p>
Contacts on the local pending list (those waiting for permission to join the channel) can always be removed. If <a class="el" href="classTp_1_1Channel.html#185fb1b3aa38e54705f286577e00493a">groupCanRejectContactsWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this; if not, the message parameter is likely to be ignored (so the user should not be asked for a message, and the message parameter should be left empty).<p>
The <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a> can also always be removed, as a way to leave the group with an optional departure message and/or departure reason indication. If <a class="el" href="classTp_1_1Channel.html#0d2877b8e03226ddd6662ee026207cc4">groupCanDepartWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this, and if not, the message parameter is likely to be ignored.<p>
Contacts in the group can only be removed (e.g. kicked) if <a class="el" href="classTp_1_1Channel.html#00f6e322596bd36db0b429ae55dd1847">groupCanRemoveContacts()</a> returns <code>true</code>. If <a class="el" href="classTp_1_1Channel.html#c98a1b1183e1a54910bfc69c44c3ac1d">groupCanRemoveContactsWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this, and if not, the message parameter is likely to be ignored.<p>
Contacts in the remote pending list (those who have been invited to the channel) can only be removed (have their invitations rescinded) if <a class="el" href="classTp_1_1Channel.html#87c1315d7c52ab1cbc8e513e54636830">groupCanRescindContacts()</a> returns <code>true</code>. If <a class="el" href="classTp_1_1Channel.html#9454b088c1a6eb08937d5b2220653149">groupCanRescindContactsWithMessage()</a> returns <code>true</code>, an optional message is expected when doing this, and if not, the message parameter is likely to be ignored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contacts</em>&nbsp;</td><td>Contacts to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A string message, which can be blank if desired. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Reason of the change, as specified in <a class="el" href="group__enumtypeconsts.html#g20af5159cb67d4edce5db5e73fbad55a">ChannelGroupChangeReason</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> which will emit <a class="el" href="classTp_1_1PendingOperation.html#bf99e0568bf06827cf873d1693061c60">PendingOperation::finished</a> when the call has finished. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1Channel.html#00f6e322596bd36db0b429ae55dd1847">groupCanRemoveContacts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c07446161a375eb940600e37582eee9f"></a><!-- doxytag: member="Tp::Channel::groupContacts" ref="c07446161a375eb940600e37582eee9f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> groupContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the current contacts of the group.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of contact objects. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc3e4a717febd9765b6f9204d0734a37"></a><!-- doxytag: member="Tp::Channel::groupLocalPendingContacts" ref="fc3e4a717febd9765b6f9204d0734a37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> groupLocalPendingContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the contacts currently waiting for local approval to join the group.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of contacts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eea564f8a4125f42e071d92a885564ab"></a><!-- doxytag: member="Tp::Channel::groupRemotePendingContacts" ref="eea564f8a4125f42e071d92a885564ab" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Contacts</a> groupRemotePendingContacts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the contacts currently waiting for remote approval to join the group.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>List of contacts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9441474ba1e45528ebe4f2c16817c88"></a><!-- doxytag: member="Tp::Channel::groupLocalPendingContactChangeInfo" ref="d9441474ba1e45528ebe4f2c16817c88" args="(const ContactPtr &amp;contact) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">Channel::GroupMemberChangeDetails</a> groupLocalPendingContactChangeInfo           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>contact</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return information of a local pending contact change. If no information is available, an object for which <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html#ac1b70a2ed67ead038c4d3f5ac4d8a81">GroupMemberChangeDetails::isValid()</a> returns <code>false</code> is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contact</em>&nbsp;</td><td>A <a class="el" href="classTp_1_1Contact.html">Contact</a> object that is on the local pending contacts list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The change info in a <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">GroupMemberChangeDetails</a> object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="143b8429433022ac622ba29700df38b6"></a><!-- doxytag: member="Tp::Channel::groupSelfContactRemoveInfo" ref="143b8429433022ac622ba29700df38b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">Channel::GroupMemberChangeDetails</a> groupSelfContactRemoveInfo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return information on the removal of the local user from the group. If the user hasn't been removed from the group, an object for which <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html#ac1b70a2ed67ead038c4d3f5ac4d8a81">GroupMemberChangeDetails::isValid()</a> Return <code>false</code> is returned.<p>
This method should be called only after the channel has been closed. This is useful for getting the remove information after missing the corresponding <a class="el" href="classTp_1_1Channel.html#434d0ec9e98866789f37441b054d3660">groupMembersChanged()</a> signal, as the local user being removed usually causes the remote <a class="el" href="classTp_1_1Channel.html">Channel</a> to be closed.<p>
The returned information is not guaranteed to be correct if groupIsSelfHandleTracked() Return false and a self handle change has occurred on the remote object.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The remove info in a <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">GroupMemberChangeDetails</a> object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="131ea23f2732d2510c149a0916ba7ae6"></a><!-- doxytag: member="Tp::Channel::groupAreHandleOwnersAvailable" ref="131ea23f2732d2510c149a0916ba7ae6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupAreHandleOwnersAvailable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether globally valid handles can be looked up using the channel-specific handle on this channel using this object.<p>
Handle owner lookup is only available if: <ul>
<li>
The object is ready </li>
<li>
The list returned by <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#fc67bc67eb43553606889443d50df9b1">interfaces()</a> contains <a class="el" href="group__ifacestrconsts.html#g7c613c607872398cf52e41c349710f88">TELEPATHY_INTERFACE_CHANNEL_INTERFACE_GROUP</a> </li>
<li>
The set of flags returned by <a class="el" href="classTp_1_1Channel.html#7c3bf7d8004b19cf59c0fab3f933ce66">groupFlags()</a> contains GroupFlagProperties and GroupFlagChannelSpecificHandles </li>
</ul>
<p>
If this function Return <code>false</code>, the return value of <a class="el" href="classTp_1_1Channel.html#8a4414a993738c1e9b1c2ae04b32d0e6">groupHandleOwners()</a> is undefined and <a class="el" href="classTp_1_1Channel.html#be6d68fb9782467019688c4958162054">groupHandleOwnersChanged()</a> will never be emitted.<p>
The value returned by this function will stay fixed for the entire time the object is ready, so no change notification is provided.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If handle owner lookup functionality is available. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a4414a993738c1e9b1c2ae04b32d0e6"></a><!-- doxytag: member="Tp::Channel::groupHandleOwners" ref="8a4414a993738c1e9b1c2ae04b32d0e6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTp_1_1HandleOwnerMap.html">HandleOwnerMap</a> groupHandleOwners           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a mapping of handles specific to this channel to globally valid handles.<p>
The mapping includes at least all of the channel-specific handles in this channel's members, local-pending and remote-pending sets as keys. Any handle not in the keys of this mapping is not channel-specific in this channel. Handles which are channel-specific, but for which the owner is unknown, appear in this mapping with 0 as owner.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A mapping from group-specific handles to globally valid handles. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1be22fdd24b182b2dbfb28c82f6d323"></a><!-- doxytag: member="Tp::Channel::groupIsSelfContactTracked" ref="f1be22fdd24b182b2dbfb28c82f6d323" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupIsSelfContactTracked           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether the value returned by <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a> is guaranteed to stay synchronized with what <a class="el" href="classTp_1_1Channel.html#42d6344939de8c2c06914b334fc53ed1">groupInterface()</a>-&gt;GetSelfHandle() would return. Older services not providing group properties don't necessarily emit the SelfHandleChanged signal either, so self contact changes can't be reliably tracked.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether or not changes to the self contact are tracked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfe23d19b4b566bfebfcd5ab776b4786"></a><!-- doxytag: member="Tp::Channel::groupSelfContact" ref="bfe23d19b4b566bfebfcd5ab776b4786" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTp.html#58b74925faeec84ce5da45dbf41bebd4">ContactPtr</a> groupSelfContact           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classTp_1_1Contact.html">Contact</a> object representing the user in the group if the user is a member of the group, otherwise either a <a class="el" href="classTp_1_1Contact.html">Contact</a> object representing the user or 0.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A contact handle representing the user, if possible. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b405b641ff735e5ded8bc45dd2fddcdc"></a><!-- doxytag: member="Tp::Channel::propertiesInterface" ref="b405b641ff735e5ded8bc45dd2fddcdc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DBus::PropertiesInterface * propertiesInterface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a Properties interface proxy. The Properties interface is not necessarily reported by the services, so a <code>check</code> parameter is not provided, and the interface is always assumed to be present.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;DBus::PropertiesInterface&gt;(BypassInterfaceCheck)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f64b32912e9c407948eb1ee877802a9"></a><!-- doxytag: member="Tp::Channel::callStateInterface" ref="6f64b32912e9c407948eb1ee877802a9" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceCallStateInterface * callStateInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a CallState interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceCallStateInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="63a97518ffdd189d37a66b2339d4e7cf"></a><!-- doxytag: member="Tp::Channel::chatStateInterface" ref="63a97518ffdd189d37a66b2339d4e7cf" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceChatStateInterface * chatStateInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a ChatState interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceChatStateInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ac1b6fbc54d814ec86e6616249bb464"></a><!-- doxytag: member="Tp::Channel::DTMFInterface" ref="7ac1b6fbc54d814ec86e6616249bb464" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceDTMFInterface * DTMFInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a DTMF interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceDTMFInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c681b88a1c9ebbe9dcb9c7758ae6a23"></a><!-- doxytag: member="Tp::Channel::holdInterface" ref="9c681b88a1c9ebbe9dcb9c7758ae6a23" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceHoldInterface * holdInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a Hold interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceHoldInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="27c4c1edb196c3ec468ec0c770aed820"></a><!-- doxytag: member="Tp::Channel::mediaSignallingInterface" ref="27c4c1edb196c3ec468ec0c770aed820" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceMediaSignallingInterface * mediaSignallingInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a MediaSignalling interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceMediaSignallingInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f47a9cf9a66576173a7bfbf14a1f9cde"></a><!-- doxytag: member="Tp::Channel::messagesInterface" ref="f47a9cf9a66576173a7bfbf14a1f9cde" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelInterfaceMessagesInterface.html">Client::ChannelInterfaceMessagesInterface</a>* messagesInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6e08ca2332ce4f521b0163fc3c835dde"></a><!-- doxytag: member="Tp::Channel::passwordInterface" ref="6e08ca2332ce4f521b0163fc3c835dde" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfacePasswordInterface * passwordInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a Password interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfacePasswordInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd2bb2cfcb6239cfe5ebb3256cc4d118"></a><!-- doxytag: member="Tp::Channel::typeInterface" ref="cd2bb2cfcb6239cfe5ebb3256cc4d118" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; class Interface &gt; Interface * typeInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a pointer to a valid instance of a given Channel type interface class, associated with the same remote object the <a class="el" href="classTp_1_1Channel.html">Channel</a> is associated with, and destroyed together with the <a class="el" href="classTp_1_1Channel.html">Channel</a>.<p>
If the interface name returned by <a class="el" href="classTp_1_1Channel.html#a562543eec8e4278c8d8e404a882f698">channelType()</a> isn't equivalent to the name of the requested interface, or the <a class="el" href="classTp_1_1Channel.html">Channel</a> is not ready, <code>0</code> is returned. This check can be bypassed by specifying <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f116d19701558688a6a6076468d349851">BypassInterfaceCheck</a> for <code>check</code>, in which case a valid instance is always returned.<p>
Convenience functions are provided for well-known channel types. However, there is no convenience getter for TypeContactList because the proxy for that interface doesn't actually have any functionality.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e2e7a0668bea89bb078c737ea83b42e4">OptionalInterfaceFactory::interface</a></dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Interface</em>&nbsp;</td><td>Class of the optional interface to get. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Should an instance be returned even if it can't be determined that the remote object is of the requested channel type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to an instance of the interface class, or <code>0</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="574314a89fba8679e17b19e94ca48a2c"></a><!-- doxytag: member="Tp::Channel::roomListInterface" ref="574314a89fba8679e17b19e94ca48a2c" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelTypeRoomListInterface * roomListInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a TypeRoomList interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1Channel.html#cd2bb2cfcb6239cfe5ebb3256cc4d118">typeInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>typeInterface&lt;ChannelTypeRoomListInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="849f4722aff2652803f458047cdd9bd0"></a><!-- doxytag: member="Tp::Channel::streamedMediaInterface" ref="849f4722aff2652803f458047cdd9bd0" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelTypeStreamedMediaInterface * streamedMediaInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a TypeStreamedMedia interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1Channel.html#cd2bb2cfcb6239cfe5ebb3256cc4d118">typeInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>typeInterface&lt;ChannelTypeStreamedMediaInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3ddb108708826242ba4f31871caf7c8"></a><!-- doxytag: member="Tp::Channel::textInterface" ref="c3ddb108708826242ba4f31871caf7c8" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelTypeTextInterface * textInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a TypeText interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1Channel.html#cd2bb2cfcb6239cfe5ebb3256cc4d118">typeInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>typeInterface&lt;ChannelTypeTextInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="efe20e2d68067926280cb16cbe0b29f8"></a><!-- doxytag: member="Tp::Channel::tubesInterface" ref="efe20e2d68067926280cb16cbe0b29f8" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelTypeTubesInterface * tubesInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a TypeTubes interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1Channel.html#cd2bb2cfcb6239cfe5ebb3256cc4d118">typeInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>typeInterface&lt;ChannelTypeTubesInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0fadf9667c8aa6732c3ad0705e7a4cbc"></a><!-- doxytag: member="Tp::Channel::groupFlagsChanged" ref="0fadf9667c8aa6732c3ad0705e7a4cbc" args="(uint flags, uint added, uint removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupFlagsChanged           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>removed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emitted when the value returned by <a class="el" href="classTp_1_1Channel.html#7c3bf7d8004b19cf59c0fab3f933ce66">groupFlags()</a> changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The value which would now be returned by <a class="el" href="classTp_1_1Channel.html#7c3bf7d8004b19cf59c0fab3f933ce66">groupFlags()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>added</em>&nbsp;</td><td>Flags added compared to the previous value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>removed</em>&nbsp;</td><td>Flags removed compared to the previous value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa3e4efaeab550e78798458bfaddda07"></a><!-- doxytag: member="Tp::Channel::groupCanAddContactsChanged" ref="aa3e4efaeab550e78798458bfaddda07" args="(bool canAddContacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupCanAddContactsChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>canAddContacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="90bfbdfa1808d6d82a52ec157757d331"></a><!-- doxytag: member="Tp::Channel::groupCanRemoveContactsChanged" ref="90bfbdfa1808d6d82a52ec157757d331" args="(bool canRemoveContacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupCanRemoveContactsChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>canRemoveContacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="daf8c439bdbf37c168bab45ebc217f83"></a><!-- doxytag: member="Tp::Channel::groupCanRescindContactsChanged" ref="daf8c439bdbf37c168bab45ebc217f83" args="(bool canRescindContacts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupCanRescindContactsChanged           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>canRescindContacts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="434d0ec9e98866789f37441b054d3660"></a><!-- doxytag: member="Tp::Channel::groupMembersChanged" ref="434d0ec9e98866789f37441b054d3660" args="(const Tp::Contacts &amp;groupMembersAdded, const Tp::Contacts &amp;groupLocalPendingMembersAdded, const Tp::Contacts &amp;groupRemotePendingMembersAdded, const Tp::Contacts &amp;groupMembersRemoved, const Tp::Channel::GroupMemberChangeDetails &amp;details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupMembersChanged           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupMembersAdded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupLocalPendingMembersAdded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupRemotePendingMembersAdded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceTp.html#7583feb9ccc05d63136cbb3b58897fb2">Tp::Contacts</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupMembersRemoved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTp_1_1Channel_1_1GroupMemberChangeDetails.html">Tp::Channel::GroupMemberChangeDetails</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>details</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emitted when the value returned by <a class="el" href="classTp_1_1Channel.html#c07446161a375eb940600e37582eee9f">groupContacts()</a>, <a class="el" href="classTp_1_1Channel.html#fc3e4a717febd9765b6f9204d0734a37">groupLocalPendingContacts()</a> or <a class="el" href="classTp_1_1Channel.html#eea564f8a4125f42e071d92a885564ab">groupRemotePendingContacts()</a> changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>groupMembersAdded</em>&nbsp;</td><td>The contacts that were added to this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupLocalPendingMembersAdded</em>&nbsp;</td><td>The local pending contacts that were added to this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupRemotePendingMembersAdded</em>&nbsp;</td><td>The remote pending contacts that were added to this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupMembersRemoved</em>&nbsp;</td><td>The contacts removed from this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>details</em>&nbsp;</td><td>Additional details such as the contact requesting or causing the change. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be6d68fb9782467019688c4958162054"></a><!-- doxytag: member="Tp::Channel::groupHandleOwnersChanged" ref="be6d68fb9782467019688c4958162054" args="(const Tp::HandleOwnerMap &amp;owners, const Tp::UIntList &amp;added, const Tp::UIntList &amp;removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupHandleOwnersChanged           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTp_1_1HandleOwnerMap.html">Tp::HandleOwnerMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>owners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>added</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>removed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emitted when the value returned by <a class="el" href="classTp_1_1Channel.html#8a4414a993738c1e9b1c2ae04b32d0e6">groupHandleOwners()</a> changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owners</em>&nbsp;</td><td>The value which would now be returned by <a class="el" href="classTp_1_1Channel.html#8a4414a993738c1e9b1c2ae04b32d0e6">groupHandleOwners()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>added</em>&nbsp;</td><td>Handles which have been added to the mapping as keys, or existing handle keys for which the mapped-to value has changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>removed</em>&nbsp;</td><td>Handles which have been removed from the mapping. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ebd8c47984b6f5a4a69f31996901d75c"></a><!-- doxytag: member="Tp::Channel::groupSelfContactChanged" ref="ebd8c47984b6f5a4a69f31996901d75c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void groupSelfContactChanged           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Emitted when the value returned by <a class="el" href="classTp_1_1Channel.html#bfe23d19b4b566bfebfcd5ab776b4786">groupSelfContact()</a> changes. 
</div>
</div><p>
<a class="anchor" name="be1dc2d17ba74769e3c93dc5a975bf57"></a><!-- doxytag: member="Tp::Channel::baseInterface" ref="be1dc2d17ba74769e3c93dc5a975bf57" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ChannelInterface.html">Client::ChannelInterface</a> * baseInterface           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the ChannelInterface for this <a class="el" href="classTp_1_1Channel.html">Channel</a> class. This method is protected since the convenience methods provided by this class should always be used instead of the interface by users of the class.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the existing ChannelInterface for this <a class="el" href="classTp_1_1Channel.html">Channel</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="42d6344939de8c2c06914b334fc53ed1"></a><!-- doxytag: member="Tp::Channel::groupInterface" ref="42d6344939de8c2c06914b334fc53ed1" args="(InterfaceSupportedChecking check=CheckInterfaceSupported) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChannelInterfaceGroupInterface * groupInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1OptionalInterfaceFactory.html#e27b733a11221b695fcc5f6dfdff740f">InterfaceSupportedChecking</a>&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>CheckInterfaceSupported</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience function for getting a Group interface proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Passed to <a class="el" href="classTp_1_1OptionalInterfaceFactory.html#ca25b29cd005986b55851ae6891cd2a2">optionalInterface()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>optionalInterface&lt;ChannelInterfaceGroupInterface&gt;(check)</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb16b08500593600376d6dbc5f380465"></a><!-- doxytag: member="Tp::Channel::groupSelfHandleIsLocalPending" ref="cb16b08500593600376d6dbc5f380465" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool groupSelfHandleIsLocalPending           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether the local user is in the "local pending" state. This indicates that the local user needs to take action to accept an invitation, an incoming call, etc.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the local user is in this channel's local-pending set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ce5d469553bca13127eb274d3760687"></a><!-- doxytag: member="Tp::Channel::groupAddSelfHandle" ref="1ce5d469553bca13127eb274d3760687" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1PendingOperation.html">PendingOperation</a> * groupAddSelfHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to add the local user to this channel. In some channel types, such as Text and StreamedMedia, this is used to accept an invitation or an incoming call.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pending operation which will emit finished on success or failure </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="5000fb4b8588d0f682acb4f35f0fb94c"></a><!-- doxytag: member="Tp::Channel::FeatureCore" ref="5000fb4b8588d0f682acb4f35f0fb94c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTp_1_1Feature.html">Feature</a> <a class="el" href="classTp_1_1Channel.html#5000fb4b8588d0f682acb4f35f0fb94c">FeatureCore</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
