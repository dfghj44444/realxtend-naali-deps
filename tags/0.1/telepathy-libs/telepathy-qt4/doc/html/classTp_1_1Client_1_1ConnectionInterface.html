<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4: ConnectionInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><a class="el" href="namespaceTp.html">Tp</a>::<a class="el" href="namespaceTp_1_1Client.html">Client</a>::<a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a>
  </div>
<div class="contents">
<h1>ConnectionInterface Class Reference<br>
<small>
[<a class="el" href="group__clientconn.html">Connection proxies</a>]</small>
</h1><!-- doxytag: class="Tp::Client::ConnectionInterface" --><!-- doxytag: inherits="Tp::AbstractInterface" --><code>#include &lt;<a class="el" href="cli-connection_8h_source.html">TelepathyQt4/Connection</a>&gt;</code>
<p>
Inherits <a class="el" href="classTp_1_1AbstractInterface.html">Tp::AbstractInterface</a>.
<p>

<p>
<a href="classTp_1_1Client_1_1ConnectionInterface-members.html">List of all members.</a><h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#a73c2af963fc07df5c3bd28f4b3fa69d">Connect</a> ()
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#c844b2b0d95281b492da6483039e8502">Disconnect</a> ()
<li>QDBusPendingReply&lt; QStringList &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#26c2973ffb797ed7628090d1a38d2bf9">GetInterfaces</a> ()
<li>QDBusPendingReply&lt; QString &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#06b1ba0d0deaa837d5c9a1962817e005">GetProtocol</a> ()
<li>QDBusPendingReply&lt; uint &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#2e4bb4c7f6eab472f28bb98894562726">GetSelfHandle</a> ()
<li>QDBusPendingReply&lt; uint &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#3fee519a5ef1d2b0271efce3f39f7851">GetStatus</a> ()
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#0b3b0efc8dc7149b8e7650439ab64f95">HoldHandles</a> (uint handleType, const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;handles)
<li>QDBusPendingReply&lt; QStringList &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#78f92eb07da3c693463370565da8e45d">InspectHandles</a> (uint handleType, const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;handles)
<li>QDBusPendingReply<br class="typebreak">
&lt; <a class="el" href="group__list.html#g8cf8046d4693498f039cbbae9648bf5f">Tp::ChannelInfoList</a> &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#3e3e566c32ed86d17edb9ae8475ba156">ListChannels</a> ()
<li>QDBusPendingReply <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#5c1e2eb2cb21e2f9ef7b3f83ad7f1608">ReleaseHandles</a> (uint handleType, const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;handles)
<li>QDBusPendingReply<br class="typebreak">
&lt; QDBusObjectPath &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#015f82f42445977478d346bb2eed2e47">RequestChannel</a> (const QString &amp;type, uint handleType, uint handle, bool suppressHandler)
<li>QDBusPendingReply&lt; <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &gt; <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#8f266b518051ae2cf78e289e9639f275">RequestHandles</a> (uint handleType, const QStringList &amp;names)
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#ab08ff79112f7c1cdc132a71313dee46">SelfHandleChanged</a> (uint selfHandle)
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#291cf9ec957988e6ddb1194363c70985">NewChannel</a> (const QDBusObjectPath &amp;objectPath, const QString &amp;channelType, uint handleType, uint handle, bool suppressHandler)
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#c33090076844f3a7b47a8fad67fe687e">ConnectionError</a> (const QString &amp;error, const QVariantMap &amp;details)
<li>void <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#13fb1a8313345bae9d509412ffe5d306">StatusChanged</a> (uint status, uint reason)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#387700fe4d932f05666d34560d7e4c1f">ConnectionInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#267291e767b561467c55b57d7efcc3c9">ConnectionInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#f9ef417a2a170aef86957242768c40ba">ConnectionInterface</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *proxy)
<li>uint <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#cc7b71c4fb769e426827e6a91e780393">SelfHandle</a> () const TELEPATHY_GNUC_DEPRECATED
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static const char * <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#a7e5232c84bbd53120bc9420a83a8d85">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#53b1ec43eceb0fe521c383dbd9d9d21d">invalidate</a> (<a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *, const QString &amp;, const QString &amp;)
</ul>
<h2>Properties</h2>
<ul>
<li>uint <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html#8002e2b5784899f95e8832f4b5385eeb">SelfHandle</a>
</ul>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection." <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="387700fe4d932f05666d34560d7e4c1f"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ConnectionInterface" ref="387700fe4d932f05666d34560d7e4c1f" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a> associated with the given object on the session bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="267291e767b561467c55b57d7efcc3c9"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ConnectionInterface" ref="267291e767b561467c55b57d7efcc3c9" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a>           </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a> associated with the given object on the given bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9ef417a2a170aef86957242768c40ba"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ConnectionInterface" ref="f9ef417a2a170aef86957242768c40ba" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classTp_1_1Client_1_1ConnectionInterface.html">ConnectionInterface</a> associated with the same object as the given proxy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a7e5232c84bbd53120bc9420a83a8d85"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::staticInterfaceName" ref="a7e5232c84bbd53120bc9420a83a8d85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* staticInterfaceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the interface "org.freedesktop.Telepathy.Connection", which this class represents.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc7b71c4fb769e426827e6a91e780393"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::SelfHandle" ref="cc7b71c4fb769e426827e6a91e780393" args="() const TELEPATHY_GNUC_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint SelfHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Getter for the remote object property "SelfHandle".<p>
Don't use this: it blocks the main loop.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or a default-constructed value if the property is not readable. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a73c2af963fc07df5c3bd28f4b3fa69d"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::Connect" ref="a73c2af963fc07df5c3bd28f4b3fa69d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Connect           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "Connect" on the remote object.<p>
Request that the connection be established. This will be done asynchronously and errors will be returned by emitting &lt;tp:member-ref&gt;StatusChanged&lt;/tp:member-ref&gt; signals.<p>
Calling this method on a <a class="el" href="classTp_1_1Connection.html">Connection</a> that is already connecting or connected is allowed, and has no effect. 
</div>
</div><p>
<a class="anchor" name="c844b2b0d95281b492da6483039e8502"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::Disconnect" ref="c844b2b0d95281b492da6483039e8502" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Disconnect           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "Disconnect" on the remote object.<p>
Request that the connection be closed. This closes the connection if it's not already in DISCONNECTED state, and destroys the connection object. 
</div>
</div><p>
<a class="anchor" name="26c2973ffb797ed7628090d1a38d2bf9"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::GetInterfaces" ref="26c2973ffb797ed7628090d1a38d2bf9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QStringList&gt; GetInterfaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetInterfaces" on the remote object.<p>
Get the optional interfaces supported by this connection. Before the connection status changes to CONNECTED, the return from this method may change at any time, but it is guaranteed that interfaces will only be added, not removed. After the connection status changes to CONNECTED, the return from this method cannot change further.<p>
There is no explicit change notification; reasonable behaviour for a client would be to retrieve the interfaces list once initially, and once more when it becomes CONNECTED.<p>
&lt;tp:rationale&gt; <p>
In some connection managers, certain capabilities of a connection are known to be implemented for all connections (e.g. support for <a class="el" href="structTp_1_1SimplePresence.html">SimplePresence</a>), and some interfaces (like <a class="el" href="structTp_1_1SimplePresence.html">SimplePresence</a>) can even be used before connecting. Other capabilities may or may not exist, depending on server functionality; by the time the connection goes CONNECTED, the connection manager is expected to have evaluated the server's functionality and enabled any extra interfaces for the remainder of the Connection's lifetime. &lt;/tp:rationale&gt;<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An array of D-Bus interface names 
</div>
</div><p>
<a class="anchor" name="06b1ba0d0deaa837d5c9a1962817e005"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::GetProtocol" ref="06b1ba0d0deaa837d5c9a1962817e005" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QString&gt; GetProtocol           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetProtocol" on the remote object.<p>
Get the protocol this connection is using.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
A string identifier for the protocol 
</div>
</div><p>
<a class="anchor" name="2e4bb4c7f6eab472f28bb98894562726"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::GetSelfHandle" ref="2e4bb4c7f6eab472f28bb98894562726" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;uint&gt; GetSelfHandle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetSelfHandle" on the remote object.<p>
Returns the value of the SelfHandle property. Change notification is via the SelfHandleChanged signal.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The value of the SelfHandle property 
</div>
</div><p>
<a class="anchor" name="3fee519a5ef1d2b0271efce3f39f7851"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::GetStatus" ref="3fee519a5ef1d2b0271efce3f39f7851" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;uint&gt; GetStatus           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "GetStatus" on the remote object.<p>
Get the current status as defined in the StatusChanged signal.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An integer representing the current status 
</div>
</div><p>
<a class="anchor" name="0b3b0efc8dc7149b8e7650439ab64f95"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::HoldHandles" ref="0b3b0efc8dc7149b8e7650439ab64f95" args="(uint handleType, const Tp::UIntList &amp;handles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply HoldHandles           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "HoldHandles" on the remote object.<p>
Notify the connection manger that your client is holding a copy of handles which may not be in use in any existing channel or list, and were not obtained by using the &lt;tp:member-ref&gt;RequestHandles&lt;/tp:member-ref&gt; method. For example, a handle observed in an emitted signal, or displayed somewhere in the UI that is not associated with a channel. The connection manager must not deallocate a handle where any clients have used this method to indicate it is in use until the &lt;tp:member-ref&gt;ReleaseHandles&lt;/tp:member-ref&gt; method is called, or the clients disappear from the bus.<p>
Note that HoldHandles is idempotent - calling it multiple times is equivalent to calling it once. If a handle is "referenced" by several components which share a D-Bus unique name, the client should perform reference counting internally, and only call ReleaseHandles when none of the cooperating components need the handle any longer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>The type of handle to be held</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handles</em>&nbsp;</td><td>A array of integer handles to hold </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="78f92eb07da3c693463370565da8e45d"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::InspectHandles" ref="78f92eb07da3c693463370565da8e45d" args="(uint handleType, const Tp::UIntList &amp;handles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QStringList&gt; InspectHandles           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "InspectHandles" on the remote object.<p>
Return a string representation for a number of handles of a given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>The type of handle to be inspected</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handles</em>&nbsp;</td><td>An array of integer handles of this type</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An array of handle names in the same order as the given numbers 
</div>
</div><p>
<a class="anchor" name="3e3e566c32ed86d17edb9ae8475ba156"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ListChannels" ref="3e3e566c32ed86d17edb9ae8475ba156" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;<a class="el" href="group__list.html#g8cf8046d4693498f039cbbae9648bf5f">Tp::ChannelInfoList</a>&gt; ListChannels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "ListChannels" on the remote object.<p>
List all the channels which currently exist on this connection.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An array of structs representing channels. 
</div>
</div><p>
<a class="anchor" name="5c1e2eb2cb21e2f9ef7b3f83ad7f1608"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ReleaseHandles" ref="5c1e2eb2cb21e2f9ef7b3f83ad7f1608" args="(uint handleType, const Tp::UIntList &amp;handles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply ReleaseHandles           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "ReleaseHandles" on the remote object.<p>
Explicitly notify the connection manager that your client is no longer holding any references to the given handles, and that they may be deallocated if they are not held by any other clients or referenced by any existing channels. See HoldHandles for notes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>An integer handle type (as defined in RequestHandle)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handles</em>&nbsp;</td><td>An array of integer handles being held by the client </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="015f82f42445977478d346bb2eed2e47"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::RequestChannel" ref="015f82f42445977478d346bb2eed2e47" args="(const QString &amp;type, uint handleType, uint handle, bool suppressHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QDBusObjectPath&gt; RequestChannel           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppressHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "RequestChannel" on the remote object.<p>
Request a channel satisfying the specified type and communicating with the contact, room, list etc. indicated by the given handle_type and handle. The handle_type and handle may both be zero to request the creation of a new, empty channel, which may or may not be possible, depending on the protocol and channel type.<p>
On success, the returned channel will always be of the requested type (i.e. implement the requested channel-type interface).<p>
If a new, empty channel is requested, on success the returned channel will always be an "anonymous" channel for which the type and handle are both zero.<p>
If a channel to a contact, room etc. is requested, on success, the returned channel may either be a new or existing channel to the requested entity (i.e. its &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel"&gt;TargetHandleType&lt;/tp:dbus-ref&gt; and &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel"&gt;TargetHandle&lt;/tp:dbus-ref&gt; properties are the requested handle type and handle), or a newly created "anonymous" channel associated with the requested handle in some implementation-specific way.<p>
For example, for a contact handle, the returned channel might be "anonymous", but implement the groups interface and have the requested contact already present among the members.<p>
If the request cannot be satisfied, an error is raised and no channel is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A D-Bus interface name representing base channel type</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>An integer representing the handle type, or Handle_Type_None if no handle is specified</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A nonzero integer handle representing a contact, room, list etc. according to handle_type, or zero if the handle_type is Handle_Type_None</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suppressHandler</em>&nbsp;</td><td>Clients SHOULD always set this to true. The historical meaning was that clients that did not intend to take responsibility for displaying the channel to the user could set this to FALSE, in which case the channel dispatcher would launch an appropriate channel handler. However, clients whose functionality relies on having a working channel dispatcher should obtain that functionality by calling methods on the channel dispatcher, so that they will get an appropriate error if the channel dispatcher is missing or not working. The channel dispatcher itself should set this to true too, so that it will ignore the NewChannel signal that results from the creation of the channel. It can then dispatch the channel returned from this method to an appropriate handler. So, there is no sensible use-case for setting this to false, and setting it to false can result in unhandled channels (in the case where clients assume that a channel dispatcher is present, but it isn't).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
The D-Bus object path for the channel created or retrieved 
</div>
</div><p>
<a class="anchor" name="8f266b518051ae2cf78e289e9639f275"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::RequestHandles" ref="8f266b518051ae2cf78e289e9639f275" args="(uint handleType, const QStringList &amp;names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;<a class="el" href="structTp_1_1UIntList.html">Tp::UIntList</a>&gt; RequestHandles           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QStringList &amp;&nbsp;</td>
          <td class="paramname"> <em>names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Begins a call to the D-Bus method "RequestHandles" on the remote object.<p>
Request several handles from the connection manager which represent a number of contacts, rooms or server-stored lists on the service. The connection manager should record that these handles are in use by the client who invokes this method, and must not deallocate the handles until the client disconnects from the bus or calls the ReleaseHandles method. Where the name refers to an entity that already has a handle in this connection manager, this handle should be returned instead. The handle number 0 must not be returned by the connection manager.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>The type of handle required</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>An array of names of entities to request handles for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd></dd></dl>
An array of integer handle numbers in the same order as the given strings 
</div>
</div><p>
<a class="anchor" name="ab08ff79112f7c1cdc132a71313dee46"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::SelfHandleChanged" ref="ab08ff79112f7c1cdc132a71313dee46" args="(uint selfHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SelfHandleChanged           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>selfHandle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "SelfHandleChanged" on the remote object.<p>
Emitted whenever the SelfHandle property changes. If the connection is not yet in the CONNECTED state, this signal is not guaranteed to be emitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selfHandle</em>&nbsp;</td><td>The new value of the SelfHandle property. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="291cf9ec957988e6ddb1194363c70985"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::NewChannel" ref="291cf9ec957988e6ddb1194363c70985" args="(const QDBusObjectPath &amp;objectPath, const QString &amp;channelType, uint handleType, uint handle, bool suppressHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewChannel           </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>channelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppressHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "NewChannel" on the remote object.<p>
Emitted when a new <a class="el" href="classTp_1_1Channel.html">Channel</a> object is created, either through user request or incoming information from the service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>A D-Bus object path for the channel object on this service</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelType</em>&nbsp;</td><td>A D-Bus interface name representing the channel type</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handleType</em>&nbsp;</td><td>An integer representing the type of handle this channel communicates with, or Handle_Type_None if no handle is specified</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>A handle indicating the specific contact, room or list this channel communicates with, or zero if no handle is specified</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suppressHandler</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
If true, the channel was requested by a client that intends to present it to the user itself (i.e. it passed suppress_handler=TRUE to the &lt;tp:member-ref&gt;RequestChannel&lt;/tp:member-ref&gt; method), so no other handler should be launched. Clients MAY assume that channels where this is true were created by a user request.<p>
If false, either the channel was created due to incoming information from the service, or the channel was requested by a local client that does not intend to handle the channel itself (this usage is deprecated).<p>
Clients MUST NOT assume that only incoming channels will have this flag set to false. 
</div>
</div><p>
<a class="anchor" name="c33090076844f3a7b47a8fad67fe687e"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::ConnectionError" ref="c33090076844f3a7b47a8fad67fe687e" args="(const QString &amp;error, const QVariantMap &amp;details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConnectionError           </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>details</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "ConnectionError" on the remote object.<p>
Emitted when an error occurs that renders this connection unusable. <p>
Whenever this signal is emitted, it MUST immediately be followed by a &lt;tp:member-ref&gt;StatusChanged&lt;/tp:member-ref&gt; signal with status Connection_Status_Reason_Disconnected and an appropriate reason code.<p>
<a class="el" href="classTp_1_1Connection.html">Connection</a> managers SHOULD emit this signal on disconnection, but need not do so. Clients MUST support connection managers that emit StatusChanged(Disconnected, ...) without first emitting ConnectionError.<p>
&lt;tp:rationale&gt; <p>
This signal provides additional information about the reason for disconnection. The reason for connection is always straightforward - it was requested - so it does not need further explanation. However, on errors, it can be useful to provide additional information.<p>
The &lt;tp:type&gt;Connection_Status_Reason&lt;/tp:type&gt; is not given here, since it will be signalled in &lt;tp:member-ref&gt;StatusChanged&lt;/tp:member-ref&gt;. A reasonable client implementation would be to store the information given by this signal until StatusChanged is received, at which point the information given by this signal can be used to supplement the StatusChanged signal. &lt;/tp:rationale&gt;<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>The name of a D-Bus error describing the error that occurred, which may correspond to a Connection_Status_Reason or be a protocol-specific or connection-manager-specific error in a suitable namespace. For instance, a SIP connection manager could signal "402 Payment Required" as an error in a connection-manager-specific namespace, or a link-local XMPP implementation that used Avahi could provide the error given to it by the avahi-daemon.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>details</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
Additional information about the error, which may include the following well-known keys:<p>
<dl>
<dt>debug-message (s) </dt>
<dd>Debugging information on the change, corresponding to the message part of a D-Bus error message, which SHOULD NOT be displayed to users under normal circumstances </dd>
</dl>
<p>
&lt;tp:rationale&gt; <p>
This argument allows for future extensions. For instance, if indicating DNS lookup failure, we could define a key that indicates the hostname that could not be found. &lt;/tp:rationale&gt; 
</div>
</div><p>
<a class="anchor" name="13fb1a8313345bae9d509412ffe5d306"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::StatusChanged" ref="13fb1a8313345bae9d509412ffe5d306" args="(uint status, uint reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StatusChanged           </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents the signal "StatusChanged" on the remote object.<p>
Emitted when the status of the connection changes. All states and reasons have numerical values, as defined in ConnectionStatus and ConnectionStatusReason.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>An integer indicating the new status, as defined by ConnectionStatus</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>An integer indicating the reason for the status change, as defined by ConnectionStatusReason </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="53b1ec43eceb0fe521c383dbd9d9d21d"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::invalidate" ref="53b1ec43eceb0fe521c383dbd9d9d21d" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invalidate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTp_1_1DBusProxy.html">Tp::DBusProxy</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classTp_1_1AbstractInterface.html#c5b212870f70b2bdde8776c87f91b8d2">AbstractInterface</a>.</p>

</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="8002e2b5784899f95e8832f4b5385eeb"></a><!-- doxytag: member="Tp::Client::ConnectionInterface::SelfHandle" ref="8002e2b5784899f95e8832f4b5385eeb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint SelfHandle<code> [read]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Represents property "SelfHandle" on the remote object.<p>
The handle which represents the user on this connection, which will remain valid for the lifetime of this connection, or until a change in the user's identifier is signalled by the SelfHandleChanged signal. If the connection is not yet in the CONNECTED state, the value of this property MAY be zero. 
</div>
</div><p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2009 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4 0.1.10</div></td>
</tr></table></div></address>
</body>
</html>
