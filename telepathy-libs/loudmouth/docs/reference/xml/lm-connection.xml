<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="loudmouth-lm-connection">
<refmeta>
<refentrytitle role="top_of_page" id="loudmouth-lm-connection.top_of_page">LmConnection</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LOUDMOUTH Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>LmConnection</refname>
<refpurpose>A client connection to the server</refpurpose>
</refnamediv>

<refsynopsisdiv id="loudmouth-lm-connection.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>
#define             <link linkend="LM-CONNECTION--CAPS">LM_CONNECTION</link>                       (o)
#define             <link linkend="LM-CONNECTION-DEFAULT-PORT--CAPS">LM_CONNECTION_DEFAULT_PORT</link>
#define             <link linkend="LM-CONNECTION-DEFAULT-PORT-SSL--CAPS">LM_CONNECTION_DEFAULT_PORT_SSL</link>
                    <link linkend="LmConnection">LmConnection</link>;
enum                <link linkend="LmHandlerResult">LmHandlerResult</link>;
enum                <link linkend="LmHandlerPriority">LmHandlerPriority</link>;
enum                <link linkend="LmDisconnectReason">LmDisconnectReason</link>;
enum                <link linkend="LmConnectionState">LmConnectionState</link>;
<link linkend="void">void</link>                (<link linkend="LmResultFunction">*LmResultFunction</link>)                 (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="gboolean">gboolean</link> success,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                (<link linkend="LmDisconnectFunction">*LmDisconnectFunction</link>)             (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmDisconnectReason">LmDisconnectReason</link> reason,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="LmConnection">LmConnection</link> *      <link linkend="lm-connection-new">lm_connection_new</link>                   (const <link linkend="gchar">gchar</link> *server);
<link linkend="LmConnection">LmConnection</link> *      <link linkend="lm-connection-new-with-context">lm_connection_new_with_context</link>      (const <link linkend="gchar">gchar</link> *server,
                                                         <link linkend="GMainContext">GMainContext</link> *context);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-open">lm_connection_open</link>                  (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmResultFunction">LmResultFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-open-and-block">lm_connection_open_and_block</link>        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-close">lm_connection_close</link>                 (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-authenticate">lm_connection_authenticate</link>          (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *username,
                                                         const <link linkend="gchar">gchar</link> *password,
                                                         const <link linkend="gchar">gchar</link> *resource,
                                                         <link linkend="LmResultFunction">LmResultFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-authenticate-and-block">lm_connection_authenticate_and_block</link>
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *username,
                                                         const <link linkend="gchar">gchar</link> *password,
                                                         const <link linkend="gchar">gchar</link> *resource,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="guint">guint</link>               <link linkend="lm-connection-get-keep-alive-rate">lm_connection_get_keep_alive_rate</link>   (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-keep-alive-rate">lm_connection_set_keep_alive_rate</link>   (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="guint">guint</link> rate);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-is-open">lm_connection_is_open</link>               (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-is-authenticated">lm_connection_is_authenticated</link>      (<link linkend="LmConnection">LmConnection</link> *connection);
const <link linkend="gchar">gchar</link> *       <link linkend="lm-connection-get-server">lm_connection_get_server</link>            (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-server">lm_connection_set_server</link>            (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *server);
const <link linkend="gchar">gchar</link> *       <link linkend="lm-connection-get-jid">lm_connection_get_jid</link>               (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-jid">lm_connection_set_jid</link>               (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *jid);
<link linkend="guint">guint</link>               <link linkend="lm-connection-get-port">lm_connection_get_port</link>              (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-port">lm_connection_set_port</link>              (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="guint">guint</link> port);
<link linkend="LmSSL">LmSSL</link> *             <link linkend="lm-connection-get-ssl">lm_connection_get_ssl</link>               (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-ssl">lm_connection_set_ssl</link>               (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmSSL">LmSSL</link> *ssl);
<link linkend="LmProxy">LmProxy</link> *           <link linkend="lm-connection-get-proxy">lm_connection_get_proxy</link>             (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-set-proxy">lm_connection_set_proxy</link>             (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmProxy">LmProxy</link> *proxy);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-send">lm_connection_send</link>                  (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-send-with-reply">lm_connection_send_with_reply</link>       (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="LmMessage">LmMessage</link> *         <link linkend="lm-connection-send-with-reply-and-block">lm_connection_send_with_reply_and_block</link>
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="lm-connection-register-message-handler">lm_connection_register_message_handler</link>
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="LmMessageType">LmMessageType</link> type,
                                                         <link linkend="LmHandlerPriority">LmHandlerPriority</link> priority);
<link linkend="void">void</link>                <link linkend="lm-connection-unregister-message-handler">lm_connection_unregister_message_handler</link>
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="LmMessageType">LmMessageType</link> type);
<link linkend="void">void</link>                <link linkend="lm-connection-set-disconnect-function">lm_connection_set_disconnect_function</link>
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmDisconnectFunction">LmDisconnectFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify);
<link linkend="gboolean">gboolean</link>            <link linkend="lm-connection-send-raw">lm_connection_send_raw</link>              (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *str,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="LmConnectionState">LmConnectionState</link>   <link linkend="lm-connection-get-state">lm_connection_get_state</link>             (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="LmConnection">LmConnection</link>*       <link linkend="lm-connection-ref">lm_connection_ref</link>                   (<link linkend="LmConnection">LmConnection</link> *connection);
<link linkend="void">void</link>                <link linkend="lm-connection-unref">lm_connection_unref</link>                 (<link linkend="LmConnection">LmConnection</link> *connection);
</synopsis>
</refsynopsisdiv>









<refsect1 id="loudmouth-lm-connection.description" role="desc">
<title role="desc.title">Description</title>
<para>
An example of how to use Loudmouth with the synchronous API.
<informalexample><programlisting>
int
main (int argc, char **argv)
{
        LmConnection *connection;
        GError       *error = NULL;
        gint          i;
	LmMessage    *m;
        connection = lm_connection_new ("myserver");
        if (!lm_connection_open_and_block (connection, &amp;error)) {
                g_error ("Failed to open: &percnt;s\n", error->message);
        }
	if (!lm_connection_authenticate_and_block (connection,
						   "username", "password",
						   "resource",
						   &amp;error)) {
		g_error ("Failed to authenticate: &percnt;s\n", error->message);
	}
	m = lm_message_new ("recipient", LM_MESSAGE_TYPE_MESSAGE);
	lm_message_node_add_child (m->node, "body", "message");
	if (!lm_connection_send (connection, m, &amp;error)) {
		g_error ("Send failed: &percnt;s\n", error->message);
	}
	lm_message_unref (m);
	lm_connection_close (connection, NULL);
	lm_connection_unref (connection);
        return 0;
}
</programlisting></informalexample>
</para>
</refsect1>

<refsect1 id="loudmouth-lm-connection.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="LM-CONNECTION--CAPS" role="macro">
<title>LM_CONNECTION()</title>
<indexterm zone="LM-CONNECTION--CAPS"><primary sortas="LM_CONNECTION">LM_CONNECTION</primary></indexterm><programlisting>#define LM_CONNECTION(o) (LmConnection *) o;
</programlisting>
<para>
Convenience macro used to cast a pointer to a <link linkend="LmConnection"><type>LmConnection</type></link>.
</para><variablelist role="params">
<varlistentry><term><parameter>o</parameter>&#160;:</term>
<listitem><simpara>pointer to cast
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="LM-CONNECTION-DEFAULT-PORT--CAPS" role="macro">
<title>LM_CONNECTION_DEFAULT_PORT</title>
<indexterm zone="LM-CONNECTION-DEFAULT-PORT--CAPS"><primary sortas="LM_CONNECTION_DEFAULT_PORT">LM_CONNECTION_DEFAULT_PORT</primary></indexterm><programlisting>#define LM_CONNECTION_DEFAULT_PORT     5222
</programlisting>
<para>
Default jabber client port.
</para></refsect2>
<refsect2 id="LM-CONNECTION-DEFAULT-PORT-SSL--CAPS" role="macro">
<title>LM_CONNECTION_DEFAULT_PORT_SSL</title>
<indexterm zone="LM-CONNECTION-DEFAULT-PORT-SSL--CAPS"><primary sortas="LM_CONNECTION_DEFAULT_PORT_SSL">LM_CONNECTION_DEFAULT_PORT_SSL</primary></indexterm><programlisting>#define LM_CONNECTION_DEFAULT_PORT_SSL 5223
</programlisting>
<para>
Default jabber client port when using SSL encryption.
</para></refsect2>
<refsect2 id="LmConnection" role="struct">
<title>LmConnection</title>
<indexterm zone="LmConnection"><primary sortas="LmConnection">LmConnection</primary></indexterm><programlisting>typedef struct _LmConnection LmConnection;</programlisting>
<para>
This should not be accessed directly. Use the accessor functions as described below.
</para></refsect2>
<refsect2 id="LmHandlerResult" role="enum">
<title>enum LmHandlerResult</title>
<indexterm zone="LmHandlerResult"><primary sortas="LmHandlerResult">LmHandlerResult</primary></indexterm><programlisting>typedef enum {
	LM_HANDLER_RESULT_REMOVE_MESSAGE,
	LM_HANDLER_RESULT_ALLOW_MORE_HANDLERS
} LmHandlerResult;
</programlisting>
<para>
The return type of an LmMessageHandler. This determines whether more message handlers should be called.
</para><variablelist role="enum">
<varlistentry id="LM-HANDLER-RESULT-REMOVE-MESSAGE--CAPS" role="constant">
<term><literal>LM_HANDLER_RESULT_REMOVE_MESSAGE</literal></term>
<listitem><simpara>Stop calling message handlers. The message handler returning this declares the message has been handled and should be removed.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-HANDLER-RESULT-ALLOW-MORE-HANDLERS--CAPS" role="constant">
<term><literal>LM_HANDLER_RESULT_ALLOW_MORE_HANDLERS</literal></term>
<listitem><simpara>Return to continue the calling handlers from the handler list. This declares that another handlers should handle the message.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="LmHandlerPriority" role="enum">
<title>enum LmHandlerPriority</title>
<indexterm zone="LmHandlerPriority"><primary sortas="LmHandlerPriority">LmHandlerPriority</primary></indexterm><programlisting>typedef enum {
	LM_HANDLER_PRIORITY_LAST   = 1,
	LM_HANDLER_PRIORITY_NORMAL = 2,
	LM_HANDLER_PRIORITY_FIRST  = 3
} LmHandlerPriority;
</programlisting>
<para>
Since the handlers decide whether to stop the calling chain with there return values it's sometimes decirable to be able to set priority. For example a handler that only logs all incoming messages and then pass the message on to another handler wants to have priority <link linkend="LM-HANDLER-PRIORITY-FIRST--CAPS"><literal>LM_HANDLER_PRIORITY_FIRST</literal></link>. An handler that should take all messages that wasn't handled by anything else would want to have priority <link linkend="LM-HANDLER-PRIORITY-LAST--CAPS"><literal>LM_HANDLER_PRIORITY_LAST</literal></link>. If several handlers have the same priority nothing can be said about the order the handlers will be called in.
</para><variablelist role="enum">
<varlistentry id="LM-HANDLER-PRIORITY-LAST--CAPS" role="constant">
<term><literal>LM_HANDLER_PRIORITY_LAST</literal></term>
<listitem><simpara>Call the handler after all handlers with <link linkend="NORMAL--CAPS"><type>NORMAL</type></link> and <link linkend="FIRST--CAPS"><type>FIRST</type></link> priority.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-HANDLER-PRIORITY-NORMAL--CAPS" role="constant">
<term><literal>LM_HANDLER_PRIORITY_NORMAL</literal></term>
<listitem><simpara>Called before handlers with priority <link linkend="LAST--CAPS"><type>LAST</type></link> and after those with <link linkend="FIRST--CAPS"><type>FIRST</type></link>.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-HANDLER-PRIORITY-FIRST--CAPS" role="constant">
<term><literal>LM_HANDLER_PRIORITY_FIRST</literal></term>
<listitem><simpara>These are called before all other handlers.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="LmDisconnectReason" role="enum">
<title>enum LmDisconnectReason</title>
<indexterm zone="LmDisconnectReason"><primary sortas="LmDisconnectReason">LmDisconnectReason</primary></indexterm><programlisting>typedef enum {
	LM_DISCONNECT_REASON_OK,
	LM_DISCONNECT_REASON_PING_TIME_OUT,
	LM_DISCONNECT_REASON_HUP,
	LM_DISCONNECT_REASON_ERROR,
	LM_DISCONNECT_REASON_RESOURCE_CONFLICT,
	LM_DISCONNECT_REASON_INVALID_XML,
	LM_DISCONNECT_REASON_UNKNOWN
} LmDisconnectReason;
</programlisting>
<para>
Sent with <link linkend="LmDisconnectFunction"><type>LmDisconnectFunction</type></link> to describe why a connection was closed.
</para><variablelist role="enum">
<varlistentry id="LM-DISCONNECT-REASON-OK--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_OK</literal></term>
<listitem><simpara>User requested disconnect.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-PING-TIME-OUT--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_PING_TIME_OUT</literal></term>
<listitem><simpara>Connection to the server timed out.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-HUP--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_HUP</literal></term>
<listitem><simpara>The socket emitted that the connection was hung up.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-ERROR--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_ERROR</literal></term>
<listitem><simpara>A generic error somewhere in the transport layer.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-RESOURCE-CONFLICT--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_RESOURCE_CONFLICT</literal></term>
<listitem><simpara>Another connection was made to the server with the same resource.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-INVALID-XML--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_INVALID_XML</literal></term>
<listitem><simpara>Invalid XML was sent from the client.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-DISCONNECT-REASON-UNKNOWN--CAPS" role="constant">
<term><literal>LM_DISCONNECT_REASON_UNKNOWN</literal></term>
<listitem><simpara>An unknown error.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="LmConnectionState" role="enum">
<title>enum LmConnectionState</title>
<indexterm zone="LmConnectionState"><primary sortas="LmConnectionState">LmConnectionState</primary></indexterm><programlisting>typedef enum {
	LM_CONNECTION_STATE_CLOSED,
	LM_CONNECTION_STATE_OPENING,
	LM_CONNECTION_STATE_OPEN,
	LM_CONNECTION_STATE_AUTHENTICATING,
	LM_CONNECTION_STATE_AUTHENTICATED
} LmConnectionState;
</programlisting>
<para>
Describes the current state of an <link linkend="LmConnection"><type>LmConnection</type></link>.
</para><variablelist role="enum">
<varlistentry id="LM-CONNECTION-STATE-CLOSED--CAPS" role="constant">
<term><literal>LM_CONNECTION_STATE_CLOSED</literal></term>
<listitem><simpara>The connection is closed.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-CONNECTION-STATE-OPENING--CAPS" role="constant">
<term><literal>LM_CONNECTION_STATE_OPENING</literal></term>
<listitem><simpara>The connection is in the process of opening.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-CONNECTION-STATE-OPEN--CAPS" role="constant">
<term><literal>LM_CONNECTION_STATE_OPEN</literal></term>
<listitem><simpara>The connection is open.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-CONNECTION-STATE-AUTHENTICATING--CAPS" role="constant">
<term><literal>LM_CONNECTION_STATE_AUTHENTICATING</literal></term>
<listitem><simpara>The connection is in the process of authenticating.
</simpara></listitem>
</varlistentry>
<varlistentry id="LM-CONNECTION-STATE-AUTHENTICATED--CAPS" role="constant">
<term><literal>LM_CONNECTION_STATE_AUTHENTICATED</literal></term>
<listitem><simpara>The connection is authenticated and is ready to start sending/receiving messages.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="LmResultFunction" role="function">
<title>LmResultFunction ()</title>
<indexterm zone="LmResultFunction"><primary sortas="LmResultFunction">LmResultFunction</primary></indexterm><programlisting><link linkend="void">void</link>                (*LmResultFunction)                 (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="gboolean">gboolean</link> success,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Callback for informing if an asynchronous operation was successful.
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara>an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>success</parameter>&#160;:</term>
<listitem><simpara>the result, <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if operation succeeded, otherwise <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>User data passed when function being called.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="LmDisconnectFunction" role="function">
<title>LmDisconnectFunction ()</title>
<indexterm zone="LmDisconnectFunction"><primary sortas="LmDisconnectFunction">LmDisconnectFunction</primary></indexterm><programlisting><link linkend="void">void</link>                (*LmDisconnectFunction)             (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmDisconnectReason">LmDisconnectReason</link> reason,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Callback called when a connection is closed.
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara>an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason</parameter>&#160;:</term>
<listitem><simpara>the reason the connection was closed.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>User data passed when function being called.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-new" role="function">
<title>lm_connection_new ()</title>
<indexterm zone="lm-connection-new"><primary sortas="lm_connection_new">lm_connection_new</primary></indexterm><programlisting><link linkend="LmConnection">LmConnection</link> *      lm_connection_new                   (const <link linkend="gchar">gchar</link> *server);</programlisting>
<para>
Creates a new closed connection. To open the connection call 
<link linkend="lm-connection-open"><function>lm_connection_open()</function></link>. <parameter>server</parameter> can be <link linkend="NULL--CAPS"><type>NULL</type></link> but must be set before calling <link linkend="lm-connection-open"><function>lm_connection_open()</function></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>server</parameter>&#160;:</term>
<listitem><simpara> The hostname to the server for the connection.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> A newly created LmConnection, should be unreffed with <link linkend="lm-connection-unref"><function>lm_connection_unref()</function></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-new-with-context" role="function">
<title>lm_connection_new_with_context ()</title>
<indexterm zone="lm-connection-new-with-context"><primary sortas="lm_connection_new_with_context">lm_connection_new_with_context</primary></indexterm><programlisting><link linkend="LmConnection">LmConnection</link> *      lm_connection_new_with_context      (const <link linkend="gchar">gchar</link> *server,
                                                         <link linkend="GMainContext">GMainContext</link> *context);</programlisting>
<para>
Creates a new closed connection running in a certain context. To open the 
connection call <link linkend="lm-connection-open"><type>lm_connection_open</type></link>. <parameter>server</parameter> can be <link linkend="NULL--CAPS"><type>NULL</type></link> but must be set 
before calling <link linkend="lm-connection-open"><type>lm_connection_open</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>server</parameter>&#160;:</term>
<listitem><simpara> The hostname to the server for the connection.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>context</parameter>&#160;:</term>
<listitem><simpara> The context this connection should be running in.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> A newly created LmConnection, should be unreffed with <link linkend="lm-connection-unref"><function>lm_connection_unref()</function></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-open" role="function">
<title>lm_connection_open ()</title>
<indexterm zone="lm-connection-open"><primary sortas="lm_connection_open">lm_connection_open</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_open                  (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmResultFunction">LmResultFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
An async call to open <parameter>connection</parameter>. When the connection is open <parameter>function</parameter> will be called.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to open
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter>&#160;:</term>
<listitem><simpara> Callback function that will be called when the connection is open.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User data that will be passed to <parameter>function</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>notify</parameter>&#160;:</term>
<listitem><simpara> Function for freeing that user_data, can be NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if everything went fine, otherwise <link linkend="FALSE--CAPS"><type>FALSE</type></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-open-and-block" role="function">
<title>lm_connection_open_and_block ()</title>
<indexterm zone="lm-connection-open-and-block"><primary sortas="lm_connection_open_and_block">lm_connection_open_and_block</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_open_and_block        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Opens <parameter>connection</parameter> and waits until the stream is setup.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link> to open
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where encountered during opening and stream setup successfully, <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-close" role="function">
<title>lm_connection_close ()</title>
<indexterm zone="lm-connection-close"><primary sortas="lm_connection_close">lm_connection_close</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_close                 (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
A synchronous call to close the connection. When returning the connection is considered to be closed and can be opened again with <link linkend="lm-connection-open"><function>lm_connection_open()</function></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to close 
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> Returns <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where detected, otherwise <link linkend="FALSE--CAPS"><type>FALSE</type></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-authenticate" role="function">
<title>lm_connection_authenticate ()</title>
<indexterm zone="lm-connection-authenticate"><primary sortas="lm_connection_authenticate">lm_connection_authenticate</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_authenticate          (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *username,
                                                         const <link linkend="gchar">gchar</link> *password,
                                                         const <link linkend="gchar">gchar</link> *resource,
                                                         <link linkend="LmResultFunction">LmResultFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Tries to authenticate a user against the server. The <link linkend="LmResult"><type>LmResult</type></link> in the result callback <parameter>function</parameter> will say whether it succeeded or not.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to authenticate.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>username</parameter>&#160;:</term>
<listitem><simpara> Username used to authenticate.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>password</parameter>&#160;:</term>
<listitem><simpara> Password corresponding to <parameter>username</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resource</parameter>&#160;:</term>
<listitem><simpara> Resource used for this connection.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter>&#160;:</term>
<listitem><simpara> Callback called when authentication is finished.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> Userdata passed to <parameter>function</parameter> when called.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>notify</parameter>&#160;:</term>
<listitem><simpara> Destroy function to free the memory used by <parameter>user_data</parameter>, can be NULL.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where detected while sending the authentication message, <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-authenticate-and-block" role="function">
<title>lm_connection_authenticate_and_block ()</title>
<indexterm zone="lm-connection-authenticate-and-block"><primary sortas="lm_connection_authenticate_and_block">lm_connection_authenticate_and_block</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_authenticate_and_block
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *username,
                                                         const <link linkend="gchar">gchar</link> *password,
                                                         const <link linkend="gchar">gchar</link> *resource,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Tries to authenticate a user against the server. This function blocks until a reply to the authentication attempt is returned and returns whether it was successful or not.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>username</parameter>&#160;:</term>
<listitem><simpara> Username used to authenticate.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>password</parameter>&#160;:</term>
<listitem><simpara> Password corresponding to <parameter>username</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resource</parameter>&#160;:</term>
<listitem><simpara> Resource used for this connection.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where detected and authentication was successful. <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-keep-alive-rate" role="function">
<title>lm_connection_get_keep_alive_rate ()</title>
<indexterm zone="lm-connection-get-keep-alive-rate"><primary sortas="lm_connection_get_keep_alive_rate">lm_connection_get_keep_alive_rate</primary></indexterm><programlisting><link linkend="guint">guint</link>               lm_connection_get_keep_alive_rate   (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Get the keep alive rate, in seconds. Zero is returned if no keep alive rate has been set.
</para>
<para>
Since 1.4.0</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link> 
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The keep alive rate in seconds.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-keep-alive-rate" role="function">
<title>lm_connection_set_keep_alive_rate ()</title>
<indexterm zone="lm-connection-set-keep-alive-rate"><primary sortas="lm_connection_set_keep_alive_rate">lm_connection_set_keep_alive_rate</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_keep_alive_rate   (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="guint">guint</link> rate);</programlisting>
<para>
Set the keep alive rate, in seconds. Set to 0 to prevent keep alive messages to be sent.
A keep alive message is a single space character.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>rate</parameter>&#160;:</term>
<listitem><simpara> Number of seconds between keep alive packages are sent.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-is-open" role="function">
<title>lm_connection_is_open ()</title>
<indexterm zone="lm-connection-is-open"><primary sortas="lm_connection_is_open">lm_connection_is_open</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_is_open               (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Check if the <parameter>connection</parameter> is currently open.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to check if it is open.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if connection is open and <link linkend="FALSE--CAPS"><type>FALSE</type></link> if it is closed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-is-authenticated" role="function">
<title>lm_connection_is_authenticated ()</title>
<indexterm zone="lm-connection-is-authenticated"><primary sortas="lm_connection_is_authenticated">lm_connection_is_authenticated</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_is_authenticated      (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Check if <parameter>connection</parameter> is authenticated.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to check if it is authenticated
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><type>TRUE</type></link> if connection is authenticated, <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-server" role="function">
<title>lm_connection_get_server ()</title>
<indexterm zone="lm-connection-get-server"><primary sortas="lm_connection_get_server">lm_connection_get_server</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link> *       lm_connection_get_server            (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Fetches the server address that <parameter>connection</parameter> is using.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the server address
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-server" role="function">
<title>lm_connection_set_server ()</title>
<indexterm zone="lm-connection-set-server"><primary sortas="lm_connection_set_server">lm_connection_set_server</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_server            (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *server);</programlisting>
<para>
Sets the server address for <parameter>connection</parameter> to <parameter>server</parameter>. Notice that <parameter>connection</parameter>
can't be open while doing this.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>server</parameter>&#160;:</term>
<listitem><simpara> Address of the server
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-jid" role="function">
<title>lm_connection_get_jid ()</title>
<indexterm zone="lm-connection-get-jid"><primary sortas="lm_connection_get_jid">lm_connection_get_jid</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link> *       lm_connection_get_jid               (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Fetches the jid set for <parameter>connection</parameter> is using.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the jid
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-jid" role="function">
<title>lm_connection_set_jid ()</title>
<indexterm zone="lm-connection-set-jid"><primary sortas="lm_connection_set_jid">lm_connection_set_jid</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_jid               (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *jid);</programlisting>
<para>
Sets the JID to be used for <parameter>connection</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>jid</parameter>&#160;:</term>
<listitem><simpara> JID to be used for <parameter>connection</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-port" role="function">
<title>lm_connection_get_port ()</title>
<indexterm zone="lm-connection-get-port"><primary sortas="lm_connection_get_port">lm_connection_get_port</primary></indexterm><programlisting><link linkend="guint">guint</link>               lm_connection_get_port              (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Fetches the port that <parameter>connection</parameter> is using.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The port used.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-port" role="function">
<title>lm_connection_set_port ()</title>
<indexterm zone="lm-connection-set-port"><primary sortas="lm_connection_set_port">lm_connection_set_port</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_port              (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="guint">guint</link> port);</programlisting>
<para>
Sets the server port that <parameter>connection</parameter> will be using.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>port</parameter>&#160;:</term>
<listitem><simpara> server port
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-ssl" role="function">
<title>lm_connection_get_ssl ()</title>
<indexterm zone="lm-connection-get-ssl"><primary sortas="lm_connection_get_ssl">lm_connection_get_ssl</primary></indexterm><programlisting><link linkend="LmSSL">LmSSL</link> *             lm_connection_get_ssl               (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Returns the SSL struct if the connection is using one.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The ssl struct or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if no proxy is used.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-ssl" role="function">
<title>lm_connection_set_ssl ()</title>
<indexterm zone="lm-connection-set-ssl"><primary sortas="lm_connection_set_ssl">lm_connection_set_ssl</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_ssl               (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmSSL">LmSSL</link> *ssl);</programlisting>
<para>
Sets SSL struct or unset if <parameter>ssl</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>. If set <parameter>connection</parameter> will use SSL to for the connection.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> An <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ssl</parameter>&#160;:</term>
<listitem><simpara> An <link linkend="LmSSL"><type>LmSSL</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-proxy" role="function">
<title>lm_connection_get_proxy ()</title>
<indexterm zone="lm-connection-get-proxy"><primary sortas="lm_connection_get_proxy">lm_connection_get_proxy</primary></indexterm><programlisting><link linkend="LmProxy">LmProxy</link> *           lm_connection_get_proxy             (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Returns the proxy if the connection is using one.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The proxy or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if no proxy is used.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-proxy" role="function">
<title>lm_connection_set_proxy ()</title>
<indexterm zone="lm-connection-set-proxy"><primary sortas="lm_connection_set_proxy">lm_connection_set_proxy</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_proxy             (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmProxy">LmProxy</link> *proxy);</programlisting>
<para>
Sets the proxy to use for this connection. To unset pass <link linkend="NULL--CAPS"><type>NULL</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>proxy</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmProxy"><type>LmProxy</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-send" role="function">
<title>lm_connection_send ()</title>
<indexterm zone="lm-connection-send"><primary sortas="lm_connection_send">lm_connection_send</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_send                  (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Asynchronous call to send a message.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> to send message over.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmMessage"><type>LmMessage</type></link> to send.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> Returns <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where detected while sending, <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-send-with-reply" role="function">
<title>lm_connection_send_with_reply ()</title>
<indexterm zone="lm-connection-send-with-reply"><primary sortas="lm_connection_send_with_reply">lm_connection_send_with_reply</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_send_with_reply       (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Send a <link linkend="LmMessage"><type>LmMessage</type></link> which will result in a reply.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmConnection"><type>LmConnection</type></link> used to send message.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmMessage"><type>LmMessage</type></link> to send.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler</parameter>&#160;:</term>
<listitem><simpara> <link linkend="LmMessageHandler"><type>LmMessageHandler</type></link> that will be used when a reply to <parameter>message</parameter> arrives
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> location to store error, or <link linkend="NULL--CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> Returns <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors where detected while sending, <link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-send-with-reply-and-block" role="function">
<title>lm_connection_send_with_reply_and_block ()</title>
<indexterm zone="lm-connection-send-with-reply-and-block"><primary sortas="lm_connection_send_with_reply_and_block">lm_connection_send_with_reply_and_block</primary></indexterm><programlisting><link linkend="LmMessage">LmMessage</link> *         lm_connection_send_with_reply_and_block
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessage">LmMessage</link> *message,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Send <parameter>message</parameter> and wait for return.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmConnection"><type>LmConnection</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>message</parameter>&#160;:</term>
<listitem><simpara> an <link linkend="LmMessage"><type>LmMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> Set if error was detected during sending.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The reply
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-register-message-handler" role="function">
<title>lm_connection_register_message_handler ()</title>
<indexterm zone="lm-connection-register-message-handler"><primary sortas="lm_connection_register_message_handler">lm_connection_register_message_handler</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_register_message_handler
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="LmMessageType">LmMessageType</link> type,
                                                         <link linkend="LmHandlerPriority">LmHandlerPriority</link> priority);</programlisting>
<para>
Registers a <link linkend="LmMessageHandler"><type>LmMessageHandler</type></link> to handle incoming messages of a certain type.
To unregister the handler call <link linkend="lm-connection-unregister-message-handler"><function>lm_connection_unregister_message_handler()</function></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to register a handler for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler</parameter>&#160;:</term>
<listitem><simpara> Message handler to register.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> Message type that <parameter>handler</parameter> will handle.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>priority</parameter>&#160;:</term>
<listitem><simpara> The priority in which to call <parameter>handler</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-unregister-message-handler" role="function">
<title>lm_connection_unregister_message_handler ()</title>
<indexterm zone="lm-connection-unregister-message-handler"><primary sortas="lm_connection_unregister_message_handler">lm_connection_unregister_message_handler</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_unregister_message_handler
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmMessageHandler">LmMessageHandler</link> *handler,
                                                         <link linkend="LmMessageType">LmMessageType</link> type);</programlisting>
<para>
Unregisters a handler for <parameter>connection</parameter>. <parameter>handler</parameter> will no longer be called 
when incoming messages of <parameter>type</parameter> arrive.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to unregister a handler for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>handler</parameter>&#160;:</term>
<listitem><simpara> The handler to unregister.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type</parameter>&#160;:</term>
<listitem><simpara> What type of messages to unregister this handler for.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-set-disconnect-function" role="function">
<title>lm_connection_set_disconnect_function ()</title>
<indexterm zone="lm-connection-set-disconnect-function"><primary sortas="lm_connection_set_disconnect_function">lm_connection_set_disconnect_function</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_set_disconnect_function
                                                        (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         <link linkend="LmDisconnectFunction">LmDisconnectFunction</link> function,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> notify);</programlisting>
<para>
Set the callback that will be called when a connection is closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to register disconnect callback for.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>function</parameter>&#160;:</term>
<listitem><simpara> Function to be called when <parameter>connection</parameter> is closed.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> User data passed to <parameter>function</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>notify</parameter>&#160;:</term>
<listitem><simpara> Function that will be called with <parameter>user_data</parameter> when <parameter>user_data</parameter> needs to be freed. Pass <link linkend="NULL--CAPS"><type>NULL</type></link> if it shouldn't be freed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-send-raw" role="function">
<title>lm_connection_send_raw ()</title>
<indexterm zone="lm-connection-send-raw"><primary sortas="lm_connection_send_raw">lm_connection_send_raw</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            lm_connection_send_raw              (<link linkend="LmConnection">LmConnection</link> *connection,
                                                         const <link linkend="gchar">gchar</link> *str,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Asynchronous call to send a raw string. Useful for debugging and testing.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection used to send
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>str</parameter>&#160;:</term>
<listitem><simpara> The string to send, the entire string will be sent.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&#160;:</term>
<listitem><simpara> Set if error was detected during sending.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> Returns <link linkend="TRUE--CAPS"><type>TRUE</type></link> if no errors was detected during sending, 
<link linkend="FALSE--CAPS"><type>FALSE</type></link> otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-get-state" role="function">
<title>lm_connection_get_state ()</title>
<indexterm zone="lm-connection-get-state"><primary sortas="lm_connection_get_state">lm_connection_get_state</primary></indexterm><programlisting><link linkend="LmConnectionState">LmConnectionState</link>   lm_connection_get_state             (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Returns the state of the connection.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to get state on
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> The state of the connection.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-ref" role="function">
<title>lm_connection_ref ()</title>
<indexterm zone="lm-connection-ref"><primary sortas="lm_connection_ref">lm_connection_ref</primary></indexterm><programlisting><link linkend="LmConnection">LmConnection</link>*       lm_connection_ref                   (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Add a reference on <parameter>connection</parameter>. To remove a reference call 
<link linkend="lm-connection-unref"><function>lm_connection_unref()</function></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to add a reference to.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> Returns the same connection.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="lm-connection-unref" role="function">
<title>lm_connection_unref ()</title>
<indexterm zone="lm-connection-unref"><primary sortas="lm_connection_unref">lm_connection_unref</primary></indexterm><programlisting><link linkend="void">void</link>                lm_connection_unref                 (<link linkend="LmConnection">LmConnection</link> *connection);</programlisting>
<para>
Removes a reference on <parameter>connection</parameter>. If there are no references to
<parameter>connection</parameter> it will be freed and shouldn't be used again.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>connection</parameter>&#160;:</term>
<listitem><simpara> Connection to remove reference from.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
